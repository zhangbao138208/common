// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"

	"gitlab.skig.tech/zero-core/common/ent/common"
	"gitlab.skig.tech/zero-core/common/ent/winbetslip"
	"gitlab.skig.tech/zero-core/common/ent/winbetslipsdetail"
	"gitlab.skig.tech/zero-core/common/ent/wincoinlog"
	"gitlab.skig.tech/zero-core/common/ent/winconfig"
	"gitlab.skig.tech/zero-core/common/ent/windict"
	"gitlab.skig.tech/zero-core/common/ent/windictitem"
	"gitlab.skig.tech/zero-core/common/ent/wingamelist"
	"gitlab.skig.tech/zero-core/common/ent/wingameslot"
	"gitlab.skig.tech/zero-core/common/ent/winplatlist"
	"gitlab.skig.tech/zero-core/common/ent/winuser"
	"gitlab.skig.tech/zero-core/common/ent/winuserwallet"
)

const errInvalidPage = "INVALID_PAGE"

const (
	listField     = "list"
	pageNumField  = "pageNum"
	pageSizeField = "pageSize"
)

type PageDetails struct {
	Page  uint64 `json:"page"`
	Size  uint64 `json:"size"`
	Total uint64 `json:"total"`
}

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

const errInvalidPagination = "INVALID_PAGINATION"

type CommonPager struct {
	Order  common.OrderOption
	Filter func(*CommonQuery) (*CommonQuery, error)
}

// CommonPaginateOption enables pagination customization.
type CommonPaginateOption func(*CommonPager)

// DefaultCommonOrder is the default ordering of Common.
var DefaultCommonOrder = Desc(common.FieldID)

func newCommonPager(opts []CommonPaginateOption) (*CommonPager, error) {
	pager := &CommonPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultCommonOrder
	}
	return pager, nil
}

func (p *CommonPager) ApplyFilter(query *CommonQuery) (*CommonQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// CommonPageList is Common PageList result.
type CommonPageList struct {
	List        []*Common    `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (c *CommonQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...CommonPaginateOption,
) (*CommonPageList, error) {

	pager, err := newCommonPager(opts)
	if err != nil {
		return nil, err
	}

	if c, err = pager.ApplyFilter(c); err != nil {
		return nil, err
	}

	ret := &CommonPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	count, err := c.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		c = c.Order(pager.Order)
	} else {
		c = c.Order(DefaultCommonOrder)
	}

	c = c.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type WinBetslipPager struct {
	Order  winbetslip.OrderOption
	Filter func(*WinBetslipQuery) (*WinBetslipQuery, error)
}

// WinBetslipPaginateOption enables pagination customization.
type WinBetslipPaginateOption func(*WinBetslipPager)

// DefaultWinBetslipOrder is the default ordering of WinBetslip.
var DefaultWinBetslipOrder = Desc(winbetslip.FieldID)

func newWinBetslipPager(opts []WinBetslipPaginateOption) (*WinBetslipPager, error) {
	pager := &WinBetslipPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultWinBetslipOrder
	}
	return pager, nil
}

func (p *WinBetslipPager) ApplyFilter(query *WinBetslipQuery) (*WinBetslipQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// WinBetslipPageList is WinBetslip PageList result.
type WinBetslipPageList struct {
	List        []*WinBetslip `json:"list"`
	PageDetails *PageDetails  `json:"pageDetails"`
}

func (wb *WinBetslipQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...WinBetslipPaginateOption,
) (*WinBetslipPageList, error) {

	pager, err := newWinBetslipPager(opts)
	if err != nil {
		return nil, err
	}

	if wb, err = pager.ApplyFilter(wb); err != nil {
		return nil, err
	}

	ret := &WinBetslipPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	count, err := wb.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		wb = wb.Order(pager.Order)
	} else {
		wb = wb.Order(DefaultWinBetslipOrder)
	}

	wb = wb.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := wb.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type WinBetslipsDetailPager struct {
	Order  winbetslipsdetail.OrderOption
	Filter func(*WinBetslipsDetailQuery) (*WinBetslipsDetailQuery, error)
}

// WinBetslipsDetailPaginateOption enables pagination customization.
type WinBetslipsDetailPaginateOption func(*WinBetslipsDetailPager)

// DefaultWinBetslipsDetailOrder is the default ordering of WinBetslipsDetail.
var DefaultWinBetslipsDetailOrder = Desc(winbetslipsdetail.FieldID)

func newWinBetslipsDetailPager(opts []WinBetslipsDetailPaginateOption) (*WinBetslipsDetailPager, error) {
	pager := &WinBetslipsDetailPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultWinBetslipsDetailOrder
	}
	return pager, nil
}

func (p *WinBetslipsDetailPager) ApplyFilter(query *WinBetslipsDetailQuery) (*WinBetslipsDetailQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// WinBetslipsDetailPageList is WinBetslipsDetail PageList result.
type WinBetslipsDetailPageList struct {
	List        []*WinBetslipsDetail `json:"list"`
	PageDetails *PageDetails         `json:"pageDetails"`
}

func (wbd *WinBetslipsDetailQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...WinBetslipsDetailPaginateOption,
) (*WinBetslipsDetailPageList, error) {

	pager, err := newWinBetslipsDetailPager(opts)
	if err != nil {
		return nil, err
	}

	if wbd, err = pager.ApplyFilter(wbd); err != nil {
		return nil, err
	}

	ret := &WinBetslipsDetailPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	count, err := wbd.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		wbd = wbd.Order(pager.Order)
	} else {
		wbd = wbd.Order(DefaultWinBetslipsDetailOrder)
	}

	wbd = wbd.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := wbd.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type WinCoinLogPager struct {
	Order  wincoinlog.OrderOption
	Filter func(*WinCoinLogQuery) (*WinCoinLogQuery, error)
}

// WinCoinLogPaginateOption enables pagination customization.
type WinCoinLogPaginateOption func(*WinCoinLogPager)

// DefaultWinCoinLogOrder is the default ordering of WinCoinLog.
var DefaultWinCoinLogOrder = Desc(wincoinlog.FieldID)

func newWinCoinLogPager(opts []WinCoinLogPaginateOption) (*WinCoinLogPager, error) {
	pager := &WinCoinLogPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultWinCoinLogOrder
	}
	return pager, nil
}

func (p *WinCoinLogPager) ApplyFilter(query *WinCoinLogQuery) (*WinCoinLogQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// WinCoinLogPageList is WinCoinLog PageList result.
type WinCoinLogPageList struct {
	List        []*WinCoinLog `json:"list"`
	PageDetails *PageDetails  `json:"pageDetails"`
}

func (wcl *WinCoinLogQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...WinCoinLogPaginateOption,
) (*WinCoinLogPageList, error) {

	pager, err := newWinCoinLogPager(opts)
	if err != nil {
		return nil, err
	}

	if wcl, err = pager.ApplyFilter(wcl); err != nil {
		return nil, err
	}

	ret := &WinCoinLogPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	count, err := wcl.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		wcl = wcl.Order(pager.Order)
	} else {
		wcl = wcl.Order(DefaultWinCoinLogOrder)
	}

	wcl = wcl.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := wcl.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type WinConfigPager struct {
	Order  winconfig.OrderOption
	Filter func(*WinConfigQuery) (*WinConfigQuery, error)
}

// WinConfigPaginateOption enables pagination customization.
type WinConfigPaginateOption func(*WinConfigPager)

// DefaultWinConfigOrder is the default ordering of WinConfig.
var DefaultWinConfigOrder = Desc(winconfig.FieldID)

func newWinConfigPager(opts []WinConfigPaginateOption) (*WinConfigPager, error) {
	pager := &WinConfigPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultWinConfigOrder
	}
	return pager, nil
}

func (p *WinConfigPager) ApplyFilter(query *WinConfigQuery) (*WinConfigQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// WinConfigPageList is WinConfig PageList result.
type WinConfigPageList struct {
	List        []*WinConfig `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (wc *WinConfigQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...WinConfigPaginateOption,
) (*WinConfigPageList, error) {

	pager, err := newWinConfigPager(opts)
	if err != nil {
		return nil, err
	}

	if wc, err = pager.ApplyFilter(wc); err != nil {
		return nil, err
	}

	ret := &WinConfigPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	count, err := wc.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		wc = wc.Order(pager.Order)
	} else {
		wc = wc.Order(DefaultWinConfigOrder)
	}

	wc = wc.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := wc.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type WinDictPager struct {
	Order  windict.OrderOption
	Filter func(*WinDictQuery) (*WinDictQuery, error)
}

// WinDictPaginateOption enables pagination customization.
type WinDictPaginateOption func(*WinDictPager)

// DefaultWinDictOrder is the default ordering of WinDict.
var DefaultWinDictOrder = Desc(windict.FieldID)

func newWinDictPager(opts []WinDictPaginateOption) (*WinDictPager, error) {
	pager := &WinDictPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultWinDictOrder
	}
	return pager, nil
}

func (p *WinDictPager) ApplyFilter(query *WinDictQuery) (*WinDictQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// WinDictPageList is WinDict PageList result.
type WinDictPageList struct {
	List        []*WinDict   `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (wd *WinDictQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...WinDictPaginateOption,
) (*WinDictPageList, error) {

	pager, err := newWinDictPager(opts)
	if err != nil {
		return nil, err
	}

	if wd, err = pager.ApplyFilter(wd); err != nil {
		return nil, err
	}

	ret := &WinDictPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	count, err := wd.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		wd = wd.Order(pager.Order)
	} else {
		wd = wd.Order(DefaultWinDictOrder)
	}

	wd = wd.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := wd.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type WinDictItemPager struct {
	Order  windictitem.OrderOption
	Filter func(*WinDictItemQuery) (*WinDictItemQuery, error)
}

// WinDictItemPaginateOption enables pagination customization.
type WinDictItemPaginateOption func(*WinDictItemPager)

// DefaultWinDictItemOrder is the default ordering of WinDictItem.
var DefaultWinDictItemOrder = Desc(windictitem.FieldID)

func newWinDictItemPager(opts []WinDictItemPaginateOption) (*WinDictItemPager, error) {
	pager := &WinDictItemPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultWinDictItemOrder
	}
	return pager, nil
}

func (p *WinDictItemPager) ApplyFilter(query *WinDictItemQuery) (*WinDictItemQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// WinDictItemPageList is WinDictItem PageList result.
type WinDictItemPageList struct {
	List        []*WinDictItem `json:"list"`
	PageDetails *PageDetails   `json:"pageDetails"`
}

func (wdi *WinDictItemQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...WinDictItemPaginateOption,
) (*WinDictItemPageList, error) {

	pager, err := newWinDictItemPager(opts)
	if err != nil {
		return nil, err
	}

	if wdi, err = pager.ApplyFilter(wdi); err != nil {
		return nil, err
	}

	ret := &WinDictItemPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	count, err := wdi.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		wdi = wdi.Order(pager.Order)
	} else {
		wdi = wdi.Order(DefaultWinDictItemOrder)
	}

	wdi = wdi.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := wdi.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type WinGameListPager struct {
	Order  wingamelist.OrderOption
	Filter func(*WinGameListQuery) (*WinGameListQuery, error)
}

// WinGameListPaginateOption enables pagination customization.
type WinGameListPaginateOption func(*WinGameListPager)

// DefaultWinGameListOrder is the default ordering of WinGameList.
var DefaultWinGameListOrder = Desc(wingamelist.FieldID)

func newWinGameListPager(opts []WinGameListPaginateOption) (*WinGameListPager, error) {
	pager := &WinGameListPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultWinGameListOrder
	}
	return pager, nil
}

func (p *WinGameListPager) ApplyFilter(query *WinGameListQuery) (*WinGameListQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// WinGameListPageList is WinGameList PageList result.
type WinGameListPageList struct {
	List        []*WinGameList `json:"list"`
	PageDetails *PageDetails   `json:"pageDetails"`
}

func (wgl *WinGameListQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...WinGameListPaginateOption,
) (*WinGameListPageList, error) {

	pager, err := newWinGameListPager(opts)
	if err != nil {
		return nil, err
	}

	if wgl, err = pager.ApplyFilter(wgl); err != nil {
		return nil, err
	}

	ret := &WinGameListPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	count, err := wgl.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		wgl = wgl.Order(pager.Order)
	} else {
		wgl = wgl.Order(DefaultWinGameListOrder)
	}

	wgl = wgl.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := wgl.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type WinGameSlotPager struct {
	Order  wingameslot.OrderOption
	Filter func(*WinGameSlotQuery) (*WinGameSlotQuery, error)
}

// WinGameSlotPaginateOption enables pagination customization.
type WinGameSlotPaginateOption func(*WinGameSlotPager)

// DefaultWinGameSlotOrder is the default ordering of WinGameSlot.
var DefaultWinGameSlotOrder = Desc(wingameslot.FieldID)

func newWinGameSlotPager(opts []WinGameSlotPaginateOption) (*WinGameSlotPager, error) {
	pager := &WinGameSlotPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultWinGameSlotOrder
	}
	return pager, nil
}

func (p *WinGameSlotPager) ApplyFilter(query *WinGameSlotQuery) (*WinGameSlotQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// WinGameSlotPageList is WinGameSlot PageList result.
type WinGameSlotPageList struct {
	List        []*WinGameSlot `json:"list"`
	PageDetails *PageDetails   `json:"pageDetails"`
}

func (wgs *WinGameSlotQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...WinGameSlotPaginateOption,
) (*WinGameSlotPageList, error) {

	pager, err := newWinGameSlotPager(opts)
	if err != nil {
		return nil, err
	}

	if wgs, err = pager.ApplyFilter(wgs); err != nil {
		return nil, err
	}

	ret := &WinGameSlotPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	count, err := wgs.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		wgs = wgs.Order(pager.Order)
	} else {
		wgs = wgs.Order(DefaultWinGameSlotOrder)
	}

	wgs = wgs.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := wgs.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type WinPlatListPager struct {
	Order  winplatlist.OrderOption
	Filter func(*WinPlatListQuery) (*WinPlatListQuery, error)
}

// WinPlatListPaginateOption enables pagination customization.
type WinPlatListPaginateOption func(*WinPlatListPager)

// DefaultWinPlatListOrder is the default ordering of WinPlatList.
var DefaultWinPlatListOrder = Desc(winplatlist.FieldID)

func newWinPlatListPager(opts []WinPlatListPaginateOption) (*WinPlatListPager, error) {
	pager := &WinPlatListPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultWinPlatListOrder
	}
	return pager, nil
}

func (p *WinPlatListPager) ApplyFilter(query *WinPlatListQuery) (*WinPlatListQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// WinPlatListPageList is WinPlatList PageList result.
type WinPlatListPageList struct {
	List        []*WinPlatList `json:"list"`
	PageDetails *PageDetails   `json:"pageDetails"`
}

func (wpl *WinPlatListQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...WinPlatListPaginateOption,
) (*WinPlatListPageList, error) {

	pager, err := newWinPlatListPager(opts)
	if err != nil {
		return nil, err
	}

	if wpl, err = pager.ApplyFilter(wpl); err != nil {
		return nil, err
	}

	ret := &WinPlatListPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	count, err := wpl.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		wpl = wpl.Order(pager.Order)
	} else {
		wpl = wpl.Order(DefaultWinPlatListOrder)
	}

	wpl = wpl.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := wpl.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type WinUserPager struct {
	Order  winuser.OrderOption
	Filter func(*WinUserQuery) (*WinUserQuery, error)
}

// WinUserPaginateOption enables pagination customization.
type WinUserPaginateOption func(*WinUserPager)

// DefaultWinUserOrder is the default ordering of WinUser.
var DefaultWinUserOrder = Desc(winuser.FieldID)

func newWinUserPager(opts []WinUserPaginateOption) (*WinUserPager, error) {
	pager := &WinUserPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultWinUserOrder
	}
	return pager, nil
}

func (p *WinUserPager) ApplyFilter(query *WinUserQuery) (*WinUserQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// WinUserPageList is WinUser PageList result.
type WinUserPageList struct {
	List        []*WinUser   `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (wu *WinUserQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...WinUserPaginateOption,
) (*WinUserPageList, error) {

	pager, err := newWinUserPager(opts)
	if err != nil {
		return nil, err
	}

	if wu, err = pager.ApplyFilter(wu); err != nil {
		return nil, err
	}

	ret := &WinUserPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	count, err := wu.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		wu = wu.Order(pager.Order)
	} else {
		wu = wu.Order(DefaultWinUserOrder)
	}

	wu = wu.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := wu.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type WinUserWalletPager struct {
	Order  winuserwallet.OrderOption
	Filter func(*WinUserWalletQuery) (*WinUserWalletQuery, error)
}

// WinUserWalletPaginateOption enables pagination customization.
type WinUserWalletPaginateOption func(*WinUserWalletPager)

// DefaultWinUserWalletOrder is the default ordering of WinUserWallet.
var DefaultWinUserWalletOrder = Desc(winuserwallet.FieldID)

func newWinUserWalletPager(opts []WinUserWalletPaginateOption) (*WinUserWalletPager, error) {
	pager := &WinUserWalletPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultWinUserWalletOrder
	}
	return pager, nil
}

func (p *WinUserWalletPager) ApplyFilter(query *WinUserWalletQuery) (*WinUserWalletQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// WinUserWalletPageList is WinUserWallet PageList result.
type WinUserWalletPageList struct {
	List        []*WinUserWallet `json:"list"`
	PageDetails *PageDetails     `json:"pageDetails"`
}

func (wuw *WinUserWalletQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...WinUserWalletPaginateOption,
) (*WinUserWalletPageList, error) {

	pager, err := newWinUserWalletPager(opts)
	if err != nil {
		return nil, err
	}

	if wuw, err = pager.ApplyFilter(wuw); err != nil {
		return nil, err
	}

	ret := &WinUserWalletPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	count, err := wuw.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		wuw = wuw.Order(pager.Order)
	} else {
		wuw = wuw.Order(DefaultWinUserWalletOrder)
	}

	wuw = wuw.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := wuw.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}
