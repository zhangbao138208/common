// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"gitlab.skig.tech/zero-core/common/ent/predicate"
	"gitlab.skig.tech/zero-core/common/ent/winbetslip"
	"gitlab.skig.tech/zero-core/common/ent/winbetslipsdetail"
	"gitlab.skig.tech/zero-core/common/ent/wincoinlog"
	"gitlab.skig.tech/zero-core/common/ent/winconfig"
	"gitlab.skig.tech/zero-core/common/ent/windict"
	"gitlab.skig.tech/zero-core/common/ent/windictitem"
	"gitlab.skig.tech/zero-core/common/ent/wingamelist"
	"gitlab.skig.tech/zero-core/common/ent/wingameslot"
	"gitlab.skig.tech/zero-core/common/ent/winplatlist"
	"gitlab.skig.tech/zero-core/common/ent/winuser"
	"gitlab.skig.tech/zero-core/common/ent/winuserwallet"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCommon            = "Common"
	TypeWinBetslip        = "WinBetslip"
	TypeWinBetslipsDetail = "WinBetslipsDetail"
	TypeWinCoinLog        = "WinCoinLog"
	TypeWinConfig         = "WinConfig"
	TypeWinDict           = "WinDict"
	TypeWinDictItem       = "WinDictItem"
	TypeWinGameList       = "WinGameList"
	TypeWinGameSlot       = "WinGameSlot"
	TypeWinPlatList       = "WinPlatList"
	TypeWinUser           = "WinUser"
	TypeWinUserWallet     = "WinUserWallet"
)

// CommonMutation represents an operation that mutates the Common nodes in the graph.
type CommonMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Common, error)
	predicates    []predicate.Common
}

var _ ent.Mutation = (*CommonMutation)(nil)

// commonOption allows management of the mutation configuration using functional options.
type commonOption func(*CommonMutation)

// newCommonMutation creates new mutation for the Common entity.
func newCommonMutation(c config, op Op, opts ...commonOption) *CommonMutation {
	m := &CommonMutation{
		config:        c,
		op:            op,
		typ:           TypeCommon,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommonID sets the ID field of the mutation.
func withCommonID(id int) commonOption {
	return func(m *CommonMutation) {
		var (
			err   error
			once  sync.Once
			value *Common
		)
		m.oldValue = func(ctx context.Context) (*Common, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Common.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommon sets the old Common of the mutation.
func withCommon(node *Common) commonOption {
	return func(m *CommonMutation) {
		m.oldValue = func(context.Context) (*Common, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommonMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommonMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Common.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the CommonMutation builder.
func (m *CommonMutation) Where(ps ...predicate.Common) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommonMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommonMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Common, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommonMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommonMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Common).
func (m *CommonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommonMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommonMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Common field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommonMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Common field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommonMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommonMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommonMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Common numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommonMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommonMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Common nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommonMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Common field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommonMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommonMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommonMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommonMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommonMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Common unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommonMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Common edge %s", name)
}

// WinBetslipMutation represents an operation that mutates the WinBetslip nodes in the graph.
type WinBetslipMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	round_id           *string
	transaction_id     *string
	game_plat_id       *int32
	addgame_plat_id    *int32
	xb_status          *int8
	addxb_status       *int8
	xb_uid             *uint32
	addxb_uid          *int32
	xb_username        *string
	xb_profit          *float64
	addxb_profit       *float64
	stake              *float64
	addstake           *float64
	valid_stake        *float64
	addvalid_stake     *float64
	payout             *float64
	addpayout          *float64
	coin_refund        *float64
	addcoin_refund     *float64
	coin_before        *float64
	addcoin_before     *float64
	game_id            *string
	game_name          *string
	amount_type        *int32
	addamount_type     *int32
	game_type_id       *string
	game_group_id      *int32
	addgame_group_id   *int32
	sport_type         *string
	dt_started         *int
	adddt_started      *int
	dt_completed       *int
	adddt_completed    *int
	win_transaction_id *string
	bet_json           *string
	reward_json        *string
	refund_json        *string
	create_time_str    *string
	created_at         *int32
	addcreated_at      *int32
	updated_at         *int32
	addupdated_at      *int32
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*WinBetslip, error)
	predicates         []predicate.WinBetslip
}

var _ ent.Mutation = (*WinBetslipMutation)(nil)

// winbetslipOption allows management of the mutation configuration using functional options.
type winbetslipOption func(*WinBetslipMutation)

// newWinBetslipMutation creates new mutation for the WinBetslip entity.
func newWinBetslipMutation(c config, op Op, opts ...winbetslipOption) *WinBetslipMutation {
	m := &WinBetslipMutation{
		config:        c,
		op:            op,
		typ:           TypeWinBetslip,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWinBetslipID sets the ID field of the mutation.
func withWinBetslipID(id int) winbetslipOption {
	return func(m *WinBetslipMutation) {
		var (
			err   error
			once  sync.Once
			value *WinBetslip
		)
		m.oldValue = func(ctx context.Context) (*WinBetslip, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WinBetslip.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWinBetslip sets the old WinBetslip of the mutation.
func withWinBetslip(node *WinBetslip) winbetslipOption {
	return func(m *WinBetslipMutation) {
		m.oldValue = func(context.Context) (*WinBetslip, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WinBetslipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WinBetslipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WinBetslip entities.
func (m *WinBetslipMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WinBetslipMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WinBetslipMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WinBetslip.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRoundID sets the "round_id" field.
func (m *WinBetslipMutation) SetRoundID(s string) {
	m.round_id = &s
}

// RoundID returns the value of the "round_id" field in the mutation.
func (m *WinBetslipMutation) RoundID() (r string, exists bool) {
	v := m.round_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoundID returns the old "round_id" field's value of the WinBetslip entity.
// If the WinBetslip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipMutation) OldRoundID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoundID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoundID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoundID: %w", err)
	}
	return oldValue.RoundID, nil
}

// ResetRoundID resets all changes to the "round_id" field.
func (m *WinBetslipMutation) ResetRoundID() {
	m.round_id = nil
}

// SetTransactionID sets the "transaction_id" field.
func (m *WinBetslipMutation) SetTransactionID(s string) {
	m.transaction_id = &s
}

// TransactionID returns the value of the "transaction_id" field in the mutation.
func (m *WinBetslipMutation) TransactionID() (r string, exists bool) {
	v := m.transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionID returns the old "transaction_id" field's value of the WinBetslip entity.
// If the WinBetslip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipMutation) OldTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionID: %w", err)
	}
	return oldValue.TransactionID, nil
}

// ResetTransactionID resets all changes to the "transaction_id" field.
func (m *WinBetslipMutation) ResetTransactionID() {
	m.transaction_id = nil
}

// SetGamePlatID sets the "game_plat_id" field.
func (m *WinBetslipMutation) SetGamePlatID(i int32) {
	m.game_plat_id = &i
	m.addgame_plat_id = nil
}

// GamePlatID returns the value of the "game_plat_id" field in the mutation.
func (m *WinBetslipMutation) GamePlatID() (r int32, exists bool) {
	v := m.game_plat_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGamePlatID returns the old "game_plat_id" field's value of the WinBetslip entity.
// If the WinBetslip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipMutation) OldGamePlatID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGamePlatID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGamePlatID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGamePlatID: %w", err)
	}
	return oldValue.GamePlatID, nil
}

// AddGamePlatID adds i to the "game_plat_id" field.
func (m *WinBetslipMutation) AddGamePlatID(i int32) {
	if m.addgame_plat_id != nil {
		*m.addgame_plat_id += i
	} else {
		m.addgame_plat_id = &i
	}
}

// AddedGamePlatID returns the value that was added to the "game_plat_id" field in this mutation.
func (m *WinBetslipMutation) AddedGamePlatID() (r int32, exists bool) {
	v := m.addgame_plat_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetGamePlatID resets all changes to the "game_plat_id" field.
func (m *WinBetslipMutation) ResetGamePlatID() {
	m.game_plat_id = nil
	m.addgame_plat_id = nil
}

// SetXbStatus sets the "xb_status" field.
func (m *WinBetslipMutation) SetXbStatus(i int8) {
	m.xb_status = &i
	m.addxb_status = nil
}

// XbStatus returns the value of the "xb_status" field in the mutation.
func (m *WinBetslipMutation) XbStatus() (r int8, exists bool) {
	v := m.xb_status
	if v == nil {
		return
	}
	return *v, true
}

// OldXbStatus returns the old "xb_status" field's value of the WinBetslip entity.
// If the WinBetslip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipMutation) OldXbStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldXbStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldXbStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldXbStatus: %w", err)
	}
	return oldValue.XbStatus, nil
}

// AddXbStatus adds i to the "xb_status" field.
func (m *WinBetslipMutation) AddXbStatus(i int8) {
	if m.addxb_status != nil {
		*m.addxb_status += i
	} else {
		m.addxb_status = &i
	}
}

// AddedXbStatus returns the value that was added to the "xb_status" field in this mutation.
func (m *WinBetslipMutation) AddedXbStatus() (r int8, exists bool) {
	v := m.addxb_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetXbStatus resets all changes to the "xb_status" field.
func (m *WinBetslipMutation) ResetXbStatus() {
	m.xb_status = nil
	m.addxb_status = nil
}

// SetXbUID sets the "xb_uid" field.
func (m *WinBetslipMutation) SetXbUID(u uint32) {
	m.xb_uid = &u
	m.addxb_uid = nil
}

// XbUID returns the value of the "xb_uid" field in the mutation.
func (m *WinBetslipMutation) XbUID() (r uint32, exists bool) {
	v := m.xb_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldXbUID returns the old "xb_uid" field's value of the WinBetslip entity.
// If the WinBetslip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipMutation) OldXbUID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldXbUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldXbUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldXbUID: %w", err)
	}
	return oldValue.XbUID, nil
}

// AddXbUID adds u to the "xb_uid" field.
func (m *WinBetslipMutation) AddXbUID(u int32) {
	if m.addxb_uid != nil {
		*m.addxb_uid += u
	} else {
		m.addxb_uid = &u
	}
}

// AddedXbUID returns the value that was added to the "xb_uid" field in this mutation.
func (m *WinBetslipMutation) AddedXbUID() (r int32, exists bool) {
	v := m.addxb_uid
	if v == nil {
		return
	}
	return *v, true
}

// ResetXbUID resets all changes to the "xb_uid" field.
func (m *WinBetslipMutation) ResetXbUID() {
	m.xb_uid = nil
	m.addxb_uid = nil
}

// SetXbUsername sets the "xb_username" field.
func (m *WinBetslipMutation) SetXbUsername(s string) {
	m.xb_username = &s
}

// XbUsername returns the value of the "xb_username" field in the mutation.
func (m *WinBetslipMutation) XbUsername() (r string, exists bool) {
	v := m.xb_username
	if v == nil {
		return
	}
	return *v, true
}

// OldXbUsername returns the old "xb_username" field's value of the WinBetslip entity.
// If the WinBetslip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipMutation) OldXbUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldXbUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldXbUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldXbUsername: %w", err)
	}
	return oldValue.XbUsername, nil
}

// ResetXbUsername resets all changes to the "xb_username" field.
func (m *WinBetslipMutation) ResetXbUsername() {
	m.xb_username = nil
}

// SetXbProfit sets the "xb_profit" field.
func (m *WinBetslipMutation) SetXbProfit(f float64) {
	m.xb_profit = &f
	m.addxb_profit = nil
}

// XbProfit returns the value of the "xb_profit" field in the mutation.
func (m *WinBetslipMutation) XbProfit() (r float64, exists bool) {
	v := m.xb_profit
	if v == nil {
		return
	}
	return *v, true
}

// OldXbProfit returns the old "xb_profit" field's value of the WinBetslip entity.
// If the WinBetslip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipMutation) OldXbProfit(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldXbProfit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldXbProfit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldXbProfit: %w", err)
	}
	return oldValue.XbProfit, nil
}

// AddXbProfit adds f to the "xb_profit" field.
func (m *WinBetslipMutation) AddXbProfit(f float64) {
	if m.addxb_profit != nil {
		*m.addxb_profit += f
	} else {
		m.addxb_profit = &f
	}
}

// AddedXbProfit returns the value that was added to the "xb_profit" field in this mutation.
func (m *WinBetslipMutation) AddedXbProfit() (r float64, exists bool) {
	v := m.addxb_profit
	if v == nil {
		return
	}
	return *v, true
}

// ClearXbProfit clears the value of the "xb_profit" field.
func (m *WinBetslipMutation) ClearXbProfit() {
	m.xb_profit = nil
	m.addxb_profit = nil
	m.clearedFields[winbetslip.FieldXbProfit] = struct{}{}
}

// XbProfitCleared returns if the "xb_profit" field was cleared in this mutation.
func (m *WinBetslipMutation) XbProfitCleared() bool {
	_, ok := m.clearedFields[winbetslip.FieldXbProfit]
	return ok
}

// ResetXbProfit resets all changes to the "xb_profit" field.
func (m *WinBetslipMutation) ResetXbProfit() {
	m.xb_profit = nil
	m.addxb_profit = nil
	delete(m.clearedFields, winbetslip.FieldXbProfit)
}

// SetStake sets the "stake" field.
func (m *WinBetslipMutation) SetStake(f float64) {
	m.stake = &f
	m.addstake = nil
}

// Stake returns the value of the "stake" field in the mutation.
func (m *WinBetslipMutation) Stake() (r float64, exists bool) {
	v := m.stake
	if v == nil {
		return
	}
	return *v, true
}

// OldStake returns the old "stake" field's value of the WinBetslip entity.
// If the WinBetslip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipMutation) OldStake(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStake is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStake requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStake: %w", err)
	}
	return oldValue.Stake, nil
}

// AddStake adds f to the "stake" field.
func (m *WinBetslipMutation) AddStake(f float64) {
	if m.addstake != nil {
		*m.addstake += f
	} else {
		m.addstake = &f
	}
}

// AddedStake returns the value that was added to the "stake" field in this mutation.
func (m *WinBetslipMutation) AddedStake() (r float64, exists bool) {
	v := m.addstake
	if v == nil {
		return
	}
	return *v, true
}

// ResetStake resets all changes to the "stake" field.
func (m *WinBetslipMutation) ResetStake() {
	m.stake = nil
	m.addstake = nil
}

// SetValidStake sets the "valid_stake" field.
func (m *WinBetslipMutation) SetValidStake(f float64) {
	m.valid_stake = &f
	m.addvalid_stake = nil
}

// ValidStake returns the value of the "valid_stake" field in the mutation.
func (m *WinBetslipMutation) ValidStake() (r float64, exists bool) {
	v := m.valid_stake
	if v == nil {
		return
	}
	return *v, true
}

// OldValidStake returns the old "valid_stake" field's value of the WinBetslip entity.
// If the WinBetslip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipMutation) OldValidStake(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidStake is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidStake requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidStake: %w", err)
	}
	return oldValue.ValidStake, nil
}

// AddValidStake adds f to the "valid_stake" field.
func (m *WinBetslipMutation) AddValidStake(f float64) {
	if m.addvalid_stake != nil {
		*m.addvalid_stake += f
	} else {
		m.addvalid_stake = &f
	}
}

// AddedValidStake returns the value that was added to the "valid_stake" field in this mutation.
func (m *WinBetslipMutation) AddedValidStake() (r float64, exists bool) {
	v := m.addvalid_stake
	if v == nil {
		return
	}
	return *v, true
}

// ResetValidStake resets all changes to the "valid_stake" field.
func (m *WinBetslipMutation) ResetValidStake() {
	m.valid_stake = nil
	m.addvalid_stake = nil
}

// SetPayout sets the "payout" field.
func (m *WinBetslipMutation) SetPayout(f float64) {
	m.payout = &f
	m.addpayout = nil
}

// Payout returns the value of the "payout" field in the mutation.
func (m *WinBetslipMutation) Payout() (r float64, exists bool) {
	v := m.payout
	if v == nil {
		return
	}
	return *v, true
}

// OldPayout returns the old "payout" field's value of the WinBetslip entity.
// If the WinBetslip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipMutation) OldPayout(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayout: %w", err)
	}
	return oldValue.Payout, nil
}

// AddPayout adds f to the "payout" field.
func (m *WinBetslipMutation) AddPayout(f float64) {
	if m.addpayout != nil {
		*m.addpayout += f
	} else {
		m.addpayout = &f
	}
}

// AddedPayout returns the value that was added to the "payout" field in this mutation.
func (m *WinBetslipMutation) AddedPayout() (r float64, exists bool) {
	v := m.addpayout
	if v == nil {
		return
	}
	return *v, true
}

// ClearPayout clears the value of the "payout" field.
func (m *WinBetslipMutation) ClearPayout() {
	m.payout = nil
	m.addpayout = nil
	m.clearedFields[winbetslip.FieldPayout] = struct{}{}
}

// PayoutCleared returns if the "payout" field was cleared in this mutation.
func (m *WinBetslipMutation) PayoutCleared() bool {
	_, ok := m.clearedFields[winbetslip.FieldPayout]
	return ok
}

// ResetPayout resets all changes to the "payout" field.
func (m *WinBetslipMutation) ResetPayout() {
	m.payout = nil
	m.addpayout = nil
	delete(m.clearedFields, winbetslip.FieldPayout)
}

// SetCoinRefund sets the "coin_refund" field.
func (m *WinBetslipMutation) SetCoinRefund(f float64) {
	m.coin_refund = &f
	m.addcoin_refund = nil
}

// CoinRefund returns the value of the "coin_refund" field in the mutation.
func (m *WinBetslipMutation) CoinRefund() (r float64, exists bool) {
	v := m.coin_refund
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinRefund returns the old "coin_refund" field's value of the WinBetslip entity.
// If the WinBetslip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipMutation) OldCoinRefund(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinRefund is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinRefund requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinRefund: %w", err)
	}
	return oldValue.CoinRefund, nil
}

// AddCoinRefund adds f to the "coin_refund" field.
func (m *WinBetslipMutation) AddCoinRefund(f float64) {
	if m.addcoin_refund != nil {
		*m.addcoin_refund += f
	} else {
		m.addcoin_refund = &f
	}
}

// AddedCoinRefund returns the value that was added to the "coin_refund" field in this mutation.
func (m *WinBetslipMutation) AddedCoinRefund() (r float64, exists bool) {
	v := m.addcoin_refund
	if v == nil {
		return
	}
	return *v, true
}

// ResetCoinRefund resets all changes to the "coin_refund" field.
func (m *WinBetslipMutation) ResetCoinRefund() {
	m.coin_refund = nil
	m.addcoin_refund = nil
}

// SetCoinBefore sets the "coin_before" field.
func (m *WinBetslipMutation) SetCoinBefore(f float64) {
	m.coin_before = &f
	m.addcoin_before = nil
}

// CoinBefore returns the value of the "coin_before" field in the mutation.
func (m *WinBetslipMutation) CoinBefore() (r float64, exists bool) {
	v := m.coin_before
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinBefore returns the old "coin_before" field's value of the WinBetslip entity.
// If the WinBetslip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipMutation) OldCoinBefore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinBefore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinBefore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinBefore: %w", err)
	}
	return oldValue.CoinBefore, nil
}

// AddCoinBefore adds f to the "coin_before" field.
func (m *WinBetslipMutation) AddCoinBefore(f float64) {
	if m.addcoin_before != nil {
		*m.addcoin_before += f
	} else {
		m.addcoin_before = &f
	}
}

// AddedCoinBefore returns the value that was added to the "coin_before" field in this mutation.
func (m *WinBetslipMutation) AddedCoinBefore() (r float64, exists bool) {
	v := m.addcoin_before
	if v == nil {
		return
	}
	return *v, true
}

// ResetCoinBefore resets all changes to the "coin_before" field.
func (m *WinBetslipMutation) ResetCoinBefore() {
	m.coin_before = nil
	m.addcoin_before = nil
}

// SetGameID sets the "game_id" field.
func (m *WinBetslipMutation) SetGameID(s string) {
	m.game_id = &s
}

// GameID returns the value of the "game_id" field in the mutation.
func (m *WinBetslipMutation) GameID() (r string, exists bool) {
	v := m.game_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGameID returns the old "game_id" field's value of the WinBetslip entity.
// If the WinBetslip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipMutation) OldGameID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGameID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGameID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGameID: %w", err)
	}
	return oldValue.GameID, nil
}

// ResetGameID resets all changes to the "game_id" field.
func (m *WinBetslipMutation) ResetGameID() {
	m.game_id = nil
}

// SetGameName sets the "game_name" field.
func (m *WinBetslipMutation) SetGameName(s string) {
	m.game_name = &s
}

// GameName returns the value of the "game_name" field in the mutation.
func (m *WinBetslipMutation) GameName() (r string, exists bool) {
	v := m.game_name
	if v == nil {
		return
	}
	return *v, true
}

// OldGameName returns the old "game_name" field's value of the WinBetslip entity.
// If the WinBetslip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipMutation) OldGameName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGameName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGameName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGameName: %w", err)
	}
	return oldValue.GameName, nil
}

// ClearGameName clears the value of the "game_name" field.
func (m *WinBetslipMutation) ClearGameName() {
	m.game_name = nil
	m.clearedFields[winbetslip.FieldGameName] = struct{}{}
}

// GameNameCleared returns if the "game_name" field was cleared in this mutation.
func (m *WinBetslipMutation) GameNameCleared() bool {
	_, ok := m.clearedFields[winbetslip.FieldGameName]
	return ok
}

// ResetGameName resets all changes to the "game_name" field.
func (m *WinBetslipMutation) ResetGameName() {
	m.game_name = nil
	delete(m.clearedFields, winbetslip.FieldGameName)
}

// SetAmountType sets the "amount_type" field.
func (m *WinBetslipMutation) SetAmountType(i int32) {
	m.amount_type = &i
	m.addamount_type = nil
}

// AmountType returns the value of the "amount_type" field in the mutation.
func (m *WinBetslipMutation) AmountType() (r int32, exists bool) {
	v := m.amount_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountType returns the old "amount_type" field's value of the WinBetslip entity.
// If the WinBetslip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipMutation) OldAmountType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmountType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmountType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountType: %w", err)
	}
	return oldValue.AmountType, nil
}

// AddAmountType adds i to the "amount_type" field.
func (m *WinBetslipMutation) AddAmountType(i int32) {
	if m.addamount_type != nil {
		*m.addamount_type += i
	} else {
		m.addamount_type = &i
	}
}

// AddedAmountType returns the value that was added to the "amount_type" field in this mutation.
func (m *WinBetslipMutation) AddedAmountType() (r int32, exists bool) {
	v := m.addamount_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmountType resets all changes to the "amount_type" field.
func (m *WinBetslipMutation) ResetAmountType() {
	m.amount_type = nil
	m.addamount_type = nil
}

// SetGameTypeID sets the "game_type_id" field.
func (m *WinBetslipMutation) SetGameTypeID(s string) {
	m.game_type_id = &s
}

// GameTypeID returns the value of the "game_type_id" field in the mutation.
func (m *WinBetslipMutation) GameTypeID() (r string, exists bool) {
	v := m.game_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGameTypeID returns the old "game_type_id" field's value of the WinBetslip entity.
// If the WinBetslip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipMutation) OldGameTypeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGameTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGameTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGameTypeID: %w", err)
	}
	return oldValue.GameTypeID, nil
}

// ResetGameTypeID resets all changes to the "game_type_id" field.
func (m *WinBetslipMutation) ResetGameTypeID() {
	m.game_type_id = nil
}

// SetGameGroupID sets the "game_group_id" field.
func (m *WinBetslipMutation) SetGameGroupID(i int32) {
	m.game_group_id = &i
	m.addgame_group_id = nil
}

// GameGroupID returns the value of the "game_group_id" field in the mutation.
func (m *WinBetslipMutation) GameGroupID() (r int32, exists bool) {
	v := m.game_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGameGroupID returns the old "game_group_id" field's value of the WinBetslip entity.
// If the WinBetslip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipMutation) OldGameGroupID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGameGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGameGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGameGroupID: %w", err)
	}
	return oldValue.GameGroupID, nil
}

// AddGameGroupID adds i to the "game_group_id" field.
func (m *WinBetslipMutation) AddGameGroupID(i int32) {
	if m.addgame_group_id != nil {
		*m.addgame_group_id += i
	} else {
		m.addgame_group_id = &i
	}
}

// AddedGameGroupID returns the value that was added to the "game_group_id" field in this mutation.
func (m *WinBetslipMutation) AddedGameGroupID() (r int32, exists bool) {
	v := m.addgame_group_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearGameGroupID clears the value of the "game_group_id" field.
func (m *WinBetslipMutation) ClearGameGroupID() {
	m.game_group_id = nil
	m.addgame_group_id = nil
	m.clearedFields[winbetslip.FieldGameGroupID] = struct{}{}
}

// GameGroupIDCleared returns if the "game_group_id" field was cleared in this mutation.
func (m *WinBetslipMutation) GameGroupIDCleared() bool {
	_, ok := m.clearedFields[winbetslip.FieldGameGroupID]
	return ok
}

// ResetGameGroupID resets all changes to the "game_group_id" field.
func (m *WinBetslipMutation) ResetGameGroupID() {
	m.game_group_id = nil
	m.addgame_group_id = nil
	delete(m.clearedFields, winbetslip.FieldGameGroupID)
}

// SetSportType sets the "sport_type" field.
func (m *WinBetslipMutation) SetSportType(s string) {
	m.sport_type = &s
}

// SportType returns the value of the "sport_type" field in the mutation.
func (m *WinBetslipMutation) SportType() (r string, exists bool) {
	v := m.sport_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSportType returns the old "sport_type" field's value of the WinBetslip entity.
// If the WinBetslip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipMutation) OldSportType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSportType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSportType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSportType: %w", err)
	}
	return oldValue.SportType, nil
}

// ClearSportType clears the value of the "sport_type" field.
func (m *WinBetslipMutation) ClearSportType() {
	m.sport_type = nil
	m.clearedFields[winbetslip.FieldSportType] = struct{}{}
}

// SportTypeCleared returns if the "sport_type" field was cleared in this mutation.
func (m *WinBetslipMutation) SportTypeCleared() bool {
	_, ok := m.clearedFields[winbetslip.FieldSportType]
	return ok
}

// ResetSportType resets all changes to the "sport_type" field.
func (m *WinBetslipMutation) ResetSportType() {
	m.sport_type = nil
	delete(m.clearedFields, winbetslip.FieldSportType)
}

// SetDtStarted sets the "dt_started" field.
func (m *WinBetslipMutation) SetDtStarted(i int) {
	m.dt_started = &i
	m.adddt_started = nil
}

// DtStarted returns the value of the "dt_started" field in the mutation.
func (m *WinBetslipMutation) DtStarted() (r int, exists bool) {
	v := m.dt_started
	if v == nil {
		return
	}
	return *v, true
}

// OldDtStarted returns the old "dt_started" field's value of the WinBetslip entity.
// If the WinBetslip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipMutation) OldDtStarted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDtStarted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDtStarted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDtStarted: %w", err)
	}
	return oldValue.DtStarted, nil
}

// AddDtStarted adds i to the "dt_started" field.
func (m *WinBetslipMutation) AddDtStarted(i int) {
	if m.adddt_started != nil {
		*m.adddt_started += i
	} else {
		m.adddt_started = &i
	}
}

// AddedDtStarted returns the value that was added to the "dt_started" field in this mutation.
func (m *WinBetslipMutation) AddedDtStarted() (r int, exists bool) {
	v := m.adddt_started
	if v == nil {
		return
	}
	return *v, true
}

// ResetDtStarted resets all changes to the "dt_started" field.
func (m *WinBetslipMutation) ResetDtStarted() {
	m.dt_started = nil
	m.adddt_started = nil
}

// SetDtCompleted sets the "dt_completed" field.
func (m *WinBetslipMutation) SetDtCompleted(i int) {
	m.dt_completed = &i
	m.adddt_completed = nil
}

// DtCompleted returns the value of the "dt_completed" field in the mutation.
func (m *WinBetslipMutation) DtCompleted() (r int, exists bool) {
	v := m.dt_completed
	if v == nil {
		return
	}
	return *v, true
}

// OldDtCompleted returns the old "dt_completed" field's value of the WinBetslip entity.
// If the WinBetslip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipMutation) OldDtCompleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDtCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDtCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDtCompleted: %w", err)
	}
	return oldValue.DtCompleted, nil
}

// AddDtCompleted adds i to the "dt_completed" field.
func (m *WinBetslipMutation) AddDtCompleted(i int) {
	if m.adddt_completed != nil {
		*m.adddt_completed += i
	} else {
		m.adddt_completed = &i
	}
}

// AddedDtCompleted returns the value that was added to the "dt_completed" field in this mutation.
func (m *WinBetslipMutation) AddedDtCompleted() (r int, exists bool) {
	v := m.adddt_completed
	if v == nil {
		return
	}
	return *v, true
}

// ClearDtCompleted clears the value of the "dt_completed" field.
func (m *WinBetslipMutation) ClearDtCompleted() {
	m.dt_completed = nil
	m.adddt_completed = nil
	m.clearedFields[winbetslip.FieldDtCompleted] = struct{}{}
}

// DtCompletedCleared returns if the "dt_completed" field was cleared in this mutation.
func (m *WinBetslipMutation) DtCompletedCleared() bool {
	_, ok := m.clearedFields[winbetslip.FieldDtCompleted]
	return ok
}

// ResetDtCompleted resets all changes to the "dt_completed" field.
func (m *WinBetslipMutation) ResetDtCompleted() {
	m.dt_completed = nil
	m.adddt_completed = nil
	delete(m.clearedFields, winbetslip.FieldDtCompleted)
}

// SetWinTransactionID sets the "win_transaction_id" field.
func (m *WinBetslipMutation) SetWinTransactionID(s string) {
	m.win_transaction_id = &s
}

// WinTransactionID returns the value of the "win_transaction_id" field in the mutation.
func (m *WinBetslipMutation) WinTransactionID() (r string, exists bool) {
	v := m.win_transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWinTransactionID returns the old "win_transaction_id" field's value of the WinBetslip entity.
// If the WinBetslip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipMutation) OldWinTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWinTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWinTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWinTransactionID: %w", err)
	}
	return oldValue.WinTransactionID, nil
}

// ClearWinTransactionID clears the value of the "win_transaction_id" field.
func (m *WinBetslipMutation) ClearWinTransactionID() {
	m.win_transaction_id = nil
	m.clearedFields[winbetslip.FieldWinTransactionID] = struct{}{}
}

// WinTransactionIDCleared returns if the "win_transaction_id" field was cleared in this mutation.
func (m *WinBetslipMutation) WinTransactionIDCleared() bool {
	_, ok := m.clearedFields[winbetslip.FieldWinTransactionID]
	return ok
}

// ResetWinTransactionID resets all changes to the "win_transaction_id" field.
func (m *WinBetslipMutation) ResetWinTransactionID() {
	m.win_transaction_id = nil
	delete(m.clearedFields, winbetslip.FieldWinTransactionID)
}

// SetBetJSON sets the "bet_json" field.
func (m *WinBetslipMutation) SetBetJSON(s string) {
	m.bet_json = &s
}

// BetJSON returns the value of the "bet_json" field in the mutation.
func (m *WinBetslipMutation) BetJSON() (r string, exists bool) {
	v := m.bet_json
	if v == nil {
		return
	}
	return *v, true
}

// OldBetJSON returns the old "bet_json" field's value of the WinBetslip entity.
// If the WinBetslip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipMutation) OldBetJSON(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBetJSON is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBetJSON requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBetJSON: %w", err)
	}
	return oldValue.BetJSON, nil
}

// ClearBetJSON clears the value of the "bet_json" field.
func (m *WinBetslipMutation) ClearBetJSON() {
	m.bet_json = nil
	m.clearedFields[winbetslip.FieldBetJSON] = struct{}{}
}

// BetJSONCleared returns if the "bet_json" field was cleared in this mutation.
func (m *WinBetslipMutation) BetJSONCleared() bool {
	_, ok := m.clearedFields[winbetslip.FieldBetJSON]
	return ok
}

// ResetBetJSON resets all changes to the "bet_json" field.
func (m *WinBetslipMutation) ResetBetJSON() {
	m.bet_json = nil
	delete(m.clearedFields, winbetslip.FieldBetJSON)
}

// SetRewardJSON sets the "reward_json" field.
func (m *WinBetslipMutation) SetRewardJSON(s string) {
	m.reward_json = &s
}

// RewardJSON returns the value of the "reward_json" field in the mutation.
func (m *WinBetslipMutation) RewardJSON() (r string, exists bool) {
	v := m.reward_json
	if v == nil {
		return
	}
	return *v, true
}

// OldRewardJSON returns the old "reward_json" field's value of the WinBetslip entity.
// If the WinBetslip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipMutation) OldRewardJSON(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRewardJSON is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRewardJSON requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRewardJSON: %w", err)
	}
	return oldValue.RewardJSON, nil
}

// ClearRewardJSON clears the value of the "reward_json" field.
func (m *WinBetslipMutation) ClearRewardJSON() {
	m.reward_json = nil
	m.clearedFields[winbetslip.FieldRewardJSON] = struct{}{}
}

// RewardJSONCleared returns if the "reward_json" field was cleared in this mutation.
func (m *WinBetslipMutation) RewardJSONCleared() bool {
	_, ok := m.clearedFields[winbetslip.FieldRewardJSON]
	return ok
}

// ResetRewardJSON resets all changes to the "reward_json" field.
func (m *WinBetslipMutation) ResetRewardJSON() {
	m.reward_json = nil
	delete(m.clearedFields, winbetslip.FieldRewardJSON)
}

// SetRefundJSON sets the "refund_json" field.
func (m *WinBetslipMutation) SetRefundJSON(s string) {
	m.refund_json = &s
}

// RefundJSON returns the value of the "refund_json" field in the mutation.
func (m *WinBetslipMutation) RefundJSON() (r string, exists bool) {
	v := m.refund_json
	if v == nil {
		return
	}
	return *v, true
}

// OldRefundJSON returns the old "refund_json" field's value of the WinBetslip entity.
// If the WinBetslip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipMutation) OldRefundJSON(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefundJSON is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefundJSON requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefundJSON: %w", err)
	}
	return oldValue.RefundJSON, nil
}

// ClearRefundJSON clears the value of the "refund_json" field.
func (m *WinBetslipMutation) ClearRefundJSON() {
	m.refund_json = nil
	m.clearedFields[winbetslip.FieldRefundJSON] = struct{}{}
}

// RefundJSONCleared returns if the "refund_json" field was cleared in this mutation.
func (m *WinBetslipMutation) RefundJSONCleared() bool {
	_, ok := m.clearedFields[winbetslip.FieldRefundJSON]
	return ok
}

// ResetRefundJSON resets all changes to the "refund_json" field.
func (m *WinBetslipMutation) ResetRefundJSON() {
	m.refund_json = nil
	delete(m.clearedFields, winbetslip.FieldRefundJSON)
}

// SetCreateTimeStr sets the "create_time_str" field.
func (m *WinBetslipMutation) SetCreateTimeStr(s string) {
	m.create_time_str = &s
}

// CreateTimeStr returns the value of the "create_time_str" field in the mutation.
func (m *WinBetslipMutation) CreateTimeStr() (r string, exists bool) {
	v := m.create_time_str
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTimeStr returns the old "create_time_str" field's value of the WinBetslip entity.
// If the WinBetslip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipMutation) OldCreateTimeStr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTimeStr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTimeStr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTimeStr: %w", err)
	}
	return oldValue.CreateTimeStr, nil
}

// ResetCreateTimeStr resets all changes to the "create_time_str" field.
func (m *WinBetslipMutation) ResetCreateTimeStr() {
	m.create_time_str = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WinBetslipMutation) SetCreatedAt(i int32) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WinBetslipMutation) CreatedAt() (r int32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WinBetslip entity.
// If the WinBetslip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipMutation) OldCreatedAt(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *WinBetslipMutation) AddCreatedAt(i int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *WinBetslipMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WinBetslipMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WinBetslipMutation) SetUpdatedAt(i int32) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WinBetslipMutation) UpdatedAt() (r int32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WinBetslip entity.
// If the WinBetslip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipMutation) OldUpdatedAt(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *WinBetslipMutation) AddUpdatedAt(i int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *WinBetslipMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WinBetslipMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// Where appends a list predicates to the WinBetslipMutation builder.
func (m *WinBetslipMutation) Where(ps ...predicate.WinBetslip) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WinBetslipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WinBetslipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WinBetslip, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WinBetslipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WinBetslipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WinBetslip).
func (m *WinBetslipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WinBetslipMutation) Fields() []string {
	fields := make([]string, 0, 27)
	if m.round_id != nil {
		fields = append(fields, winbetslip.FieldRoundID)
	}
	if m.transaction_id != nil {
		fields = append(fields, winbetslip.FieldTransactionID)
	}
	if m.game_plat_id != nil {
		fields = append(fields, winbetslip.FieldGamePlatID)
	}
	if m.xb_status != nil {
		fields = append(fields, winbetslip.FieldXbStatus)
	}
	if m.xb_uid != nil {
		fields = append(fields, winbetslip.FieldXbUID)
	}
	if m.xb_username != nil {
		fields = append(fields, winbetslip.FieldXbUsername)
	}
	if m.xb_profit != nil {
		fields = append(fields, winbetslip.FieldXbProfit)
	}
	if m.stake != nil {
		fields = append(fields, winbetslip.FieldStake)
	}
	if m.valid_stake != nil {
		fields = append(fields, winbetslip.FieldValidStake)
	}
	if m.payout != nil {
		fields = append(fields, winbetslip.FieldPayout)
	}
	if m.coin_refund != nil {
		fields = append(fields, winbetslip.FieldCoinRefund)
	}
	if m.coin_before != nil {
		fields = append(fields, winbetslip.FieldCoinBefore)
	}
	if m.game_id != nil {
		fields = append(fields, winbetslip.FieldGameID)
	}
	if m.game_name != nil {
		fields = append(fields, winbetslip.FieldGameName)
	}
	if m.amount_type != nil {
		fields = append(fields, winbetslip.FieldAmountType)
	}
	if m.game_type_id != nil {
		fields = append(fields, winbetslip.FieldGameTypeID)
	}
	if m.game_group_id != nil {
		fields = append(fields, winbetslip.FieldGameGroupID)
	}
	if m.sport_type != nil {
		fields = append(fields, winbetslip.FieldSportType)
	}
	if m.dt_started != nil {
		fields = append(fields, winbetslip.FieldDtStarted)
	}
	if m.dt_completed != nil {
		fields = append(fields, winbetslip.FieldDtCompleted)
	}
	if m.win_transaction_id != nil {
		fields = append(fields, winbetslip.FieldWinTransactionID)
	}
	if m.bet_json != nil {
		fields = append(fields, winbetslip.FieldBetJSON)
	}
	if m.reward_json != nil {
		fields = append(fields, winbetslip.FieldRewardJSON)
	}
	if m.refund_json != nil {
		fields = append(fields, winbetslip.FieldRefundJSON)
	}
	if m.create_time_str != nil {
		fields = append(fields, winbetslip.FieldCreateTimeStr)
	}
	if m.created_at != nil {
		fields = append(fields, winbetslip.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, winbetslip.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WinBetslipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case winbetslip.FieldRoundID:
		return m.RoundID()
	case winbetslip.FieldTransactionID:
		return m.TransactionID()
	case winbetslip.FieldGamePlatID:
		return m.GamePlatID()
	case winbetslip.FieldXbStatus:
		return m.XbStatus()
	case winbetslip.FieldXbUID:
		return m.XbUID()
	case winbetslip.FieldXbUsername:
		return m.XbUsername()
	case winbetslip.FieldXbProfit:
		return m.XbProfit()
	case winbetslip.FieldStake:
		return m.Stake()
	case winbetslip.FieldValidStake:
		return m.ValidStake()
	case winbetslip.FieldPayout:
		return m.Payout()
	case winbetslip.FieldCoinRefund:
		return m.CoinRefund()
	case winbetslip.FieldCoinBefore:
		return m.CoinBefore()
	case winbetslip.FieldGameID:
		return m.GameID()
	case winbetslip.FieldGameName:
		return m.GameName()
	case winbetslip.FieldAmountType:
		return m.AmountType()
	case winbetslip.FieldGameTypeID:
		return m.GameTypeID()
	case winbetslip.FieldGameGroupID:
		return m.GameGroupID()
	case winbetslip.FieldSportType:
		return m.SportType()
	case winbetslip.FieldDtStarted:
		return m.DtStarted()
	case winbetslip.FieldDtCompleted:
		return m.DtCompleted()
	case winbetslip.FieldWinTransactionID:
		return m.WinTransactionID()
	case winbetslip.FieldBetJSON:
		return m.BetJSON()
	case winbetslip.FieldRewardJSON:
		return m.RewardJSON()
	case winbetslip.FieldRefundJSON:
		return m.RefundJSON()
	case winbetslip.FieldCreateTimeStr:
		return m.CreateTimeStr()
	case winbetslip.FieldCreatedAt:
		return m.CreatedAt()
	case winbetslip.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WinBetslipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case winbetslip.FieldRoundID:
		return m.OldRoundID(ctx)
	case winbetslip.FieldTransactionID:
		return m.OldTransactionID(ctx)
	case winbetslip.FieldGamePlatID:
		return m.OldGamePlatID(ctx)
	case winbetslip.FieldXbStatus:
		return m.OldXbStatus(ctx)
	case winbetslip.FieldXbUID:
		return m.OldXbUID(ctx)
	case winbetslip.FieldXbUsername:
		return m.OldXbUsername(ctx)
	case winbetslip.FieldXbProfit:
		return m.OldXbProfit(ctx)
	case winbetslip.FieldStake:
		return m.OldStake(ctx)
	case winbetslip.FieldValidStake:
		return m.OldValidStake(ctx)
	case winbetslip.FieldPayout:
		return m.OldPayout(ctx)
	case winbetslip.FieldCoinRefund:
		return m.OldCoinRefund(ctx)
	case winbetslip.FieldCoinBefore:
		return m.OldCoinBefore(ctx)
	case winbetslip.FieldGameID:
		return m.OldGameID(ctx)
	case winbetslip.FieldGameName:
		return m.OldGameName(ctx)
	case winbetslip.FieldAmountType:
		return m.OldAmountType(ctx)
	case winbetslip.FieldGameTypeID:
		return m.OldGameTypeID(ctx)
	case winbetslip.FieldGameGroupID:
		return m.OldGameGroupID(ctx)
	case winbetslip.FieldSportType:
		return m.OldSportType(ctx)
	case winbetslip.FieldDtStarted:
		return m.OldDtStarted(ctx)
	case winbetslip.FieldDtCompleted:
		return m.OldDtCompleted(ctx)
	case winbetslip.FieldWinTransactionID:
		return m.OldWinTransactionID(ctx)
	case winbetslip.FieldBetJSON:
		return m.OldBetJSON(ctx)
	case winbetslip.FieldRewardJSON:
		return m.OldRewardJSON(ctx)
	case winbetslip.FieldRefundJSON:
		return m.OldRefundJSON(ctx)
	case winbetslip.FieldCreateTimeStr:
		return m.OldCreateTimeStr(ctx)
	case winbetslip.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case winbetslip.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WinBetslip field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WinBetslipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case winbetslip.FieldRoundID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoundID(v)
		return nil
	case winbetslip.FieldTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionID(v)
		return nil
	case winbetslip.FieldGamePlatID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGamePlatID(v)
		return nil
	case winbetslip.FieldXbStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetXbStatus(v)
		return nil
	case winbetslip.FieldXbUID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetXbUID(v)
		return nil
	case winbetslip.FieldXbUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetXbUsername(v)
		return nil
	case winbetslip.FieldXbProfit:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetXbProfit(v)
		return nil
	case winbetslip.FieldStake:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStake(v)
		return nil
	case winbetslip.FieldValidStake:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidStake(v)
		return nil
	case winbetslip.FieldPayout:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayout(v)
		return nil
	case winbetslip.FieldCoinRefund:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinRefund(v)
		return nil
	case winbetslip.FieldCoinBefore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinBefore(v)
		return nil
	case winbetslip.FieldGameID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGameID(v)
		return nil
	case winbetslip.FieldGameName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGameName(v)
		return nil
	case winbetslip.FieldAmountType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountType(v)
		return nil
	case winbetslip.FieldGameTypeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGameTypeID(v)
		return nil
	case winbetslip.FieldGameGroupID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGameGroupID(v)
		return nil
	case winbetslip.FieldSportType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSportType(v)
		return nil
	case winbetslip.FieldDtStarted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDtStarted(v)
		return nil
	case winbetslip.FieldDtCompleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDtCompleted(v)
		return nil
	case winbetslip.FieldWinTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWinTransactionID(v)
		return nil
	case winbetslip.FieldBetJSON:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBetJSON(v)
		return nil
	case winbetslip.FieldRewardJSON:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRewardJSON(v)
		return nil
	case winbetslip.FieldRefundJSON:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefundJSON(v)
		return nil
	case winbetslip.FieldCreateTimeStr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTimeStr(v)
		return nil
	case winbetslip.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case winbetslip.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WinBetslip field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WinBetslipMutation) AddedFields() []string {
	var fields []string
	if m.addgame_plat_id != nil {
		fields = append(fields, winbetslip.FieldGamePlatID)
	}
	if m.addxb_status != nil {
		fields = append(fields, winbetslip.FieldXbStatus)
	}
	if m.addxb_uid != nil {
		fields = append(fields, winbetslip.FieldXbUID)
	}
	if m.addxb_profit != nil {
		fields = append(fields, winbetslip.FieldXbProfit)
	}
	if m.addstake != nil {
		fields = append(fields, winbetslip.FieldStake)
	}
	if m.addvalid_stake != nil {
		fields = append(fields, winbetslip.FieldValidStake)
	}
	if m.addpayout != nil {
		fields = append(fields, winbetslip.FieldPayout)
	}
	if m.addcoin_refund != nil {
		fields = append(fields, winbetslip.FieldCoinRefund)
	}
	if m.addcoin_before != nil {
		fields = append(fields, winbetslip.FieldCoinBefore)
	}
	if m.addamount_type != nil {
		fields = append(fields, winbetslip.FieldAmountType)
	}
	if m.addgame_group_id != nil {
		fields = append(fields, winbetslip.FieldGameGroupID)
	}
	if m.adddt_started != nil {
		fields = append(fields, winbetslip.FieldDtStarted)
	}
	if m.adddt_completed != nil {
		fields = append(fields, winbetslip.FieldDtCompleted)
	}
	if m.addcreated_at != nil {
		fields = append(fields, winbetslip.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, winbetslip.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WinBetslipMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case winbetslip.FieldGamePlatID:
		return m.AddedGamePlatID()
	case winbetslip.FieldXbStatus:
		return m.AddedXbStatus()
	case winbetslip.FieldXbUID:
		return m.AddedXbUID()
	case winbetslip.FieldXbProfit:
		return m.AddedXbProfit()
	case winbetslip.FieldStake:
		return m.AddedStake()
	case winbetslip.FieldValidStake:
		return m.AddedValidStake()
	case winbetslip.FieldPayout:
		return m.AddedPayout()
	case winbetslip.FieldCoinRefund:
		return m.AddedCoinRefund()
	case winbetslip.FieldCoinBefore:
		return m.AddedCoinBefore()
	case winbetslip.FieldAmountType:
		return m.AddedAmountType()
	case winbetslip.FieldGameGroupID:
		return m.AddedGameGroupID()
	case winbetslip.FieldDtStarted:
		return m.AddedDtStarted()
	case winbetslip.FieldDtCompleted:
		return m.AddedDtCompleted()
	case winbetslip.FieldCreatedAt:
		return m.AddedCreatedAt()
	case winbetslip.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WinBetslipMutation) AddField(name string, value ent.Value) error {
	switch name {
	case winbetslip.FieldGamePlatID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGamePlatID(v)
		return nil
	case winbetslip.FieldXbStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddXbStatus(v)
		return nil
	case winbetslip.FieldXbUID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddXbUID(v)
		return nil
	case winbetslip.FieldXbProfit:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddXbProfit(v)
		return nil
	case winbetslip.FieldStake:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStake(v)
		return nil
	case winbetslip.FieldValidStake:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValidStake(v)
		return nil
	case winbetslip.FieldPayout:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayout(v)
		return nil
	case winbetslip.FieldCoinRefund:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoinRefund(v)
		return nil
	case winbetslip.FieldCoinBefore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoinBefore(v)
		return nil
	case winbetslip.FieldAmountType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmountType(v)
		return nil
	case winbetslip.FieldGameGroupID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGameGroupID(v)
		return nil
	case winbetslip.FieldDtStarted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDtStarted(v)
		return nil
	case winbetslip.FieldDtCompleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDtCompleted(v)
		return nil
	case winbetslip.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case winbetslip.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WinBetslip numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WinBetslipMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(winbetslip.FieldXbProfit) {
		fields = append(fields, winbetslip.FieldXbProfit)
	}
	if m.FieldCleared(winbetslip.FieldPayout) {
		fields = append(fields, winbetslip.FieldPayout)
	}
	if m.FieldCleared(winbetslip.FieldGameName) {
		fields = append(fields, winbetslip.FieldGameName)
	}
	if m.FieldCleared(winbetslip.FieldGameGroupID) {
		fields = append(fields, winbetslip.FieldGameGroupID)
	}
	if m.FieldCleared(winbetslip.FieldSportType) {
		fields = append(fields, winbetslip.FieldSportType)
	}
	if m.FieldCleared(winbetslip.FieldDtCompleted) {
		fields = append(fields, winbetslip.FieldDtCompleted)
	}
	if m.FieldCleared(winbetslip.FieldWinTransactionID) {
		fields = append(fields, winbetslip.FieldWinTransactionID)
	}
	if m.FieldCleared(winbetslip.FieldBetJSON) {
		fields = append(fields, winbetslip.FieldBetJSON)
	}
	if m.FieldCleared(winbetslip.FieldRewardJSON) {
		fields = append(fields, winbetslip.FieldRewardJSON)
	}
	if m.FieldCleared(winbetslip.FieldRefundJSON) {
		fields = append(fields, winbetslip.FieldRefundJSON)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WinBetslipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WinBetslipMutation) ClearField(name string) error {
	switch name {
	case winbetslip.FieldXbProfit:
		m.ClearXbProfit()
		return nil
	case winbetslip.FieldPayout:
		m.ClearPayout()
		return nil
	case winbetslip.FieldGameName:
		m.ClearGameName()
		return nil
	case winbetslip.FieldGameGroupID:
		m.ClearGameGroupID()
		return nil
	case winbetslip.FieldSportType:
		m.ClearSportType()
		return nil
	case winbetslip.FieldDtCompleted:
		m.ClearDtCompleted()
		return nil
	case winbetslip.FieldWinTransactionID:
		m.ClearWinTransactionID()
		return nil
	case winbetslip.FieldBetJSON:
		m.ClearBetJSON()
		return nil
	case winbetslip.FieldRewardJSON:
		m.ClearRewardJSON()
		return nil
	case winbetslip.FieldRefundJSON:
		m.ClearRefundJSON()
		return nil
	}
	return fmt.Errorf("unknown WinBetslip nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WinBetslipMutation) ResetField(name string) error {
	switch name {
	case winbetslip.FieldRoundID:
		m.ResetRoundID()
		return nil
	case winbetslip.FieldTransactionID:
		m.ResetTransactionID()
		return nil
	case winbetslip.FieldGamePlatID:
		m.ResetGamePlatID()
		return nil
	case winbetslip.FieldXbStatus:
		m.ResetXbStatus()
		return nil
	case winbetslip.FieldXbUID:
		m.ResetXbUID()
		return nil
	case winbetslip.FieldXbUsername:
		m.ResetXbUsername()
		return nil
	case winbetslip.FieldXbProfit:
		m.ResetXbProfit()
		return nil
	case winbetslip.FieldStake:
		m.ResetStake()
		return nil
	case winbetslip.FieldValidStake:
		m.ResetValidStake()
		return nil
	case winbetslip.FieldPayout:
		m.ResetPayout()
		return nil
	case winbetslip.FieldCoinRefund:
		m.ResetCoinRefund()
		return nil
	case winbetslip.FieldCoinBefore:
		m.ResetCoinBefore()
		return nil
	case winbetslip.FieldGameID:
		m.ResetGameID()
		return nil
	case winbetslip.FieldGameName:
		m.ResetGameName()
		return nil
	case winbetslip.FieldAmountType:
		m.ResetAmountType()
		return nil
	case winbetslip.FieldGameTypeID:
		m.ResetGameTypeID()
		return nil
	case winbetslip.FieldGameGroupID:
		m.ResetGameGroupID()
		return nil
	case winbetslip.FieldSportType:
		m.ResetSportType()
		return nil
	case winbetslip.FieldDtStarted:
		m.ResetDtStarted()
		return nil
	case winbetslip.FieldDtCompleted:
		m.ResetDtCompleted()
		return nil
	case winbetslip.FieldWinTransactionID:
		m.ResetWinTransactionID()
		return nil
	case winbetslip.FieldBetJSON:
		m.ResetBetJSON()
		return nil
	case winbetslip.FieldRewardJSON:
		m.ResetRewardJSON()
		return nil
	case winbetslip.FieldRefundJSON:
		m.ResetRefundJSON()
		return nil
	case winbetslip.FieldCreateTimeStr:
		m.ResetCreateTimeStr()
		return nil
	case winbetslip.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case winbetslip.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown WinBetslip field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WinBetslipMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WinBetslipMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WinBetslipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WinBetslipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WinBetslipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WinBetslipMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WinBetslipMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WinBetslip unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WinBetslipMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WinBetslip edge %s", name)
}

// WinBetslipsDetailMutation represents an operation that mutates the WinBetslipsDetail nodes in the graph.
type WinBetslipsDetailMutation struct {
	config
	op            Op
	typ           string
	id            *int
	xb_uid        *uint32
	addxb_uid     *int32
	xb_username   *string
	bet_json      *string
	reward_json   *string
	refund_json   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WinBetslipsDetail, error)
	predicates    []predicate.WinBetslipsDetail
}

var _ ent.Mutation = (*WinBetslipsDetailMutation)(nil)

// winbetslipsdetailOption allows management of the mutation configuration using functional options.
type winbetslipsdetailOption func(*WinBetslipsDetailMutation)

// newWinBetslipsDetailMutation creates new mutation for the WinBetslipsDetail entity.
func newWinBetslipsDetailMutation(c config, op Op, opts ...winbetslipsdetailOption) *WinBetslipsDetailMutation {
	m := &WinBetslipsDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeWinBetslipsDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWinBetslipsDetailID sets the ID field of the mutation.
func withWinBetslipsDetailID(id int) winbetslipsdetailOption {
	return func(m *WinBetslipsDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *WinBetslipsDetail
		)
		m.oldValue = func(ctx context.Context) (*WinBetslipsDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WinBetslipsDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWinBetslipsDetail sets the old WinBetslipsDetail of the mutation.
func withWinBetslipsDetail(node *WinBetslipsDetail) winbetslipsdetailOption {
	return func(m *WinBetslipsDetailMutation) {
		m.oldValue = func(context.Context) (*WinBetslipsDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WinBetslipsDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WinBetslipsDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WinBetslipsDetail entities.
func (m *WinBetslipsDetailMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WinBetslipsDetailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WinBetslipsDetailMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WinBetslipsDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetXbUID sets the "xb_uid" field.
func (m *WinBetslipsDetailMutation) SetXbUID(u uint32) {
	m.xb_uid = &u
	m.addxb_uid = nil
}

// XbUID returns the value of the "xb_uid" field in the mutation.
func (m *WinBetslipsDetailMutation) XbUID() (r uint32, exists bool) {
	v := m.xb_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldXbUID returns the old "xb_uid" field's value of the WinBetslipsDetail entity.
// If the WinBetslipsDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipsDetailMutation) OldXbUID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldXbUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldXbUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldXbUID: %w", err)
	}
	return oldValue.XbUID, nil
}

// AddXbUID adds u to the "xb_uid" field.
func (m *WinBetslipsDetailMutation) AddXbUID(u int32) {
	if m.addxb_uid != nil {
		*m.addxb_uid += u
	} else {
		m.addxb_uid = &u
	}
}

// AddedXbUID returns the value that was added to the "xb_uid" field in this mutation.
func (m *WinBetslipsDetailMutation) AddedXbUID() (r int32, exists bool) {
	v := m.addxb_uid
	if v == nil {
		return
	}
	return *v, true
}

// ResetXbUID resets all changes to the "xb_uid" field.
func (m *WinBetslipsDetailMutation) ResetXbUID() {
	m.xb_uid = nil
	m.addxb_uid = nil
}

// SetXbUsername sets the "xb_username" field.
func (m *WinBetslipsDetailMutation) SetXbUsername(s string) {
	m.xb_username = &s
}

// XbUsername returns the value of the "xb_username" field in the mutation.
func (m *WinBetslipsDetailMutation) XbUsername() (r string, exists bool) {
	v := m.xb_username
	if v == nil {
		return
	}
	return *v, true
}

// OldXbUsername returns the old "xb_username" field's value of the WinBetslipsDetail entity.
// If the WinBetslipsDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipsDetailMutation) OldXbUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldXbUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldXbUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldXbUsername: %w", err)
	}
	return oldValue.XbUsername, nil
}

// ResetXbUsername resets all changes to the "xb_username" field.
func (m *WinBetslipsDetailMutation) ResetXbUsername() {
	m.xb_username = nil
}

// SetBetJSON sets the "bet_json" field.
func (m *WinBetslipsDetailMutation) SetBetJSON(s string) {
	m.bet_json = &s
}

// BetJSON returns the value of the "bet_json" field in the mutation.
func (m *WinBetslipsDetailMutation) BetJSON() (r string, exists bool) {
	v := m.bet_json
	if v == nil {
		return
	}
	return *v, true
}

// OldBetJSON returns the old "bet_json" field's value of the WinBetslipsDetail entity.
// If the WinBetslipsDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipsDetailMutation) OldBetJSON(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBetJSON is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBetJSON requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBetJSON: %w", err)
	}
	return oldValue.BetJSON, nil
}

// ClearBetJSON clears the value of the "bet_json" field.
func (m *WinBetslipsDetailMutation) ClearBetJSON() {
	m.bet_json = nil
	m.clearedFields[winbetslipsdetail.FieldBetJSON] = struct{}{}
}

// BetJSONCleared returns if the "bet_json" field was cleared in this mutation.
func (m *WinBetslipsDetailMutation) BetJSONCleared() bool {
	_, ok := m.clearedFields[winbetslipsdetail.FieldBetJSON]
	return ok
}

// ResetBetJSON resets all changes to the "bet_json" field.
func (m *WinBetslipsDetailMutation) ResetBetJSON() {
	m.bet_json = nil
	delete(m.clearedFields, winbetslipsdetail.FieldBetJSON)
}

// SetRewardJSON sets the "reward_json" field.
func (m *WinBetslipsDetailMutation) SetRewardJSON(s string) {
	m.reward_json = &s
}

// RewardJSON returns the value of the "reward_json" field in the mutation.
func (m *WinBetslipsDetailMutation) RewardJSON() (r string, exists bool) {
	v := m.reward_json
	if v == nil {
		return
	}
	return *v, true
}

// OldRewardJSON returns the old "reward_json" field's value of the WinBetslipsDetail entity.
// If the WinBetslipsDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipsDetailMutation) OldRewardJSON(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRewardJSON is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRewardJSON requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRewardJSON: %w", err)
	}
	return oldValue.RewardJSON, nil
}

// ClearRewardJSON clears the value of the "reward_json" field.
func (m *WinBetslipsDetailMutation) ClearRewardJSON() {
	m.reward_json = nil
	m.clearedFields[winbetslipsdetail.FieldRewardJSON] = struct{}{}
}

// RewardJSONCleared returns if the "reward_json" field was cleared in this mutation.
func (m *WinBetslipsDetailMutation) RewardJSONCleared() bool {
	_, ok := m.clearedFields[winbetslipsdetail.FieldRewardJSON]
	return ok
}

// ResetRewardJSON resets all changes to the "reward_json" field.
func (m *WinBetslipsDetailMutation) ResetRewardJSON() {
	m.reward_json = nil
	delete(m.clearedFields, winbetslipsdetail.FieldRewardJSON)
}

// SetRefundJSON sets the "refund_json" field.
func (m *WinBetslipsDetailMutation) SetRefundJSON(s string) {
	m.refund_json = &s
}

// RefundJSON returns the value of the "refund_json" field in the mutation.
func (m *WinBetslipsDetailMutation) RefundJSON() (r string, exists bool) {
	v := m.refund_json
	if v == nil {
		return
	}
	return *v, true
}

// OldRefundJSON returns the old "refund_json" field's value of the WinBetslipsDetail entity.
// If the WinBetslipsDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinBetslipsDetailMutation) OldRefundJSON(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefundJSON is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefundJSON requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefundJSON: %w", err)
	}
	return oldValue.RefundJSON, nil
}

// ClearRefundJSON clears the value of the "refund_json" field.
func (m *WinBetslipsDetailMutation) ClearRefundJSON() {
	m.refund_json = nil
	m.clearedFields[winbetslipsdetail.FieldRefundJSON] = struct{}{}
}

// RefundJSONCleared returns if the "refund_json" field was cleared in this mutation.
func (m *WinBetslipsDetailMutation) RefundJSONCleared() bool {
	_, ok := m.clearedFields[winbetslipsdetail.FieldRefundJSON]
	return ok
}

// ResetRefundJSON resets all changes to the "refund_json" field.
func (m *WinBetslipsDetailMutation) ResetRefundJSON() {
	m.refund_json = nil
	delete(m.clearedFields, winbetslipsdetail.FieldRefundJSON)
}

// Where appends a list predicates to the WinBetslipsDetailMutation builder.
func (m *WinBetslipsDetailMutation) Where(ps ...predicate.WinBetslipsDetail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WinBetslipsDetailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WinBetslipsDetailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WinBetslipsDetail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WinBetslipsDetailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WinBetslipsDetailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WinBetslipsDetail).
func (m *WinBetslipsDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WinBetslipsDetailMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.xb_uid != nil {
		fields = append(fields, winbetslipsdetail.FieldXbUID)
	}
	if m.xb_username != nil {
		fields = append(fields, winbetslipsdetail.FieldXbUsername)
	}
	if m.bet_json != nil {
		fields = append(fields, winbetslipsdetail.FieldBetJSON)
	}
	if m.reward_json != nil {
		fields = append(fields, winbetslipsdetail.FieldRewardJSON)
	}
	if m.refund_json != nil {
		fields = append(fields, winbetslipsdetail.FieldRefundJSON)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WinBetslipsDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case winbetslipsdetail.FieldXbUID:
		return m.XbUID()
	case winbetslipsdetail.FieldXbUsername:
		return m.XbUsername()
	case winbetslipsdetail.FieldBetJSON:
		return m.BetJSON()
	case winbetslipsdetail.FieldRewardJSON:
		return m.RewardJSON()
	case winbetslipsdetail.FieldRefundJSON:
		return m.RefundJSON()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WinBetslipsDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case winbetslipsdetail.FieldXbUID:
		return m.OldXbUID(ctx)
	case winbetslipsdetail.FieldXbUsername:
		return m.OldXbUsername(ctx)
	case winbetslipsdetail.FieldBetJSON:
		return m.OldBetJSON(ctx)
	case winbetslipsdetail.FieldRewardJSON:
		return m.OldRewardJSON(ctx)
	case winbetslipsdetail.FieldRefundJSON:
		return m.OldRefundJSON(ctx)
	}
	return nil, fmt.Errorf("unknown WinBetslipsDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WinBetslipsDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case winbetslipsdetail.FieldXbUID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetXbUID(v)
		return nil
	case winbetslipsdetail.FieldXbUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetXbUsername(v)
		return nil
	case winbetslipsdetail.FieldBetJSON:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBetJSON(v)
		return nil
	case winbetslipsdetail.FieldRewardJSON:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRewardJSON(v)
		return nil
	case winbetslipsdetail.FieldRefundJSON:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefundJSON(v)
		return nil
	}
	return fmt.Errorf("unknown WinBetslipsDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WinBetslipsDetailMutation) AddedFields() []string {
	var fields []string
	if m.addxb_uid != nil {
		fields = append(fields, winbetslipsdetail.FieldXbUID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WinBetslipsDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case winbetslipsdetail.FieldXbUID:
		return m.AddedXbUID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WinBetslipsDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case winbetslipsdetail.FieldXbUID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddXbUID(v)
		return nil
	}
	return fmt.Errorf("unknown WinBetslipsDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WinBetslipsDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(winbetslipsdetail.FieldBetJSON) {
		fields = append(fields, winbetslipsdetail.FieldBetJSON)
	}
	if m.FieldCleared(winbetslipsdetail.FieldRewardJSON) {
		fields = append(fields, winbetslipsdetail.FieldRewardJSON)
	}
	if m.FieldCleared(winbetslipsdetail.FieldRefundJSON) {
		fields = append(fields, winbetslipsdetail.FieldRefundJSON)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WinBetslipsDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WinBetslipsDetailMutation) ClearField(name string) error {
	switch name {
	case winbetslipsdetail.FieldBetJSON:
		m.ClearBetJSON()
		return nil
	case winbetslipsdetail.FieldRewardJSON:
		m.ClearRewardJSON()
		return nil
	case winbetslipsdetail.FieldRefundJSON:
		m.ClearRefundJSON()
		return nil
	}
	return fmt.Errorf("unknown WinBetslipsDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WinBetslipsDetailMutation) ResetField(name string) error {
	switch name {
	case winbetslipsdetail.FieldXbUID:
		m.ResetXbUID()
		return nil
	case winbetslipsdetail.FieldXbUsername:
		m.ResetXbUsername()
		return nil
	case winbetslipsdetail.FieldBetJSON:
		m.ResetBetJSON()
		return nil
	case winbetslipsdetail.FieldRewardJSON:
		m.ResetRewardJSON()
		return nil
	case winbetslipsdetail.FieldRefundJSON:
		m.ResetRefundJSON()
		return nil
	}
	return fmt.Errorf("unknown WinBetslipsDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WinBetslipsDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WinBetslipsDetailMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WinBetslipsDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WinBetslipsDetailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WinBetslipsDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WinBetslipsDetailMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WinBetslipsDetailMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WinBetslipsDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WinBetslipsDetailMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WinBetslipsDetail edge %s", name)
}

// WinCoinLogMutation represents an operation that mutates the WinCoinLog nodes in the graph.
type WinCoinLogMutation struct {
	config
	op             Op
	typ            string
	id             *int
	uid            *int32
	adduid         *int32
	username       *string
	category       *int8
	addcategory    *int8
	refer_id       *int
	addrefer_id    *int
	coin           *float64
	addcoin        *float64
	coin_real      *float64
	addcoin_real   *float64
	plat_id        *int32
	addplat_id     *int32
	out_in         *int8
	addout_in      *int8
	game_id        *int32
	addgame_id     *int32
	coin_before    *float64
	addcoin_before *float64
	coin_after     *float64
	addcoin_after  *float64
	status         *int8
	addstatus      *int8
	created_at     *int32
	addcreated_at  *int32
	updated_at     *int32
	addupdated_at  *int32
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*WinCoinLog, error)
	predicates     []predicate.WinCoinLog
}

var _ ent.Mutation = (*WinCoinLogMutation)(nil)

// wincoinlogOption allows management of the mutation configuration using functional options.
type wincoinlogOption func(*WinCoinLogMutation)

// newWinCoinLogMutation creates new mutation for the WinCoinLog entity.
func newWinCoinLogMutation(c config, op Op, opts ...wincoinlogOption) *WinCoinLogMutation {
	m := &WinCoinLogMutation{
		config:        c,
		op:            op,
		typ:           TypeWinCoinLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWinCoinLogID sets the ID field of the mutation.
func withWinCoinLogID(id int) wincoinlogOption {
	return func(m *WinCoinLogMutation) {
		var (
			err   error
			once  sync.Once
			value *WinCoinLog
		)
		m.oldValue = func(ctx context.Context) (*WinCoinLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WinCoinLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWinCoinLog sets the old WinCoinLog of the mutation.
func withWinCoinLog(node *WinCoinLog) wincoinlogOption {
	return func(m *WinCoinLogMutation) {
		m.oldValue = func(context.Context) (*WinCoinLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WinCoinLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WinCoinLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WinCoinLog entities.
func (m *WinCoinLogMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WinCoinLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WinCoinLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WinCoinLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *WinCoinLogMutation) SetUID(i int32) {
	m.uid = &i
	m.adduid = nil
}

// UID returns the value of the "uid" field in the mutation.
func (m *WinCoinLogMutation) UID() (r int32, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the WinCoinLog entity.
// If the WinCoinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinCoinLogMutation) OldUID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// AddUID adds i to the "uid" field.
func (m *WinCoinLogMutation) AddUID(i int32) {
	if m.adduid != nil {
		*m.adduid += i
	} else {
		m.adduid = &i
	}
}

// AddedUID returns the value that was added to the "uid" field in this mutation.
func (m *WinCoinLogMutation) AddedUID() (r int32, exists bool) {
	v := m.adduid
	if v == nil {
		return
	}
	return *v, true
}

// ResetUID resets all changes to the "uid" field.
func (m *WinCoinLogMutation) ResetUID() {
	m.uid = nil
	m.adduid = nil
}

// SetUsername sets the "username" field.
func (m *WinCoinLogMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *WinCoinLogMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the WinCoinLog entity.
// If the WinCoinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinCoinLogMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *WinCoinLogMutation) ResetUsername() {
	m.username = nil
}

// SetCategory sets the "category" field.
func (m *WinCoinLogMutation) SetCategory(i int8) {
	m.category = &i
	m.addcategory = nil
}

// Category returns the value of the "category" field in the mutation.
func (m *WinCoinLogMutation) Category() (r int8, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the WinCoinLog entity.
// If the WinCoinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinCoinLogMutation) OldCategory(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// AddCategory adds i to the "category" field.
func (m *WinCoinLogMutation) AddCategory(i int8) {
	if m.addcategory != nil {
		*m.addcategory += i
	} else {
		m.addcategory = &i
	}
}

// AddedCategory returns the value that was added to the "category" field in this mutation.
func (m *WinCoinLogMutation) AddedCategory() (r int8, exists bool) {
	v := m.addcategory
	if v == nil {
		return
	}
	return *v, true
}

// ResetCategory resets all changes to the "category" field.
func (m *WinCoinLogMutation) ResetCategory() {
	m.category = nil
	m.addcategory = nil
}

// SetReferID sets the "refer_id" field.
func (m *WinCoinLogMutation) SetReferID(i int) {
	m.refer_id = &i
	m.addrefer_id = nil
}

// ReferID returns the value of the "refer_id" field in the mutation.
func (m *WinCoinLogMutation) ReferID() (r int, exists bool) {
	v := m.refer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReferID returns the old "refer_id" field's value of the WinCoinLog entity.
// If the WinCoinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinCoinLogMutation) OldReferID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferID: %w", err)
	}
	return oldValue.ReferID, nil
}

// AddReferID adds i to the "refer_id" field.
func (m *WinCoinLogMutation) AddReferID(i int) {
	if m.addrefer_id != nil {
		*m.addrefer_id += i
	} else {
		m.addrefer_id = &i
	}
}

// AddedReferID returns the value that was added to the "refer_id" field in this mutation.
func (m *WinCoinLogMutation) AddedReferID() (r int, exists bool) {
	v := m.addrefer_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearReferID clears the value of the "refer_id" field.
func (m *WinCoinLogMutation) ClearReferID() {
	m.refer_id = nil
	m.addrefer_id = nil
	m.clearedFields[wincoinlog.FieldReferID] = struct{}{}
}

// ReferIDCleared returns if the "refer_id" field was cleared in this mutation.
func (m *WinCoinLogMutation) ReferIDCleared() bool {
	_, ok := m.clearedFields[wincoinlog.FieldReferID]
	return ok
}

// ResetReferID resets all changes to the "refer_id" field.
func (m *WinCoinLogMutation) ResetReferID() {
	m.refer_id = nil
	m.addrefer_id = nil
	delete(m.clearedFields, wincoinlog.FieldReferID)
}

// SetCoin sets the "coin" field.
func (m *WinCoinLogMutation) SetCoin(f float64) {
	m.coin = &f
	m.addcoin = nil
}

// Coin returns the value of the "coin" field in the mutation.
func (m *WinCoinLogMutation) Coin() (r float64, exists bool) {
	v := m.coin
	if v == nil {
		return
	}
	return *v, true
}

// OldCoin returns the old "coin" field's value of the WinCoinLog entity.
// If the WinCoinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinCoinLogMutation) OldCoin(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoin: %w", err)
	}
	return oldValue.Coin, nil
}

// AddCoin adds f to the "coin" field.
func (m *WinCoinLogMutation) AddCoin(f float64) {
	if m.addcoin != nil {
		*m.addcoin += f
	} else {
		m.addcoin = &f
	}
}

// AddedCoin returns the value that was added to the "coin" field in this mutation.
func (m *WinCoinLogMutation) AddedCoin() (r float64, exists bool) {
	v := m.addcoin
	if v == nil {
		return
	}
	return *v, true
}

// ResetCoin resets all changes to the "coin" field.
func (m *WinCoinLogMutation) ResetCoin() {
	m.coin = nil
	m.addcoin = nil
}

// SetCoinReal sets the "coin_real" field.
func (m *WinCoinLogMutation) SetCoinReal(f float64) {
	m.coin_real = &f
	m.addcoin_real = nil
}

// CoinReal returns the value of the "coin_real" field in the mutation.
func (m *WinCoinLogMutation) CoinReal() (r float64, exists bool) {
	v := m.coin_real
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinReal returns the old "coin_real" field's value of the WinCoinLog entity.
// If the WinCoinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinCoinLogMutation) OldCoinReal(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinReal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinReal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinReal: %w", err)
	}
	return oldValue.CoinReal, nil
}

// AddCoinReal adds f to the "coin_real" field.
func (m *WinCoinLogMutation) AddCoinReal(f float64) {
	if m.addcoin_real != nil {
		*m.addcoin_real += f
	} else {
		m.addcoin_real = &f
	}
}

// AddedCoinReal returns the value that was added to the "coin_real" field in this mutation.
func (m *WinCoinLogMutation) AddedCoinReal() (r float64, exists bool) {
	v := m.addcoin_real
	if v == nil {
		return
	}
	return *v, true
}

// ResetCoinReal resets all changes to the "coin_real" field.
func (m *WinCoinLogMutation) ResetCoinReal() {
	m.coin_real = nil
	m.addcoin_real = nil
}

// SetPlatID sets the "plat_id" field.
func (m *WinCoinLogMutation) SetPlatID(i int32) {
	m.plat_id = &i
	m.addplat_id = nil
}

// PlatID returns the value of the "plat_id" field in the mutation.
func (m *WinCoinLogMutation) PlatID() (r int32, exists bool) {
	v := m.plat_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatID returns the old "plat_id" field's value of the WinCoinLog entity.
// If the WinCoinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinCoinLogMutation) OldPlatID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatID: %w", err)
	}
	return oldValue.PlatID, nil
}

// AddPlatID adds i to the "plat_id" field.
func (m *WinCoinLogMutation) AddPlatID(i int32) {
	if m.addplat_id != nil {
		*m.addplat_id += i
	} else {
		m.addplat_id = &i
	}
}

// AddedPlatID returns the value that was added to the "plat_id" field in this mutation.
func (m *WinCoinLogMutation) AddedPlatID() (r int32, exists bool) {
	v := m.addplat_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPlatID resets all changes to the "plat_id" field.
func (m *WinCoinLogMutation) ResetPlatID() {
	m.plat_id = nil
	m.addplat_id = nil
}

// SetOutIn sets the "out_in" field.
func (m *WinCoinLogMutation) SetOutIn(i int8) {
	m.out_in = &i
	m.addout_in = nil
}

// OutIn returns the value of the "out_in" field in the mutation.
func (m *WinCoinLogMutation) OutIn() (r int8, exists bool) {
	v := m.out_in
	if v == nil {
		return
	}
	return *v, true
}

// OldOutIn returns the old "out_in" field's value of the WinCoinLog entity.
// If the WinCoinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinCoinLogMutation) OldOutIn(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutIn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutIn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutIn: %w", err)
	}
	return oldValue.OutIn, nil
}

// AddOutIn adds i to the "out_in" field.
func (m *WinCoinLogMutation) AddOutIn(i int8) {
	if m.addout_in != nil {
		*m.addout_in += i
	} else {
		m.addout_in = &i
	}
}

// AddedOutIn returns the value that was added to the "out_in" field in this mutation.
func (m *WinCoinLogMutation) AddedOutIn() (r int8, exists bool) {
	v := m.addout_in
	if v == nil {
		return
	}
	return *v, true
}

// ResetOutIn resets all changes to the "out_in" field.
func (m *WinCoinLogMutation) ResetOutIn() {
	m.out_in = nil
	m.addout_in = nil
}

// SetGameID sets the "game_id" field.
func (m *WinCoinLogMutation) SetGameID(i int32) {
	m.game_id = &i
	m.addgame_id = nil
}

// GameID returns the value of the "game_id" field in the mutation.
func (m *WinCoinLogMutation) GameID() (r int32, exists bool) {
	v := m.game_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGameID returns the old "game_id" field's value of the WinCoinLog entity.
// If the WinCoinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinCoinLogMutation) OldGameID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGameID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGameID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGameID: %w", err)
	}
	return oldValue.GameID, nil
}

// AddGameID adds i to the "game_id" field.
func (m *WinCoinLogMutation) AddGameID(i int32) {
	if m.addgame_id != nil {
		*m.addgame_id += i
	} else {
		m.addgame_id = &i
	}
}

// AddedGameID returns the value that was added to the "game_id" field in this mutation.
func (m *WinCoinLogMutation) AddedGameID() (r int32, exists bool) {
	v := m.addgame_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetGameID resets all changes to the "game_id" field.
func (m *WinCoinLogMutation) ResetGameID() {
	m.game_id = nil
	m.addgame_id = nil
}

// SetCoinBefore sets the "coin_before" field.
func (m *WinCoinLogMutation) SetCoinBefore(f float64) {
	m.coin_before = &f
	m.addcoin_before = nil
}

// CoinBefore returns the value of the "coin_before" field in the mutation.
func (m *WinCoinLogMutation) CoinBefore() (r float64, exists bool) {
	v := m.coin_before
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinBefore returns the old "coin_before" field's value of the WinCoinLog entity.
// If the WinCoinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinCoinLogMutation) OldCoinBefore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinBefore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinBefore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinBefore: %w", err)
	}
	return oldValue.CoinBefore, nil
}

// AddCoinBefore adds f to the "coin_before" field.
func (m *WinCoinLogMutation) AddCoinBefore(f float64) {
	if m.addcoin_before != nil {
		*m.addcoin_before += f
	} else {
		m.addcoin_before = &f
	}
}

// AddedCoinBefore returns the value that was added to the "coin_before" field in this mutation.
func (m *WinCoinLogMutation) AddedCoinBefore() (r float64, exists bool) {
	v := m.addcoin_before
	if v == nil {
		return
	}
	return *v, true
}

// ResetCoinBefore resets all changes to the "coin_before" field.
func (m *WinCoinLogMutation) ResetCoinBefore() {
	m.coin_before = nil
	m.addcoin_before = nil
}

// SetCoinAfter sets the "coin_after" field.
func (m *WinCoinLogMutation) SetCoinAfter(f float64) {
	m.coin_after = &f
	m.addcoin_after = nil
}

// CoinAfter returns the value of the "coin_after" field in the mutation.
func (m *WinCoinLogMutation) CoinAfter() (r float64, exists bool) {
	v := m.coin_after
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinAfter returns the old "coin_after" field's value of the WinCoinLog entity.
// If the WinCoinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinCoinLogMutation) OldCoinAfter(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinAfter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinAfter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinAfter: %w", err)
	}
	return oldValue.CoinAfter, nil
}

// AddCoinAfter adds f to the "coin_after" field.
func (m *WinCoinLogMutation) AddCoinAfter(f float64) {
	if m.addcoin_after != nil {
		*m.addcoin_after += f
	} else {
		m.addcoin_after = &f
	}
}

// AddedCoinAfter returns the value that was added to the "coin_after" field in this mutation.
func (m *WinCoinLogMutation) AddedCoinAfter() (r float64, exists bool) {
	v := m.addcoin_after
	if v == nil {
		return
	}
	return *v, true
}

// ResetCoinAfter resets all changes to the "coin_after" field.
func (m *WinCoinLogMutation) ResetCoinAfter() {
	m.coin_after = nil
	m.addcoin_after = nil
}

// SetStatus sets the "status" field.
func (m *WinCoinLogMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *WinCoinLogMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the WinCoinLog entity.
// If the WinCoinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinCoinLogMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *WinCoinLogMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *WinCoinLogMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *WinCoinLogMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WinCoinLogMutation) SetCreatedAt(i int32) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WinCoinLogMutation) CreatedAt() (r int32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WinCoinLog entity.
// If the WinCoinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinCoinLogMutation) OldCreatedAt(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *WinCoinLogMutation) AddCreatedAt(i int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *WinCoinLogMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WinCoinLogMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WinCoinLogMutation) SetUpdatedAt(i int32) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WinCoinLogMutation) UpdatedAt() (r int32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WinCoinLog entity.
// If the WinCoinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinCoinLogMutation) OldUpdatedAt(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *WinCoinLogMutation) AddUpdatedAt(i int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *WinCoinLogMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WinCoinLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// Where appends a list predicates to the WinCoinLogMutation builder.
func (m *WinCoinLogMutation) Where(ps ...predicate.WinCoinLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WinCoinLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WinCoinLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WinCoinLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WinCoinLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WinCoinLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WinCoinLog).
func (m *WinCoinLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WinCoinLogMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.uid != nil {
		fields = append(fields, wincoinlog.FieldUID)
	}
	if m.username != nil {
		fields = append(fields, wincoinlog.FieldUsername)
	}
	if m.category != nil {
		fields = append(fields, wincoinlog.FieldCategory)
	}
	if m.refer_id != nil {
		fields = append(fields, wincoinlog.FieldReferID)
	}
	if m.coin != nil {
		fields = append(fields, wincoinlog.FieldCoin)
	}
	if m.coin_real != nil {
		fields = append(fields, wincoinlog.FieldCoinReal)
	}
	if m.plat_id != nil {
		fields = append(fields, wincoinlog.FieldPlatID)
	}
	if m.out_in != nil {
		fields = append(fields, wincoinlog.FieldOutIn)
	}
	if m.game_id != nil {
		fields = append(fields, wincoinlog.FieldGameID)
	}
	if m.coin_before != nil {
		fields = append(fields, wincoinlog.FieldCoinBefore)
	}
	if m.coin_after != nil {
		fields = append(fields, wincoinlog.FieldCoinAfter)
	}
	if m.status != nil {
		fields = append(fields, wincoinlog.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, wincoinlog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, wincoinlog.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WinCoinLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wincoinlog.FieldUID:
		return m.UID()
	case wincoinlog.FieldUsername:
		return m.Username()
	case wincoinlog.FieldCategory:
		return m.Category()
	case wincoinlog.FieldReferID:
		return m.ReferID()
	case wincoinlog.FieldCoin:
		return m.Coin()
	case wincoinlog.FieldCoinReal:
		return m.CoinReal()
	case wincoinlog.FieldPlatID:
		return m.PlatID()
	case wincoinlog.FieldOutIn:
		return m.OutIn()
	case wincoinlog.FieldGameID:
		return m.GameID()
	case wincoinlog.FieldCoinBefore:
		return m.CoinBefore()
	case wincoinlog.FieldCoinAfter:
		return m.CoinAfter()
	case wincoinlog.FieldStatus:
		return m.Status()
	case wincoinlog.FieldCreatedAt:
		return m.CreatedAt()
	case wincoinlog.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WinCoinLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wincoinlog.FieldUID:
		return m.OldUID(ctx)
	case wincoinlog.FieldUsername:
		return m.OldUsername(ctx)
	case wincoinlog.FieldCategory:
		return m.OldCategory(ctx)
	case wincoinlog.FieldReferID:
		return m.OldReferID(ctx)
	case wincoinlog.FieldCoin:
		return m.OldCoin(ctx)
	case wincoinlog.FieldCoinReal:
		return m.OldCoinReal(ctx)
	case wincoinlog.FieldPlatID:
		return m.OldPlatID(ctx)
	case wincoinlog.FieldOutIn:
		return m.OldOutIn(ctx)
	case wincoinlog.FieldGameID:
		return m.OldGameID(ctx)
	case wincoinlog.FieldCoinBefore:
		return m.OldCoinBefore(ctx)
	case wincoinlog.FieldCoinAfter:
		return m.OldCoinAfter(ctx)
	case wincoinlog.FieldStatus:
		return m.OldStatus(ctx)
	case wincoinlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case wincoinlog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WinCoinLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WinCoinLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wincoinlog.FieldUID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case wincoinlog.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case wincoinlog.FieldCategory:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case wincoinlog.FieldReferID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferID(v)
		return nil
	case wincoinlog.FieldCoin:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoin(v)
		return nil
	case wincoinlog.FieldCoinReal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinReal(v)
		return nil
	case wincoinlog.FieldPlatID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatID(v)
		return nil
	case wincoinlog.FieldOutIn:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutIn(v)
		return nil
	case wincoinlog.FieldGameID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGameID(v)
		return nil
	case wincoinlog.FieldCoinBefore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinBefore(v)
		return nil
	case wincoinlog.FieldCoinAfter:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinAfter(v)
		return nil
	case wincoinlog.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case wincoinlog.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case wincoinlog.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WinCoinLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WinCoinLogMutation) AddedFields() []string {
	var fields []string
	if m.adduid != nil {
		fields = append(fields, wincoinlog.FieldUID)
	}
	if m.addcategory != nil {
		fields = append(fields, wincoinlog.FieldCategory)
	}
	if m.addrefer_id != nil {
		fields = append(fields, wincoinlog.FieldReferID)
	}
	if m.addcoin != nil {
		fields = append(fields, wincoinlog.FieldCoin)
	}
	if m.addcoin_real != nil {
		fields = append(fields, wincoinlog.FieldCoinReal)
	}
	if m.addplat_id != nil {
		fields = append(fields, wincoinlog.FieldPlatID)
	}
	if m.addout_in != nil {
		fields = append(fields, wincoinlog.FieldOutIn)
	}
	if m.addgame_id != nil {
		fields = append(fields, wincoinlog.FieldGameID)
	}
	if m.addcoin_before != nil {
		fields = append(fields, wincoinlog.FieldCoinBefore)
	}
	if m.addcoin_after != nil {
		fields = append(fields, wincoinlog.FieldCoinAfter)
	}
	if m.addstatus != nil {
		fields = append(fields, wincoinlog.FieldStatus)
	}
	if m.addcreated_at != nil {
		fields = append(fields, wincoinlog.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, wincoinlog.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WinCoinLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case wincoinlog.FieldUID:
		return m.AddedUID()
	case wincoinlog.FieldCategory:
		return m.AddedCategory()
	case wincoinlog.FieldReferID:
		return m.AddedReferID()
	case wincoinlog.FieldCoin:
		return m.AddedCoin()
	case wincoinlog.FieldCoinReal:
		return m.AddedCoinReal()
	case wincoinlog.FieldPlatID:
		return m.AddedPlatID()
	case wincoinlog.FieldOutIn:
		return m.AddedOutIn()
	case wincoinlog.FieldGameID:
		return m.AddedGameID()
	case wincoinlog.FieldCoinBefore:
		return m.AddedCoinBefore()
	case wincoinlog.FieldCoinAfter:
		return m.AddedCoinAfter()
	case wincoinlog.FieldStatus:
		return m.AddedStatus()
	case wincoinlog.FieldCreatedAt:
		return m.AddedCreatedAt()
	case wincoinlog.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WinCoinLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case wincoinlog.FieldUID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUID(v)
		return nil
	case wincoinlog.FieldCategory:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategory(v)
		return nil
	case wincoinlog.FieldReferID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReferID(v)
		return nil
	case wincoinlog.FieldCoin:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoin(v)
		return nil
	case wincoinlog.FieldCoinReal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoinReal(v)
		return nil
	case wincoinlog.FieldPlatID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlatID(v)
		return nil
	case wincoinlog.FieldOutIn:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutIn(v)
		return nil
	case wincoinlog.FieldGameID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGameID(v)
		return nil
	case wincoinlog.FieldCoinBefore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoinBefore(v)
		return nil
	case wincoinlog.FieldCoinAfter:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoinAfter(v)
		return nil
	case wincoinlog.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case wincoinlog.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case wincoinlog.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WinCoinLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WinCoinLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(wincoinlog.FieldReferID) {
		fields = append(fields, wincoinlog.FieldReferID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WinCoinLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WinCoinLogMutation) ClearField(name string) error {
	switch name {
	case wincoinlog.FieldReferID:
		m.ClearReferID()
		return nil
	}
	return fmt.Errorf("unknown WinCoinLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WinCoinLogMutation) ResetField(name string) error {
	switch name {
	case wincoinlog.FieldUID:
		m.ResetUID()
		return nil
	case wincoinlog.FieldUsername:
		m.ResetUsername()
		return nil
	case wincoinlog.FieldCategory:
		m.ResetCategory()
		return nil
	case wincoinlog.FieldReferID:
		m.ResetReferID()
		return nil
	case wincoinlog.FieldCoin:
		m.ResetCoin()
		return nil
	case wincoinlog.FieldCoinReal:
		m.ResetCoinReal()
		return nil
	case wincoinlog.FieldPlatID:
		m.ResetPlatID()
		return nil
	case wincoinlog.FieldOutIn:
		m.ResetOutIn()
		return nil
	case wincoinlog.FieldGameID:
		m.ResetGameID()
		return nil
	case wincoinlog.FieldCoinBefore:
		m.ResetCoinBefore()
		return nil
	case wincoinlog.FieldCoinAfter:
		m.ResetCoinAfter()
		return nil
	case wincoinlog.FieldStatus:
		m.ResetStatus()
		return nil
	case wincoinlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case wincoinlog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown WinCoinLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WinCoinLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WinCoinLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WinCoinLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WinCoinLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WinCoinLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WinCoinLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WinCoinLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WinCoinLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WinCoinLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WinCoinLog edge %s", name)
}

// WinConfigMutation represents an operation that mutates the WinConfig nodes in the graph.
type WinConfigMutation struct {
	config
	op            Op
	typ           string
	id            *int32
	title         *string
	title_zh      *string
	value         *string
	show_app      *int8
	addshow_app   *int8
	can_modify    *int8
	addcan_modify *int8
	status        *int8
	addstatus     *int8
	created_at    *int32
	addcreated_at *int32
	updated_at    *int32
	addupdated_at *int32
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WinConfig, error)
	predicates    []predicate.WinConfig
}

var _ ent.Mutation = (*WinConfigMutation)(nil)

// winconfigOption allows management of the mutation configuration using functional options.
type winconfigOption func(*WinConfigMutation)

// newWinConfigMutation creates new mutation for the WinConfig entity.
func newWinConfigMutation(c config, op Op, opts ...winconfigOption) *WinConfigMutation {
	m := &WinConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeWinConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWinConfigID sets the ID field of the mutation.
func withWinConfigID(id int32) winconfigOption {
	return func(m *WinConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *WinConfig
		)
		m.oldValue = func(ctx context.Context) (*WinConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WinConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWinConfig sets the old WinConfig of the mutation.
func withWinConfig(node *WinConfig) winconfigOption {
	return func(m *WinConfigMutation) {
		m.oldValue = func(context.Context) (*WinConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WinConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WinConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WinConfig entities.
func (m *WinConfigMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WinConfigMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WinConfigMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WinConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *WinConfigMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *WinConfigMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the WinConfig entity.
// If the WinConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinConfigMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *WinConfigMutation) ResetTitle() {
	m.title = nil
}

// SetTitleZh sets the "title_zh" field.
func (m *WinConfigMutation) SetTitleZh(s string) {
	m.title_zh = &s
}

// TitleZh returns the value of the "title_zh" field in the mutation.
func (m *WinConfigMutation) TitleZh() (r string, exists bool) {
	v := m.title_zh
	if v == nil {
		return
	}
	return *v, true
}

// OldTitleZh returns the old "title_zh" field's value of the WinConfig entity.
// If the WinConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinConfigMutation) OldTitleZh(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitleZh is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitleZh requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitleZh: %w", err)
	}
	return oldValue.TitleZh, nil
}

// ResetTitleZh resets all changes to the "title_zh" field.
func (m *WinConfigMutation) ResetTitleZh() {
	m.title_zh = nil
}

// SetValue sets the "value" field.
func (m *WinConfigMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *WinConfigMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the WinConfig entity.
// If the WinConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinConfigMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *WinConfigMutation) ResetValue() {
	m.value = nil
}

// SetShowApp sets the "show_app" field.
func (m *WinConfigMutation) SetShowApp(i int8) {
	m.show_app = &i
	m.addshow_app = nil
}

// ShowApp returns the value of the "show_app" field in the mutation.
func (m *WinConfigMutation) ShowApp() (r int8, exists bool) {
	v := m.show_app
	if v == nil {
		return
	}
	return *v, true
}

// OldShowApp returns the old "show_app" field's value of the WinConfig entity.
// If the WinConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinConfigMutation) OldShowApp(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShowApp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShowApp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowApp: %w", err)
	}
	return oldValue.ShowApp, nil
}

// AddShowApp adds i to the "show_app" field.
func (m *WinConfigMutation) AddShowApp(i int8) {
	if m.addshow_app != nil {
		*m.addshow_app += i
	} else {
		m.addshow_app = &i
	}
}

// AddedShowApp returns the value that was added to the "show_app" field in this mutation.
func (m *WinConfigMutation) AddedShowApp() (r int8, exists bool) {
	v := m.addshow_app
	if v == nil {
		return
	}
	return *v, true
}

// ResetShowApp resets all changes to the "show_app" field.
func (m *WinConfigMutation) ResetShowApp() {
	m.show_app = nil
	m.addshow_app = nil
}

// SetCanModify sets the "can_modify" field.
func (m *WinConfigMutation) SetCanModify(i int8) {
	m.can_modify = &i
	m.addcan_modify = nil
}

// CanModify returns the value of the "can_modify" field in the mutation.
func (m *WinConfigMutation) CanModify() (r int8, exists bool) {
	v := m.can_modify
	if v == nil {
		return
	}
	return *v, true
}

// OldCanModify returns the old "can_modify" field's value of the WinConfig entity.
// If the WinConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinConfigMutation) OldCanModify(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanModify is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanModify requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanModify: %w", err)
	}
	return oldValue.CanModify, nil
}

// AddCanModify adds i to the "can_modify" field.
func (m *WinConfigMutation) AddCanModify(i int8) {
	if m.addcan_modify != nil {
		*m.addcan_modify += i
	} else {
		m.addcan_modify = &i
	}
}

// AddedCanModify returns the value that was added to the "can_modify" field in this mutation.
func (m *WinConfigMutation) AddedCanModify() (r int8, exists bool) {
	v := m.addcan_modify
	if v == nil {
		return
	}
	return *v, true
}

// ResetCanModify resets all changes to the "can_modify" field.
func (m *WinConfigMutation) ResetCanModify() {
	m.can_modify = nil
	m.addcan_modify = nil
}

// SetStatus sets the "status" field.
func (m *WinConfigMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *WinConfigMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the WinConfig entity.
// If the WinConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinConfigMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *WinConfigMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *WinConfigMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *WinConfigMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WinConfigMutation) SetCreatedAt(i int32) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WinConfigMutation) CreatedAt() (r int32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WinConfig entity.
// If the WinConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinConfigMutation) OldCreatedAt(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *WinConfigMutation) AddCreatedAt(i int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *WinConfigMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WinConfigMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WinConfigMutation) SetUpdatedAt(i int32) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WinConfigMutation) UpdatedAt() (r int32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WinConfig entity.
// If the WinConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinConfigMutation) OldUpdatedAt(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *WinConfigMutation) AddUpdatedAt(i int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *WinConfigMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WinConfigMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// Where appends a list predicates to the WinConfigMutation builder.
func (m *WinConfigMutation) Where(ps ...predicate.WinConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WinConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WinConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WinConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WinConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WinConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WinConfig).
func (m *WinConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WinConfigMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.title != nil {
		fields = append(fields, winconfig.FieldTitle)
	}
	if m.title_zh != nil {
		fields = append(fields, winconfig.FieldTitleZh)
	}
	if m.value != nil {
		fields = append(fields, winconfig.FieldValue)
	}
	if m.show_app != nil {
		fields = append(fields, winconfig.FieldShowApp)
	}
	if m.can_modify != nil {
		fields = append(fields, winconfig.FieldCanModify)
	}
	if m.status != nil {
		fields = append(fields, winconfig.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, winconfig.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, winconfig.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WinConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case winconfig.FieldTitle:
		return m.Title()
	case winconfig.FieldTitleZh:
		return m.TitleZh()
	case winconfig.FieldValue:
		return m.Value()
	case winconfig.FieldShowApp:
		return m.ShowApp()
	case winconfig.FieldCanModify:
		return m.CanModify()
	case winconfig.FieldStatus:
		return m.Status()
	case winconfig.FieldCreatedAt:
		return m.CreatedAt()
	case winconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WinConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case winconfig.FieldTitle:
		return m.OldTitle(ctx)
	case winconfig.FieldTitleZh:
		return m.OldTitleZh(ctx)
	case winconfig.FieldValue:
		return m.OldValue(ctx)
	case winconfig.FieldShowApp:
		return m.OldShowApp(ctx)
	case winconfig.FieldCanModify:
		return m.OldCanModify(ctx)
	case winconfig.FieldStatus:
		return m.OldStatus(ctx)
	case winconfig.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case winconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WinConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WinConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case winconfig.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case winconfig.FieldTitleZh:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitleZh(v)
		return nil
	case winconfig.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case winconfig.FieldShowApp:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowApp(v)
		return nil
	case winconfig.FieldCanModify:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanModify(v)
		return nil
	case winconfig.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case winconfig.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case winconfig.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WinConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WinConfigMutation) AddedFields() []string {
	var fields []string
	if m.addshow_app != nil {
		fields = append(fields, winconfig.FieldShowApp)
	}
	if m.addcan_modify != nil {
		fields = append(fields, winconfig.FieldCanModify)
	}
	if m.addstatus != nil {
		fields = append(fields, winconfig.FieldStatus)
	}
	if m.addcreated_at != nil {
		fields = append(fields, winconfig.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, winconfig.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WinConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case winconfig.FieldShowApp:
		return m.AddedShowApp()
	case winconfig.FieldCanModify:
		return m.AddedCanModify()
	case winconfig.FieldStatus:
		return m.AddedStatus()
	case winconfig.FieldCreatedAt:
		return m.AddedCreatedAt()
	case winconfig.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WinConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	case winconfig.FieldShowApp:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShowApp(v)
		return nil
	case winconfig.FieldCanModify:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCanModify(v)
		return nil
	case winconfig.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case winconfig.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case winconfig.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WinConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WinConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WinConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WinConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WinConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WinConfigMutation) ResetField(name string) error {
	switch name {
	case winconfig.FieldTitle:
		m.ResetTitle()
		return nil
	case winconfig.FieldTitleZh:
		m.ResetTitleZh()
		return nil
	case winconfig.FieldValue:
		m.ResetValue()
		return nil
	case winconfig.FieldShowApp:
		m.ResetShowApp()
		return nil
	case winconfig.FieldCanModify:
		m.ResetCanModify()
		return nil
	case winconfig.FieldStatus:
		m.ResetStatus()
		return nil
	case winconfig.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case winconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown WinConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WinConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WinConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WinConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WinConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WinConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WinConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WinConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WinConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WinConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WinConfig edge %s", name)
}

// WinDictMutation represents an operation that mutates the WinDict nodes in the graph.
type WinDictMutation struct {
	config
	op            Op
	typ           string
	id            *int32
	title         *string
	category      *string
	status        *bool
	created_at    *int32
	addcreated_at *int32
	updated_at    *int32
	addupdated_at *int32
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WinDict, error)
	predicates    []predicate.WinDict
}

var _ ent.Mutation = (*WinDictMutation)(nil)

// windictOption allows management of the mutation configuration using functional options.
type windictOption func(*WinDictMutation)

// newWinDictMutation creates new mutation for the WinDict entity.
func newWinDictMutation(c config, op Op, opts ...windictOption) *WinDictMutation {
	m := &WinDictMutation{
		config:        c,
		op:            op,
		typ:           TypeWinDict,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWinDictID sets the ID field of the mutation.
func withWinDictID(id int32) windictOption {
	return func(m *WinDictMutation) {
		var (
			err   error
			once  sync.Once
			value *WinDict
		)
		m.oldValue = func(ctx context.Context) (*WinDict, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WinDict.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWinDict sets the old WinDict of the mutation.
func withWinDict(node *WinDict) windictOption {
	return func(m *WinDictMutation) {
		m.oldValue = func(context.Context) (*WinDict, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WinDictMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WinDictMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WinDict entities.
func (m *WinDictMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WinDictMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WinDictMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WinDict.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *WinDictMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *WinDictMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the WinDict entity.
// If the WinDict object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinDictMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *WinDictMutation) ResetTitle() {
	m.title = nil
}

// SetCategory sets the "category" field.
func (m *WinDictMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *WinDictMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the WinDict entity.
// If the WinDict object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinDictMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *WinDictMutation) ResetCategory() {
	m.category = nil
}

// SetStatus sets the "status" field.
func (m *WinDictMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *WinDictMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the WinDict entity.
// If the WinDict object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinDictMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *WinDictMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WinDictMutation) SetCreatedAt(i int32) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WinDictMutation) CreatedAt() (r int32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WinDict entity.
// If the WinDict object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinDictMutation) OldCreatedAt(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *WinDictMutation) AddCreatedAt(i int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *WinDictMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WinDictMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WinDictMutation) SetUpdatedAt(i int32) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WinDictMutation) UpdatedAt() (r int32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WinDict entity.
// If the WinDict object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinDictMutation) OldUpdatedAt(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *WinDictMutation) AddUpdatedAt(i int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *WinDictMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WinDictMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// Where appends a list predicates to the WinDictMutation builder.
func (m *WinDictMutation) Where(ps ...predicate.WinDict) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WinDictMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WinDictMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WinDict, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WinDictMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WinDictMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WinDict).
func (m *WinDictMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WinDictMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.title != nil {
		fields = append(fields, windict.FieldTitle)
	}
	if m.category != nil {
		fields = append(fields, windict.FieldCategory)
	}
	if m.status != nil {
		fields = append(fields, windict.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, windict.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, windict.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WinDictMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case windict.FieldTitle:
		return m.Title()
	case windict.FieldCategory:
		return m.Category()
	case windict.FieldStatus:
		return m.Status()
	case windict.FieldCreatedAt:
		return m.CreatedAt()
	case windict.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WinDictMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case windict.FieldTitle:
		return m.OldTitle(ctx)
	case windict.FieldCategory:
		return m.OldCategory(ctx)
	case windict.FieldStatus:
		return m.OldStatus(ctx)
	case windict.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case windict.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WinDict field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WinDictMutation) SetField(name string, value ent.Value) error {
	switch name {
	case windict.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case windict.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case windict.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case windict.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case windict.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WinDict field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WinDictMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, windict.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, windict.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WinDictMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case windict.FieldCreatedAt:
		return m.AddedCreatedAt()
	case windict.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WinDictMutation) AddField(name string, value ent.Value) error {
	switch name {
	case windict.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case windict.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WinDict numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WinDictMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WinDictMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WinDictMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WinDict nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WinDictMutation) ResetField(name string) error {
	switch name {
	case windict.FieldTitle:
		m.ResetTitle()
		return nil
	case windict.FieldCategory:
		m.ResetCategory()
		return nil
	case windict.FieldStatus:
		m.ResetStatus()
		return nil
	case windict.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case windict.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown WinDict field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WinDictMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WinDictMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WinDictMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WinDictMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WinDictMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WinDictMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WinDictMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WinDict unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WinDictMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WinDict edge %s", name)
}

// WinDictItemMutation represents an operation that mutates the WinDictItem nodes in the graph.
type WinDictItemMutation struct {
	config
	op            Op
	typ           string
	id            *int32
	code          *string
	title         *string
	remark        *string
	sort          *int32
	addsort       *int32
	refer_id      *int32
	addrefer_id   *int32
	status        *bool
	is_show       *int8
	addis_show    *int8
	created_at    *int32
	addcreated_at *int32
	updated_at    *int32
	addupdated_at *int32
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WinDictItem, error)
	predicates    []predicate.WinDictItem
}

var _ ent.Mutation = (*WinDictItemMutation)(nil)

// windictitemOption allows management of the mutation configuration using functional options.
type windictitemOption func(*WinDictItemMutation)

// newWinDictItemMutation creates new mutation for the WinDictItem entity.
func newWinDictItemMutation(c config, op Op, opts ...windictitemOption) *WinDictItemMutation {
	m := &WinDictItemMutation{
		config:        c,
		op:            op,
		typ:           TypeWinDictItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWinDictItemID sets the ID field of the mutation.
func withWinDictItemID(id int32) windictitemOption {
	return func(m *WinDictItemMutation) {
		var (
			err   error
			once  sync.Once
			value *WinDictItem
		)
		m.oldValue = func(ctx context.Context) (*WinDictItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WinDictItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWinDictItem sets the old WinDictItem of the mutation.
func withWinDictItem(node *WinDictItem) windictitemOption {
	return func(m *WinDictItemMutation) {
		m.oldValue = func(context.Context) (*WinDictItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WinDictItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WinDictItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WinDictItem entities.
func (m *WinDictItemMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WinDictItemMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WinDictItemMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WinDictItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *WinDictItemMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *WinDictItemMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the WinDictItem entity.
// If the WinDictItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinDictItemMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *WinDictItemMutation) ResetCode() {
	m.code = nil
}

// SetTitle sets the "title" field.
func (m *WinDictItemMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *WinDictItemMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the WinDictItem entity.
// If the WinDictItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinDictItemMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *WinDictItemMutation) ResetTitle() {
	m.title = nil
}

// SetRemark sets the "remark" field.
func (m *WinDictItemMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *WinDictItemMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the WinDictItem entity.
// If the WinDictItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinDictItemMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *WinDictItemMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[windictitem.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *WinDictItemMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[windictitem.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *WinDictItemMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, windictitem.FieldRemark)
}

// SetSort sets the "sort" field.
func (m *WinDictItemMutation) SetSort(i int32) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *WinDictItemMutation) Sort() (r int32, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the WinDictItem entity.
// If the WinDictItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinDictItemMutation) OldSort(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *WinDictItemMutation) AddSort(i int32) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *WinDictItemMutation) AddedSort() (r int32, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *WinDictItemMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetReferID sets the "refer_id" field.
func (m *WinDictItemMutation) SetReferID(i int32) {
	m.refer_id = &i
	m.addrefer_id = nil
}

// ReferID returns the value of the "refer_id" field in the mutation.
func (m *WinDictItemMutation) ReferID() (r int32, exists bool) {
	v := m.refer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReferID returns the old "refer_id" field's value of the WinDictItem entity.
// If the WinDictItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinDictItemMutation) OldReferID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferID: %w", err)
	}
	return oldValue.ReferID, nil
}

// AddReferID adds i to the "refer_id" field.
func (m *WinDictItemMutation) AddReferID(i int32) {
	if m.addrefer_id != nil {
		*m.addrefer_id += i
	} else {
		m.addrefer_id = &i
	}
}

// AddedReferID returns the value that was added to the "refer_id" field in this mutation.
func (m *WinDictItemMutation) AddedReferID() (r int32, exists bool) {
	v := m.addrefer_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetReferID resets all changes to the "refer_id" field.
func (m *WinDictItemMutation) ResetReferID() {
	m.refer_id = nil
	m.addrefer_id = nil
}

// SetStatus sets the "status" field.
func (m *WinDictItemMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *WinDictItemMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the WinDictItem entity.
// If the WinDictItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinDictItemMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *WinDictItemMutation) ResetStatus() {
	m.status = nil
}

// SetIsShow sets the "is_show" field.
func (m *WinDictItemMutation) SetIsShow(i int8) {
	m.is_show = &i
	m.addis_show = nil
}

// IsShow returns the value of the "is_show" field in the mutation.
func (m *WinDictItemMutation) IsShow() (r int8, exists bool) {
	v := m.is_show
	if v == nil {
		return
	}
	return *v, true
}

// OldIsShow returns the old "is_show" field's value of the WinDictItem entity.
// If the WinDictItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinDictItemMutation) OldIsShow(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsShow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsShow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsShow: %w", err)
	}
	return oldValue.IsShow, nil
}

// AddIsShow adds i to the "is_show" field.
func (m *WinDictItemMutation) AddIsShow(i int8) {
	if m.addis_show != nil {
		*m.addis_show += i
	} else {
		m.addis_show = &i
	}
}

// AddedIsShow returns the value that was added to the "is_show" field in this mutation.
func (m *WinDictItemMutation) AddedIsShow() (r int8, exists bool) {
	v := m.addis_show
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsShow resets all changes to the "is_show" field.
func (m *WinDictItemMutation) ResetIsShow() {
	m.is_show = nil
	m.addis_show = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WinDictItemMutation) SetCreatedAt(i int32) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WinDictItemMutation) CreatedAt() (r int32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WinDictItem entity.
// If the WinDictItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinDictItemMutation) OldCreatedAt(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *WinDictItemMutation) AddCreatedAt(i int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *WinDictItemMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WinDictItemMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WinDictItemMutation) SetUpdatedAt(i int32) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WinDictItemMutation) UpdatedAt() (r int32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WinDictItem entity.
// If the WinDictItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinDictItemMutation) OldUpdatedAt(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *WinDictItemMutation) AddUpdatedAt(i int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *WinDictItemMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WinDictItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// Where appends a list predicates to the WinDictItemMutation builder.
func (m *WinDictItemMutation) Where(ps ...predicate.WinDictItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WinDictItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WinDictItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WinDictItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WinDictItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WinDictItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WinDictItem).
func (m *WinDictItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WinDictItemMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.code != nil {
		fields = append(fields, windictitem.FieldCode)
	}
	if m.title != nil {
		fields = append(fields, windictitem.FieldTitle)
	}
	if m.remark != nil {
		fields = append(fields, windictitem.FieldRemark)
	}
	if m.sort != nil {
		fields = append(fields, windictitem.FieldSort)
	}
	if m.refer_id != nil {
		fields = append(fields, windictitem.FieldReferID)
	}
	if m.status != nil {
		fields = append(fields, windictitem.FieldStatus)
	}
	if m.is_show != nil {
		fields = append(fields, windictitem.FieldIsShow)
	}
	if m.created_at != nil {
		fields = append(fields, windictitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, windictitem.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WinDictItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case windictitem.FieldCode:
		return m.Code()
	case windictitem.FieldTitle:
		return m.Title()
	case windictitem.FieldRemark:
		return m.Remark()
	case windictitem.FieldSort:
		return m.Sort()
	case windictitem.FieldReferID:
		return m.ReferID()
	case windictitem.FieldStatus:
		return m.Status()
	case windictitem.FieldIsShow:
		return m.IsShow()
	case windictitem.FieldCreatedAt:
		return m.CreatedAt()
	case windictitem.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WinDictItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case windictitem.FieldCode:
		return m.OldCode(ctx)
	case windictitem.FieldTitle:
		return m.OldTitle(ctx)
	case windictitem.FieldRemark:
		return m.OldRemark(ctx)
	case windictitem.FieldSort:
		return m.OldSort(ctx)
	case windictitem.FieldReferID:
		return m.OldReferID(ctx)
	case windictitem.FieldStatus:
		return m.OldStatus(ctx)
	case windictitem.FieldIsShow:
		return m.OldIsShow(ctx)
	case windictitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case windictitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WinDictItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WinDictItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case windictitem.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case windictitem.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case windictitem.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case windictitem.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case windictitem.FieldReferID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferID(v)
		return nil
	case windictitem.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case windictitem.FieldIsShow:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsShow(v)
		return nil
	case windictitem.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case windictitem.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WinDictItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WinDictItemMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, windictitem.FieldSort)
	}
	if m.addrefer_id != nil {
		fields = append(fields, windictitem.FieldReferID)
	}
	if m.addis_show != nil {
		fields = append(fields, windictitem.FieldIsShow)
	}
	if m.addcreated_at != nil {
		fields = append(fields, windictitem.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, windictitem.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WinDictItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case windictitem.FieldSort:
		return m.AddedSort()
	case windictitem.FieldReferID:
		return m.AddedReferID()
	case windictitem.FieldIsShow:
		return m.AddedIsShow()
	case windictitem.FieldCreatedAt:
		return m.AddedCreatedAt()
	case windictitem.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WinDictItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case windictitem.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case windictitem.FieldReferID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReferID(v)
		return nil
	case windictitem.FieldIsShow:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsShow(v)
		return nil
	case windictitem.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case windictitem.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WinDictItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WinDictItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(windictitem.FieldRemark) {
		fields = append(fields, windictitem.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WinDictItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WinDictItemMutation) ClearField(name string) error {
	switch name {
	case windictitem.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown WinDictItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WinDictItemMutation) ResetField(name string) error {
	switch name {
	case windictitem.FieldCode:
		m.ResetCode()
		return nil
	case windictitem.FieldTitle:
		m.ResetTitle()
		return nil
	case windictitem.FieldRemark:
		m.ResetRemark()
		return nil
	case windictitem.FieldSort:
		m.ResetSort()
		return nil
	case windictitem.FieldReferID:
		m.ResetReferID()
		return nil
	case windictitem.FieldStatus:
		m.ResetStatus()
		return nil
	case windictitem.FieldIsShow:
		m.ResetIsShow()
		return nil
	case windictitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case windictitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown WinDictItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WinDictItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WinDictItemMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WinDictItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WinDictItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WinDictItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WinDictItemMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WinDictItemMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WinDictItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WinDictItemMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WinDictItem edge %s", name)
}

// WinGameListMutation represents an operation that mutates the WinGameList nodes in the graph.
type WinGameListMutation struct {
	config
	op              Op
	typ             string
	id              *int32
	code            *string
	name            *string
	icon            *string
	group_id        *int8
	addgroup_id     *int8
	plat_list_id    *int32
	addplat_list_id *int32
	revenue_rate    *float64
	addrevenue_rate *float64
	maintenance     *string
	game_count      *int32
	addgame_count   *int32
	remark          *string
	sort            *int8
	addsort         *int8
	status          *int8
	addstatus       *int8
	created_at      *int32
	addcreated_at   *int32
	updated_at      *int32
	addupdated_at   *int32
	updated_user    *string
	operator_name   *string
	category        *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*WinGameList, error)
	predicates      []predicate.WinGameList
}

var _ ent.Mutation = (*WinGameListMutation)(nil)

// wingamelistOption allows management of the mutation configuration using functional options.
type wingamelistOption func(*WinGameListMutation)

// newWinGameListMutation creates new mutation for the WinGameList entity.
func newWinGameListMutation(c config, op Op, opts ...wingamelistOption) *WinGameListMutation {
	m := &WinGameListMutation{
		config:        c,
		op:            op,
		typ:           TypeWinGameList,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWinGameListID sets the ID field of the mutation.
func withWinGameListID(id int32) wingamelistOption {
	return func(m *WinGameListMutation) {
		var (
			err   error
			once  sync.Once
			value *WinGameList
		)
		m.oldValue = func(ctx context.Context) (*WinGameList, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WinGameList.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWinGameList sets the old WinGameList of the mutation.
func withWinGameList(node *WinGameList) wingamelistOption {
	return func(m *WinGameListMutation) {
		m.oldValue = func(context.Context) (*WinGameList, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WinGameListMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WinGameListMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WinGameList entities.
func (m *WinGameListMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WinGameListMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WinGameListMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WinGameList.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *WinGameListMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *WinGameListMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the WinGameList entity.
// If the WinGameList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameListMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *WinGameListMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *WinGameListMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WinGameListMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the WinGameList entity.
// If the WinGameList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameListMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WinGameListMutation) ResetName() {
	m.name = nil
}

// SetIcon sets the "icon" field.
func (m *WinGameListMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *WinGameListMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the WinGameList entity.
// If the WinGameList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameListMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ResetIcon resets all changes to the "icon" field.
func (m *WinGameListMutation) ResetIcon() {
	m.icon = nil
}

// SetGroupID sets the "group_id" field.
func (m *WinGameListMutation) SetGroupID(i int8) {
	m.group_id = &i
	m.addgroup_id = nil
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *WinGameListMutation) GroupID() (r int8, exists bool) {
	v := m.group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the WinGameList entity.
// If the WinGameList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameListMutation) OldGroupID(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// AddGroupID adds i to the "group_id" field.
func (m *WinGameListMutation) AddGroupID(i int8) {
	if m.addgroup_id != nil {
		*m.addgroup_id += i
	} else {
		m.addgroup_id = &i
	}
}

// AddedGroupID returns the value that was added to the "group_id" field in this mutation.
func (m *WinGameListMutation) AddedGroupID() (r int8, exists bool) {
	v := m.addgroup_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *WinGameListMutation) ResetGroupID() {
	m.group_id = nil
	m.addgroup_id = nil
}

// SetPlatListID sets the "plat_list_id" field.
func (m *WinGameListMutation) SetPlatListID(i int32) {
	m.plat_list_id = &i
	m.addplat_list_id = nil
}

// PlatListID returns the value of the "plat_list_id" field in the mutation.
func (m *WinGameListMutation) PlatListID() (r int32, exists bool) {
	v := m.plat_list_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatListID returns the old "plat_list_id" field's value of the WinGameList entity.
// If the WinGameList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameListMutation) OldPlatListID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatListID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatListID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatListID: %w", err)
	}
	return oldValue.PlatListID, nil
}

// AddPlatListID adds i to the "plat_list_id" field.
func (m *WinGameListMutation) AddPlatListID(i int32) {
	if m.addplat_list_id != nil {
		*m.addplat_list_id += i
	} else {
		m.addplat_list_id = &i
	}
}

// AddedPlatListID returns the value that was added to the "plat_list_id" field in this mutation.
func (m *WinGameListMutation) AddedPlatListID() (r int32, exists bool) {
	v := m.addplat_list_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPlatListID resets all changes to the "plat_list_id" field.
func (m *WinGameListMutation) ResetPlatListID() {
	m.plat_list_id = nil
	m.addplat_list_id = nil
}

// SetRevenueRate sets the "revenue_rate" field.
func (m *WinGameListMutation) SetRevenueRate(f float64) {
	m.revenue_rate = &f
	m.addrevenue_rate = nil
}

// RevenueRate returns the value of the "revenue_rate" field in the mutation.
func (m *WinGameListMutation) RevenueRate() (r float64, exists bool) {
	v := m.revenue_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldRevenueRate returns the old "revenue_rate" field's value of the WinGameList entity.
// If the WinGameList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameListMutation) OldRevenueRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevenueRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevenueRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevenueRate: %w", err)
	}
	return oldValue.RevenueRate, nil
}

// AddRevenueRate adds f to the "revenue_rate" field.
func (m *WinGameListMutation) AddRevenueRate(f float64) {
	if m.addrevenue_rate != nil {
		*m.addrevenue_rate += f
	} else {
		m.addrevenue_rate = &f
	}
}

// AddedRevenueRate returns the value that was added to the "revenue_rate" field in this mutation.
func (m *WinGameListMutation) AddedRevenueRate() (r float64, exists bool) {
	v := m.addrevenue_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetRevenueRate resets all changes to the "revenue_rate" field.
func (m *WinGameListMutation) ResetRevenueRate() {
	m.revenue_rate = nil
	m.addrevenue_rate = nil
}

// SetMaintenance sets the "maintenance" field.
func (m *WinGameListMutation) SetMaintenance(s string) {
	m.maintenance = &s
}

// Maintenance returns the value of the "maintenance" field in the mutation.
func (m *WinGameListMutation) Maintenance() (r string, exists bool) {
	v := m.maintenance
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintenance returns the old "maintenance" field's value of the WinGameList entity.
// If the WinGameList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameListMutation) OldMaintenance(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintenance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintenance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintenance: %w", err)
	}
	return oldValue.Maintenance, nil
}

// ClearMaintenance clears the value of the "maintenance" field.
func (m *WinGameListMutation) ClearMaintenance() {
	m.maintenance = nil
	m.clearedFields[wingamelist.FieldMaintenance] = struct{}{}
}

// MaintenanceCleared returns if the "maintenance" field was cleared in this mutation.
func (m *WinGameListMutation) MaintenanceCleared() bool {
	_, ok := m.clearedFields[wingamelist.FieldMaintenance]
	return ok
}

// ResetMaintenance resets all changes to the "maintenance" field.
func (m *WinGameListMutation) ResetMaintenance() {
	m.maintenance = nil
	delete(m.clearedFields, wingamelist.FieldMaintenance)
}

// SetGameCount sets the "game_count" field.
func (m *WinGameListMutation) SetGameCount(i int32) {
	m.game_count = &i
	m.addgame_count = nil
}

// GameCount returns the value of the "game_count" field in the mutation.
func (m *WinGameListMutation) GameCount() (r int32, exists bool) {
	v := m.game_count
	if v == nil {
		return
	}
	return *v, true
}

// OldGameCount returns the old "game_count" field's value of the WinGameList entity.
// If the WinGameList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameListMutation) OldGameCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGameCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGameCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGameCount: %w", err)
	}
	return oldValue.GameCount, nil
}

// AddGameCount adds i to the "game_count" field.
func (m *WinGameListMutation) AddGameCount(i int32) {
	if m.addgame_count != nil {
		*m.addgame_count += i
	} else {
		m.addgame_count = &i
	}
}

// AddedGameCount returns the value that was added to the "game_count" field in this mutation.
func (m *WinGameListMutation) AddedGameCount() (r int32, exists bool) {
	v := m.addgame_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearGameCount clears the value of the "game_count" field.
func (m *WinGameListMutation) ClearGameCount() {
	m.game_count = nil
	m.addgame_count = nil
	m.clearedFields[wingamelist.FieldGameCount] = struct{}{}
}

// GameCountCleared returns if the "game_count" field was cleared in this mutation.
func (m *WinGameListMutation) GameCountCleared() bool {
	_, ok := m.clearedFields[wingamelist.FieldGameCount]
	return ok
}

// ResetGameCount resets all changes to the "game_count" field.
func (m *WinGameListMutation) ResetGameCount() {
	m.game_count = nil
	m.addgame_count = nil
	delete(m.clearedFields, wingamelist.FieldGameCount)
}

// SetRemark sets the "remark" field.
func (m *WinGameListMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *WinGameListMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the WinGameList entity.
// If the WinGameList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameListMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *WinGameListMutation) ResetRemark() {
	m.remark = nil
}

// SetSort sets the "sort" field.
func (m *WinGameListMutation) SetSort(i int8) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *WinGameListMutation) Sort() (r int8, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the WinGameList entity.
// If the WinGameList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameListMutation) OldSort(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *WinGameListMutation) AddSort(i int8) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *WinGameListMutation) AddedSort() (r int8, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *WinGameListMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetStatus sets the "status" field.
func (m *WinGameListMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *WinGameListMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the WinGameList entity.
// If the WinGameList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameListMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *WinGameListMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *WinGameListMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *WinGameListMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WinGameListMutation) SetCreatedAt(i int32) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WinGameListMutation) CreatedAt() (r int32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WinGameList entity.
// If the WinGameList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameListMutation) OldCreatedAt(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *WinGameListMutation) AddCreatedAt(i int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *WinGameListMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WinGameListMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WinGameListMutation) SetUpdatedAt(i int32) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WinGameListMutation) UpdatedAt() (r int32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WinGameList entity.
// If the WinGameList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameListMutation) OldUpdatedAt(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *WinGameListMutation) AddUpdatedAt(i int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *WinGameListMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WinGameListMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedUser sets the "updated_user" field.
func (m *WinGameListMutation) SetUpdatedUser(s string) {
	m.updated_user = &s
}

// UpdatedUser returns the value of the "updated_user" field in the mutation.
func (m *WinGameListMutation) UpdatedUser() (r string, exists bool) {
	v := m.updated_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedUser returns the old "updated_user" field's value of the WinGameList entity.
// If the WinGameList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameListMutation) OldUpdatedUser(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedUser: %w", err)
	}
	return oldValue.UpdatedUser, nil
}

// ClearUpdatedUser clears the value of the "updated_user" field.
func (m *WinGameListMutation) ClearUpdatedUser() {
	m.updated_user = nil
	m.clearedFields[wingamelist.FieldUpdatedUser] = struct{}{}
}

// UpdatedUserCleared returns if the "updated_user" field was cleared in this mutation.
func (m *WinGameListMutation) UpdatedUserCleared() bool {
	_, ok := m.clearedFields[wingamelist.FieldUpdatedUser]
	return ok
}

// ResetUpdatedUser resets all changes to the "updated_user" field.
func (m *WinGameListMutation) ResetUpdatedUser() {
	m.updated_user = nil
	delete(m.clearedFields, wingamelist.FieldUpdatedUser)
}

// SetOperatorName sets the "operator_name" field.
func (m *WinGameListMutation) SetOperatorName(s string) {
	m.operator_name = &s
}

// OperatorName returns the value of the "operator_name" field in the mutation.
func (m *WinGameListMutation) OperatorName() (r string, exists bool) {
	v := m.operator_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorName returns the old "operator_name" field's value of the WinGameList entity.
// If the WinGameList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameListMutation) OldOperatorName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorName: %w", err)
	}
	return oldValue.OperatorName, nil
}

// ClearOperatorName clears the value of the "operator_name" field.
func (m *WinGameListMutation) ClearOperatorName() {
	m.operator_name = nil
	m.clearedFields[wingamelist.FieldOperatorName] = struct{}{}
}

// OperatorNameCleared returns if the "operator_name" field was cleared in this mutation.
func (m *WinGameListMutation) OperatorNameCleared() bool {
	_, ok := m.clearedFields[wingamelist.FieldOperatorName]
	return ok
}

// ResetOperatorName resets all changes to the "operator_name" field.
func (m *WinGameListMutation) ResetOperatorName() {
	m.operator_name = nil
	delete(m.clearedFields, wingamelist.FieldOperatorName)
}

// SetCategory sets the "category" field.
func (m *WinGameListMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *WinGameListMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the WinGameList entity.
// If the WinGameList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameListMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *WinGameListMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[wingamelist.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *WinGameListMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[wingamelist.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *WinGameListMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, wingamelist.FieldCategory)
}

// Where appends a list predicates to the WinGameListMutation builder.
func (m *WinGameListMutation) Where(ps ...predicate.WinGameList) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WinGameListMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WinGameListMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WinGameList, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WinGameListMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WinGameListMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WinGameList).
func (m *WinGameListMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WinGameListMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.code != nil {
		fields = append(fields, wingamelist.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, wingamelist.FieldName)
	}
	if m.icon != nil {
		fields = append(fields, wingamelist.FieldIcon)
	}
	if m.group_id != nil {
		fields = append(fields, wingamelist.FieldGroupID)
	}
	if m.plat_list_id != nil {
		fields = append(fields, wingamelist.FieldPlatListID)
	}
	if m.revenue_rate != nil {
		fields = append(fields, wingamelist.FieldRevenueRate)
	}
	if m.maintenance != nil {
		fields = append(fields, wingamelist.FieldMaintenance)
	}
	if m.game_count != nil {
		fields = append(fields, wingamelist.FieldGameCount)
	}
	if m.remark != nil {
		fields = append(fields, wingamelist.FieldRemark)
	}
	if m.sort != nil {
		fields = append(fields, wingamelist.FieldSort)
	}
	if m.status != nil {
		fields = append(fields, wingamelist.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, wingamelist.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, wingamelist.FieldUpdatedAt)
	}
	if m.updated_user != nil {
		fields = append(fields, wingamelist.FieldUpdatedUser)
	}
	if m.operator_name != nil {
		fields = append(fields, wingamelist.FieldOperatorName)
	}
	if m.category != nil {
		fields = append(fields, wingamelist.FieldCategory)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WinGameListMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wingamelist.FieldCode:
		return m.Code()
	case wingamelist.FieldName:
		return m.Name()
	case wingamelist.FieldIcon:
		return m.Icon()
	case wingamelist.FieldGroupID:
		return m.GroupID()
	case wingamelist.FieldPlatListID:
		return m.PlatListID()
	case wingamelist.FieldRevenueRate:
		return m.RevenueRate()
	case wingamelist.FieldMaintenance:
		return m.Maintenance()
	case wingamelist.FieldGameCount:
		return m.GameCount()
	case wingamelist.FieldRemark:
		return m.Remark()
	case wingamelist.FieldSort:
		return m.Sort()
	case wingamelist.FieldStatus:
		return m.Status()
	case wingamelist.FieldCreatedAt:
		return m.CreatedAt()
	case wingamelist.FieldUpdatedAt:
		return m.UpdatedAt()
	case wingamelist.FieldUpdatedUser:
		return m.UpdatedUser()
	case wingamelist.FieldOperatorName:
		return m.OperatorName()
	case wingamelist.FieldCategory:
		return m.Category()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WinGameListMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wingamelist.FieldCode:
		return m.OldCode(ctx)
	case wingamelist.FieldName:
		return m.OldName(ctx)
	case wingamelist.FieldIcon:
		return m.OldIcon(ctx)
	case wingamelist.FieldGroupID:
		return m.OldGroupID(ctx)
	case wingamelist.FieldPlatListID:
		return m.OldPlatListID(ctx)
	case wingamelist.FieldRevenueRate:
		return m.OldRevenueRate(ctx)
	case wingamelist.FieldMaintenance:
		return m.OldMaintenance(ctx)
	case wingamelist.FieldGameCount:
		return m.OldGameCount(ctx)
	case wingamelist.FieldRemark:
		return m.OldRemark(ctx)
	case wingamelist.FieldSort:
		return m.OldSort(ctx)
	case wingamelist.FieldStatus:
		return m.OldStatus(ctx)
	case wingamelist.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case wingamelist.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case wingamelist.FieldUpdatedUser:
		return m.OldUpdatedUser(ctx)
	case wingamelist.FieldOperatorName:
		return m.OldOperatorName(ctx)
	case wingamelist.FieldCategory:
		return m.OldCategory(ctx)
	}
	return nil, fmt.Errorf("unknown WinGameList field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WinGameListMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wingamelist.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case wingamelist.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case wingamelist.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case wingamelist.FieldGroupID:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case wingamelist.FieldPlatListID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatListID(v)
		return nil
	case wingamelist.FieldRevenueRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevenueRate(v)
		return nil
	case wingamelist.FieldMaintenance:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintenance(v)
		return nil
	case wingamelist.FieldGameCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGameCount(v)
		return nil
	case wingamelist.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case wingamelist.FieldSort:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case wingamelist.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case wingamelist.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case wingamelist.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case wingamelist.FieldUpdatedUser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedUser(v)
		return nil
	case wingamelist.FieldOperatorName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorName(v)
		return nil
	case wingamelist.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	}
	return fmt.Errorf("unknown WinGameList field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WinGameListMutation) AddedFields() []string {
	var fields []string
	if m.addgroup_id != nil {
		fields = append(fields, wingamelist.FieldGroupID)
	}
	if m.addplat_list_id != nil {
		fields = append(fields, wingamelist.FieldPlatListID)
	}
	if m.addrevenue_rate != nil {
		fields = append(fields, wingamelist.FieldRevenueRate)
	}
	if m.addgame_count != nil {
		fields = append(fields, wingamelist.FieldGameCount)
	}
	if m.addsort != nil {
		fields = append(fields, wingamelist.FieldSort)
	}
	if m.addstatus != nil {
		fields = append(fields, wingamelist.FieldStatus)
	}
	if m.addcreated_at != nil {
		fields = append(fields, wingamelist.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, wingamelist.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WinGameListMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case wingamelist.FieldGroupID:
		return m.AddedGroupID()
	case wingamelist.FieldPlatListID:
		return m.AddedPlatListID()
	case wingamelist.FieldRevenueRate:
		return m.AddedRevenueRate()
	case wingamelist.FieldGameCount:
		return m.AddedGameCount()
	case wingamelist.FieldSort:
		return m.AddedSort()
	case wingamelist.FieldStatus:
		return m.AddedStatus()
	case wingamelist.FieldCreatedAt:
		return m.AddedCreatedAt()
	case wingamelist.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WinGameListMutation) AddField(name string, value ent.Value) error {
	switch name {
	case wingamelist.FieldGroupID:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGroupID(v)
		return nil
	case wingamelist.FieldPlatListID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlatListID(v)
		return nil
	case wingamelist.FieldRevenueRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevenueRate(v)
		return nil
	case wingamelist.FieldGameCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGameCount(v)
		return nil
	case wingamelist.FieldSort:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case wingamelist.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case wingamelist.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case wingamelist.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WinGameList numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WinGameListMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(wingamelist.FieldMaintenance) {
		fields = append(fields, wingamelist.FieldMaintenance)
	}
	if m.FieldCleared(wingamelist.FieldGameCount) {
		fields = append(fields, wingamelist.FieldGameCount)
	}
	if m.FieldCleared(wingamelist.FieldUpdatedUser) {
		fields = append(fields, wingamelist.FieldUpdatedUser)
	}
	if m.FieldCleared(wingamelist.FieldOperatorName) {
		fields = append(fields, wingamelist.FieldOperatorName)
	}
	if m.FieldCleared(wingamelist.FieldCategory) {
		fields = append(fields, wingamelist.FieldCategory)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WinGameListMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WinGameListMutation) ClearField(name string) error {
	switch name {
	case wingamelist.FieldMaintenance:
		m.ClearMaintenance()
		return nil
	case wingamelist.FieldGameCount:
		m.ClearGameCount()
		return nil
	case wingamelist.FieldUpdatedUser:
		m.ClearUpdatedUser()
		return nil
	case wingamelist.FieldOperatorName:
		m.ClearOperatorName()
		return nil
	case wingamelist.FieldCategory:
		m.ClearCategory()
		return nil
	}
	return fmt.Errorf("unknown WinGameList nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WinGameListMutation) ResetField(name string) error {
	switch name {
	case wingamelist.FieldCode:
		m.ResetCode()
		return nil
	case wingamelist.FieldName:
		m.ResetName()
		return nil
	case wingamelist.FieldIcon:
		m.ResetIcon()
		return nil
	case wingamelist.FieldGroupID:
		m.ResetGroupID()
		return nil
	case wingamelist.FieldPlatListID:
		m.ResetPlatListID()
		return nil
	case wingamelist.FieldRevenueRate:
		m.ResetRevenueRate()
		return nil
	case wingamelist.FieldMaintenance:
		m.ResetMaintenance()
		return nil
	case wingamelist.FieldGameCount:
		m.ResetGameCount()
		return nil
	case wingamelist.FieldRemark:
		m.ResetRemark()
		return nil
	case wingamelist.FieldSort:
		m.ResetSort()
		return nil
	case wingamelist.FieldStatus:
		m.ResetStatus()
		return nil
	case wingamelist.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case wingamelist.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case wingamelist.FieldUpdatedUser:
		m.ResetUpdatedUser()
		return nil
	case wingamelist.FieldOperatorName:
		m.ResetOperatorName()
		return nil
	case wingamelist.FieldCategory:
		m.ResetCategory()
		return nil
	}
	return fmt.Errorf("unknown WinGameList field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WinGameListMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WinGameListMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WinGameListMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WinGameListMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WinGameListMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WinGameListMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WinGameListMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WinGameList unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WinGameListMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WinGameList edge %s", name)
}

// WinGameSlotMutation represents an operation that mutates the WinGameSlot nodes in the graph.
type WinGameSlotMutation struct {
	config
	op               Op
	typ              string
	id               *string
	game_id          *int32
	addgame_id       *int32
	game_group_id    *int8
	addgame_group_id *int8
	plat_id          *int32
	addplat_id       *int32
	provider         *string
	name             *string
	name_zh          *string
	img              *string
	img_new          *string
	is_new           *bool
	is_casino        *int8
	addis_casino     *int8
	game_type_id     *string
	game_type_name   *string
	favorite_star    *int32
	addfavorite_star *int32
	hot_star         *int32
	addhot_star      *int32
	sort             *int32
	addsort          *int32
	status           *int8
	addstatus        *int8
	device           *int8
	adddevice        *int8
	created_at       *int32
	addcreated_at    *int32
	updated_at       *int32
	addupdated_at    *int32
	updated_user     *string
	maintenance      *string
	operator_name    *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*WinGameSlot, error)
	predicates       []predicate.WinGameSlot
}

var _ ent.Mutation = (*WinGameSlotMutation)(nil)

// wingameslotOption allows management of the mutation configuration using functional options.
type wingameslotOption func(*WinGameSlotMutation)

// newWinGameSlotMutation creates new mutation for the WinGameSlot entity.
func newWinGameSlotMutation(c config, op Op, opts ...wingameslotOption) *WinGameSlotMutation {
	m := &WinGameSlotMutation{
		config:        c,
		op:            op,
		typ:           TypeWinGameSlot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWinGameSlotID sets the ID field of the mutation.
func withWinGameSlotID(id string) wingameslotOption {
	return func(m *WinGameSlotMutation) {
		var (
			err   error
			once  sync.Once
			value *WinGameSlot
		)
		m.oldValue = func(ctx context.Context) (*WinGameSlot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WinGameSlot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWinGameSlot sets the old WinGameSlot of the mutation.
func withWinGameSlot(node *WinGameSlot) wingameslotOption {
	return func(m *WinGameSlotMutation) {
		m.oldValue = func(context.Context) (*WinGameSlot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WinGameSlotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WinGameSlotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WinGameSlot entities.
func (m *WinGameSlotMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WinGameSlotMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WinGameSlotMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WinGameSlot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGameID sets the "game_id" field.
func (m *WinGameSlotMutation) SetGameID(i int32) {
	m.game_id = &i
	m.addgame_id = nil
}

// GameID returns the value of the "game_id" field in the mutation.
func (m *WinGameSlotMutation) GameID() (r int32, exists bool) {
	v := m.game_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGameID returns the old "game_id" field's value of the WinGameSlot entity.
// If the WinGameSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameSlotMutation) OldGameID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGameID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGameID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGameID: %w", err)
	}
	return oldValue.GameID, nil
}

// AddGameID adds i to the "game_id" field.
func (m *WinGameSlotMutation) AddGameID(i int32) {
	if m.addgame_id != nil {
		*m.addgame_id += i
	} else {
		m.addgame_id = &i
	}
}

// AddedGameID returns the value that was added to the "game_id" field in this mutation.
func (m *WinGameSlotMutation) AddedGameID() (r int32, exists bool) {
	v := m.addgame_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetGameID resets all changes to the "game_id" field.
func (m *WinGameSlotMutation) ResetGameID() {
	m.game_id = nil
	m.addgame_id = nil
}

// SetGameGroupID sets the "game_group_id" field.
func (m *WinGameSlotMutation) SetGameGroupID(i int8) {
	m.game_group_id = &i
	m.addgame_group_id = nil
}

// GameGroupID returns the value of the "game_group_id" field in the mutation.
func (m *WinGameSlotMutation) GameGroupID() (r int8, exists bool) {
	v := m.game_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGameGroupID returns the old "game_group_id" field's value of the WinGameSlot entity.
// If the WinGameSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameSlotMutation) OldGameGroupID(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGameGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGameGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGameGroupID: %w", err)
	}
	return oldValue.GameGroupID, nil
}

// AddGameGroupID adds i to the "game_group_id" field.
func (m *WinGameSlotMutation) AddGameGroupID(i int8) {
	if m.addgame_group_id != nil {
		*m.addgame_group_id += i
	} else {
		m.addgame_group_id = &i
	}
}

// AddedGameGroupID returns the value that was added to the "game_group_id" field in this mutation.
func (m *WinGameSlotMutation) AddedGameGroupID() (r int8, exists bool) {
	v := m.addgame_group_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetGameGroupID resets all changes to the "game_group_id" field.
func (m *WinGameSlotMutation) ResetGameGroupID() {
	m.game_group_id = nil
	m.addgame_group_id = nil
}

// SetPlatID sets the "plat_id" field.
func (m *WinGameSlotMutation) SetPlatID(i int32) {
	m.plat_id = &i
	m.addplat_id = nil
}

// PlatID returns the value of the "plat_id" field in the mutation.
func (m *WinGameSlotMutation) PlatID() (r int32, exists bool) {
	v := m.plat_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatID returns the old "plat_id" field's value of the WinGameSlot entity.
// If the WinGameSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameSlotMutation) OldPlatID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatID: %w", err)
	}
	return oldValue.PlatID, nil
}

// AddPlatID adds i to the "plat_id" field.
func (m *WinGameSlotMutation) AddPlatID(i int32) {
	if m.addplat_id != nil {
		*m.addplat_id += i
	} else {
		m.addplat_id = &i
	}
}

// AddedPlatID returns the value that was added to the "plat_id" field in this mutation.
func (m *WinGameSlotMutation) AddedPlatID() (r int32, exists bool) {
	v := m.addplat_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPlatID resets all changes to the "plat_id" field.
func (m *WinGameSlotMutation) ResetPlatID() {
	m.plat_id = nil
	m.addplat_id = nil
}

// SetProvider sets the "provider" field.
func (m *WinGameSlotMutation) SetProvider(s string) {
	m.provider = &s
}

// Provider returns the value of the "provider" field in the mutation.
func (m *WinGameSlotMutation) Provider() (r string, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the WinGameSlot entity.
// If the WinGameSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameSlotMutation) OldProvider(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ClearProvider clears the value of the "provider" field.
func (m *WinGameSlotMutation) ClearProvider() {
	m.provider = nil
	m.clearedFields[wingameslot.FieldProvider] = struct{}{}
}

// ProviderCleared returns if the "provider" field was cleared in this mutation.
func (m *WinGameSlotMutation) ProviderCleared() bool {
	_, ok := m.clearedFields[wingameslot.FieldProvider]
	return ok
}

// ResetProvider resets all changes to the "provider" field.
func (m *WinGameSlotMutation) ResetProvider() {
	m.provider = nil
	delete(m.clearedFields, wingameslot.FieldProvider)
}

// SetName sets the "name" field.
func (m *WinGameSlotMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WinGameSlotMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the WinGameSlot entity.
// If the WinGameSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameSlotMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WinGameSlotMutation) ResetName() {
	m.name = nil
}

// SetNameZh sets the "name_zh" field.
func (m *WinGameSlotMutation) SetNameZh(s string) {
	m.name_zh = &s
}

// NameZh returns the value of the "name_zh" field in the mutation.
func (m *WinGameSlotMutation) NameZh() (r string, exists bool) {
	v := m.name_zh
	if v == nil {
		return
	}
	return *v, true
}

// OldNameZh returns the old "name_zh" field's value of the WinGameSlot entity.
// If the WinGameSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameSlotMutation) OldNameZh(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameZh is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameZh requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameZh: %w", err)
	}
	return oldValue.NameZh, nil
}

// ResetNameZh resets all changes to the "name_zh" field.
func (m *WinGameSlotMutation) ResetNameZh() {
	m.name_zh = nil
}

// SetImg sets the "img" field.
func (m *WinGameSlotMutation) SetImg(s string) {
	m.img = &s
}

// Img returns the value of the "img" field in the mutation.
func (m *WinGameSlotMutation) Img() (r string, exists bool) {
	v := m.img
	if v == nil {
		return
	}
	return *v, true
}

// OldImg returns the old "img" field's value of the WinGameSlot entity.
// If the WinGameSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameSlotMutation) OldImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImg: %w", err)
	}
	return oldValue.Img, nil
}

// ResetImg resets all changes to the "img" field.
func (m *WinGameSlotMutation) ResetImg() {
	m.img = nil
}

// SetImgNew sets the "img_new" field.
func (m *WinGameSlotMutation) SetImgNew(s string) {
	m.img_new = &s
}

// ImgNew returns the value of the "img_new" field in the mutation.
func (m *WinGameSlotMutation) ImgNew() (r string, exists bool) {
	v := m.img_new
	if v == nil {
		return
	}
	return *v, true
}

// OldImgNew returns the old "img_new" field's value of the WinGameSlot entity.
// If the WinGameSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameSlotMutation) OldImgNew(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImgNew is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImgNew requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImgNew: %w", err)
	}
	return oldValue.ImgNew, nil
}

// ClearImgNew clears the value of the "img_new" field.
func (m *WinGameSlotMutation) ClearImgNew() {
	m.img_new = nil
	m.clearedFields[wingameslot.FieldImgNew] = struct{}{}
}

// ImgNewCleared returns if the "img_new" field was cleared in this mutation.
func (m *WinGameSlotMutation) ImgNewCleared() bool {
	_, ok := m.clearedFields[wingameslot.FieldImgNew]
	return ok
}

// ResetImgNew resets all changes to the "img_new" field.
func (m *WinGameSlotMutation) ResetImgNew() {
	m.img_new = nil
	delete(m.clearedFields, wingameslot.FieldImgNew)
}

// SetIsNew sets the "is_new" field.
func (m *WinGameSlotMutation) SetIsNew(b bool) {
	m.is_new = &b
}

// IsNew returns the value of the "is_new" field in the mutation.
func (m *WinGameSlotMutation) IsNew() (r bool, exists bool) {
	v := m.is_new
	if v == nil {
		return
	}
	return *v, true
}

// OldIsNew returns the old "is_new" field's value of the WinGameSlot entity.
// If the WinGameSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameSlotMutation) OldIsNew(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsNew is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsNew requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsNew: %w", err)
	}
	return oldValue.IsNew, nil
}

// ResetIsNew resets all changes to the "is_new" field.
func (m *WinGameSlotMutation) ResetIsNew() {
	m.is_new = nil
}

// SetIsCasino sets the "is_casino" field.
func (m *WinGameSlotMutation) SetIsCasino(i int8) {
	m.is_casino = &i
	m.addis_casino = nil
}

// IsCasino returns the value of the "is_casino" field in the mutation.
func (m *WinGameSlotMutation) IsCasino() (r int8, exists bool) {
	v := m.is_casino
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCasino returns the old "is_casino" field's value of the WinGameSlot entity.
// If the WinGameSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameSlotMutation) OldIsCasino(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCasino is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCasino requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCasino: %w", err)
	}
	return oldValue.IsCasino, nil
}

// AddIsCasino adds i to the "is_casino" field.
func (m *WinGameSlotMutation) AddIsCasino(i int8) {
	if m.addis_casino != nil {
		*m.addis_casino += i
	} else {
		m.addis_casino = &i
	}
}

// AddedIsCasino returns the value that was added to the "is_casino" field in this mutation.
func (m *WinGameSlotMutation) AddedIsCasino() (r int8, exists bool) {
	v := m.addis_casino
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsCasino resets all changes to the "is_casino" field.
func (m *WinGameSlotMutation) ResetIsCasino() {
	m.is_casino = nil
	m.addis_casino = nil
}

// SetGameTypeID sets the "game_type_id" field.
func (m *WinGameSlotMutation) SetGameTypeID(s string) {
	m.game_type_id = &s
}

// GameTypeID returns the value of the "game_type_id" field in the mutation.
func (m *WinGameSlotMutation) GameTypeID() (r string, exists bool) {
	v := m.game_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGameTypeID returns the old "game_type_id" field's value of the WinGameSlot entity.
// If the WinGameSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameSlotMutation) OldGameTypeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGameTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGameTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGameTypeID: %w", err)
	}
	return oldValue.GameTypeID, nil
}

// ClearGameTypeID clears the value of the "game_type_id" field.
func (m *WinGameSlotMutation) ClearGameTypeID() {
	m.game_type_id = nil
	m.clearedFields[wingameslot.FieldGameTypeID] = struct{}{}
}

// GameTypeIDCleared returns if the "game_type_id" field was cleared in this mutation.
func (m *WinGameSlotMutation) GameTypeIDCleared() bool {
	_, ok := m.clearedFields[wingameslot.FieldGameTypeID]
	return ok
}

// ResetGameTypeID resets all changes to the "game_type_id" field.
func (m *WinGameSlotMutation) ResetGameTypeID() {
	m.game_type_id = nil
	delete(m.clearedFields, wingameslot.FieldGameTypeID)
}

// SetGameTypeName sets the "game_type_name" field.
func (m *WinGameSlotMutation) SetGameTypeName(s string) {
	m.game_type_name = &s
}

// GameTypeName returns the value of the "game_type_name" field in the mutation.
func (m *WinGameSlotMutation) GameTypeName() (r string, exists bool) {
	v := m.game_type_name
	if v == nil {
		return
	}
	return *v, true
}

// OldGameTypeName returns the old "game_type_name" field's value of the WinGameSlot entity.
// If the WinGameSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameSlotMutation) OldGameTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGameTypeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGameTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGameTypeName: %w", err)
	}
	return oldValue.GameTypeName, nil
}

// ClearGameTypeName clears the value of the "game_type_name" field.
func (m *WinGameSlotMutation) ClearGameTypeName() {
	m.game_type_name = nil
	m.clearedFields[wingameslot.FieldGameTypeName] = struct{}{}
}

// GameTypeNameCleared returns if the "game_type_name" field was cleared in this mutation.
func (m *WinGameSlotMutation) GameTypeNameCleared() bool {
	_, ok := m.clearedFields[wingameslot.FieldGameTypeName]
	return ok
}

// ResetGameTypeName resets all changes to the "game_type_name" field.
func (m *WinGameSlotMutation) ResetGameTypeName() {
	m.game_type_name = nil
	delete(m.clearedFields, wingameslot.FieldGameTypeName)
}

// SetFavoriteStar sets the "favorite_star" field.
func (m *WinGameSlotMutation) SetFavoriteStar(i int32) {
	m.favorite_star = &i
	m.addfavorite_star = nil
}

// FavoriteStar returns the value of the "favorite_star" field in the mutation.
func (m *WinGameSlotMutation) FavoriteStar() (r int32, exists bool) {
	v := m.favorite_star
	if v == nil {
		return
	}
	return *v, true
}

// OldFavoriteStar returns the old "favorite_star" field's value of the WinGameSlot entity.
// If the WinGameSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameSlotMutation) OldFavoriteStar(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFavoriteStar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFavoriteStar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFavoriteStar: %w", err)
	}
	return oldValue.FavoriteStar, nil
}

// AddFavoriteStar adds i to the "favorite_star" field.
func (m *WinGameSlotMutation) AddFavoriteStar(i int32) {
	if m.addfavorite_star != nil {
		*m.addfavorite_star += i
	} else {
		m.addfavorite_star = &i
	}
}

// AddedFavoriteStar returns the value that was added to the "favorite_star" field in this mutation.
func (m *WinGameSlotMutation) AddedFavoriteStar() (r int32, exists bool) {
	v := m.addfavorite_star
	if v == nil {
		return
	}
	return *v, true
}

// ResetFavoriteStar resets all changes to the "favorite_star" field.
func (m *WinGameSlotMutation) ResetFavoriteStar() {
	m.favorite_star = nil
	m.addfavorite_star = nil
}

// SetHotStar sets the "hot_star" field.
func (m *WinGameSlotMutation) SetHotStar(i int32) {
	m.hot_star = &i
	m.addhot_star = nil
}

// HotStar returns the value of the "hot_star" field in the mutation.
func (m *WinGameSlotMutation) HotStar() (r int32, exists bool) {
	v := m.hot_star
	if v == nil {
		return
	}
	return *v, true
}

// OldHotStar returns the old "hot_star" field's value of the WinGameSlot entity.
// If the WinGameSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameSlotMutation) OldHotStar(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHotStar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHotStar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHotStar: %w", err)
	}
	return oldValue.HotStar, nil
}

// AddHotStar adds i to the "hot_star" field.
func (m *WinGameSlotMutation) AddHotStar(i int32) {
	if m.addhot_star != nil {
		*m.addhot_star += i
	} else {
		m.addhot_star = &i
	}
}

// AddedHotStar returns the value that was added to the "hot_star" field in this mutation.
func (m *WinGameSlotMutation) AddedHotStar() (r int32, exists bool) {
	v := m.addhot_star
	if v == nil {
		return
	}
	return *v, true
}

// ResetHotStar resets all changes to the "hot_star" field.
func (m *WinGameSlotMutation) ResetHotStar() {
	m.hot_star = nil
	m.addhot_star = nil
}

// SetSort sets the "sort" field.
func (m *WinGameSlotMutation) SetSort(i int32) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *WinGameSlotMutation) Sort() (r int32, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the WinGameSlot entity.
// If the WinGameSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameSlotMutation) OldSort(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *WinGameSlotMutation) AddSort(i int32) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *WinGameSlotMutation) AddedSort() (r int32, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *WinGameSlotMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetStatus sets the "status" field.
func (m *WinGameSlotMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *WinGameSlotMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the WinGameSlot entity.
// If the WinGameSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameSlotMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *WinGameSlotMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *WinGameSlotMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *WinGameSlotMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetDevice sets the "device" field.
func (m *WinGameSlotMutation) SetDevice(i int8) {
	m.device = &i
	m.adddevice = nil
}

// Device returns the value of the "device" field in the mutation.
func (m *WinGameSlotMutation) Device() (r int8, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDevice returns the old "device" field's value of the WinGameSlot entity.
// If the WinGameSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameSlotMutation) OldDevice(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDevice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDevice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDevice: %w", err)
	}
	return oldValue.Device, nil
}

// AddDevice adds i to the "device" field.
func (m *WinGameSlotMutation) AddDevice(i int8) {
	if m.adddevice != nil {
		*m.adddevice += i
	} else {
		m.adddevice = &i
	}
}

// AddedDevice returns the value that was added to the "device" field in this mutation.
func (m *WinGameSlotMutation) AddedDevice() (r int8, exists bool) {
	v := m.adddevice
	if v == nil {
		return
	}
	return *v, true
}

// ClearDevice clears the value of the "device" field.
func (m *WinGameSlotMutation) ClearDevice() {
	m.device = nil
	m.adddevice = nil
	m.clearedFields[wingameslot.FieldDevice] = struct{}{}
}

// DeviceCleared returns if the "device" field was cleared in this mutation.
func (m *WinGameSlotMutation) DeviceCleared() bool {
	_, ok := m.clearedFields[wingameslot.FieldDevice]
	return ok
}

// ResetDevice resets all changes to the "device" field.
func (m *WinGameSlotMutation) ResetDevice() {
	m.device = nil
	m.adddevice = nil
	delete(m.clearedFields, wingameslot.FieldDevice)
}

// SetCreatedAt sets the "created_at" field.
func (m *WinGameSlotMutation) SetCreatedAt(i int32) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WinGameSlotMutation) CreatedAt() (r int32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WinGameSlot entity.
// If the WinGameSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameSlotMutation) OldCreatedAt(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *WinGameSlotMutation) AddCreatedAt(i int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *WinGameSlotMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WinGameSlotMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WinGameSlotMutation) SetUpdatedAt(i int32) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WinGameSlotMutation) UpdatedAt() (r int32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WinGameSlot entity.
// If the WinGameSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameSlotMutation) OldUpdatedAt(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *WinGameSlotMutation) AddUpdatedAt(i int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *WinGameSlotMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WinGameSlotMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetUpdatedUser sets the "updated_user" field.
func (m *WinGameSlotMutation) SetUpdatedUser(s string) {
	m.updated_user = &s
}

// UpdatedUser returns the value of the "updated_user" field in the mutation.
func (m *WinGameSlotMutation) UpdatedUser() (r string, exists bool) {
	v := m.updated_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedUser returns the old "updated_user" field's value of the WinGameSlot entity.
// If the WinGameSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameSlotMutation) OldUpdatedUser(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedUser: %w", err)
	}
	return oldValue.UpdatedUser, nil
}

// ClearUpdatedUser clears the value of the "updated_user" field.
func (m *WinGameSlotMutation) ClearUpdatedUser() {
	m.updated_user = nil
	m.clearedFields[wingameslot.FieldUpdatedUser] = struct{}{}
}

// UpdatedUserCleared returns if the "updated_user" field was cleared in this mutation.
func (m *WinGameSlotMutation) UpdatedUserCleared() bool {
	_, ok := m.clearedFields[wingameslot.FieldUpdatedUser]
	return ok
}

// ResetUpdatedUser resets all changes to the "updated_user" field.
func (m *WinGameSlotMutation) ResetUpdatedUser() {
	m.updated_user = nil
	delete(m.clearedFields, wingameslot.FieldUpdatedUser)
}

// SetMaintenance sets the "maintenance" field.
func (m *WinGameSlotMutation) SetMaintenance(s string) {
	m.maintenance = &s
}

// Maintenance returns the value of the "maintenance" field in the mutation.
func (m *WinGameSlotMutation) Maintenance() (r string, exists bool) {
	v := m.maintenance
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintenance returns the old "maintenance" field's value of the WinGameSlot entity.
// If the WinGameSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameSlotMutation) OldMaintenance(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintenance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintenance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintenance: %w", err)
	}
	return oldValue.Maintenance, nil
}

// ClearMaintenance clears the value of the "maintenance" field.
func (m *WinGameSlotMutation) ClearMaintenance() {
	m.maintenance = nil
	m.clearedFields[wingameslot.FieldMaintenance] = struct{}{}
}

// MaintenanceCleared returns if the "maintenance" field was cleared in this mutation.
func (m *WinGameSlotMutation) MaintenanceCleared() bool {
	_, ok := m.clearedFields[wingameslot.FieldMaintenance]
	return ok
}

// ResetMaintenance resets all changes to the "maintenance" field.
func (m *WinGameSlotMutation) ResetMaintenance() {
	m.maintenance = nil
	delete(m.clearedFields, wingameslot.FieldMaintenance)
}

// SetOperatorName sets the "operator_name" field.
func (m *WinGameSlotMutation) SetOperatorName(s string) {
	m.operator_name = &s
}

// OperatorName returns the value of the "operator_name" field in the mutation.
func (m *WinGameSlotMutation) OperatorName() (r string, exists bool) {
	v := m.operator_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorName returns the old "operator_name" field's value of the WinGameSlot entity.
// If the WinGameSlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinGameSlotMutation) OldOperatorName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorName: %w", err)
	}
	return oldValue.OperatorName, nil
}

// ClearOperatorName clears the value of the "operator_name" field.
func (m *WinGameSlotMutation) ClearOperatorName() {
	m.operator_name = nil
	m.clearedFields[wingameslot.FieldOperatorName] = struct{}{}
}

// OperatorNameCleared returns if the "operator_name" field was cleared in this mutation.
func (m *WinGameSlotMutation) OperatorNameCleared() bool {
	_, ok := m.clearedFields[wingameslot.FieldOperatorName]
	return ok
}

// ResetOperatorName resets all changes to the "operator_name" field.
func (m *WinGameSlotMutation) ResetOperatorName() {
	m.operator_name = nil
	delete(m.clearedFields, wingameslot.FieldOperatorName)
}

// Where appends a list predicates to the WinGameSlotMutation builder.
func (m *WinGameSlotMutation) Where(ps ...predicate.WinGameSlot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WinGameSlotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WinGameSlotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WinGameSlot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WinGameSlotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WinGameSlotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WinGameSlot).
func (m *WinGameSlotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WinGameSlotMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.game_id != nil {
		fields = append(fields, wingameslot.FieldGameID)
	}
	if m.game_group_id != nil {
		fields = append(fields, wingameslot.FieldGameGroupID)
	}
	if m.plat_id != nil {
		fields = append(fields, wingameslot.FieldPlatID)
	}
	if m.provider != nil {
		fields = append(fields, wingameslot.FieldProvider)
	}
	if m.name != nil {
		fields = append(fields, wingameslot.FieldName)
	}
	if m.name_zh != nil {
		fields = append(fields, wingameslot.FieldNameZh)
	}
	if m.img != nil {
		fields = append(fields, wingameslot.FieldImg)
	}
	if m.img_new != nil {
		fields = append(fields, wingameslot.FieldImgNew)
	}
	if m.is_new != nil {
		fields = append(fields, wingameslot.FieldIsNew)
	}
	if m.is_casino != nil {
		fields = append(fields, wingameslot.FieldIsCasino)
	}
	if m.game_type_id != nil {
		fields = append(fields, wingameslot.FieldGameTypeID)
	}
	if m.game_type_name != nil {
		fields = append(fields, wingameslot.FieldGameTypeName)
	}
	if m.favorite_star != nil {
		fields = append(fields, wingameslot.FieldFavoriteStar)
	}
	if m.hot_star != nil {
		fields = append(fields, wingameslot.FieldHotStar)
	}
	if m.sort != nil {
		fields = append(fields, wingameslot.FieldSort)
	}
	if m.status != nil {
		fields = append(fields, wingameslot.FieldStatus)
	}
	if m.device != nil {
		fields = append(fields, wingameslot.FieldDevice)
	}
	if m.created_at != nil {
		fields = append(fields, wingameslot.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, wingameslot.FieldUpdatedAt)
	}
	if m.updated_user != nil {
		fields = append(fields, wingameslot.FieldUpdatedUser)
	}
	if m.maintenance != nil {
		fields = append(fields, wingameslot.FieldMaintenance)
	}
	if m.operator_name != nil {
		fields = append(fields, wingameslot.FieldOperatorName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WinGameSlotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wingameslot.FieldGameID:
		return m.GameID()
	case wingameslot.FieldGameGroupID:
		return m.GameGroupID()
	case wingameslot.FieldPlatID:
		return m.PlatID()
	case wingameslot.FieldProvider:
		return m.Provider()
	case wingameslot.FieldName:
		return m.Name()
	case wingameslot.FieldNameZh:
		return m.NameZh()
	case wingameslot.FieldImg:
		return m.Img()
	case wingameslot.FieldImgNew:
		return m.ImgNew()
	case wingameslot.FieldIsNew:
		return m.IsNew()
	case wingameslot.FieldIsCasino:
		return m.IsCasino()
	case wingameslot.FieldGameTypeID:
		return m.GameTypeID()
	case wingameslot.FieldGameTypeName:
		return m.GameTypeName()
	case wingameslot.FieldFavoriteStar:
		return m.FavoriteStar()
	case wingameslot.FieldHotStar:
		return m.HotStar()
	case wingameslot.FieldSort:
		return m.Sort()
	case wingameslot.FieldStatus:
		return m.Status()
	case wingameslot.FieldDevice:
		return m.Device()
	case wingameslot.FieldCreatedAt:
		return m.CreatedAt()
	case wingameslot.FieldUpdatedAt:
		return m.UpdatedAt()
	case wingameslot.FieldUpdatedUser:
		return m.UpdatedUser()
	case wingameslot.FieldMaintenance:
		return m.Maintenance()
	case wingameslot.FieldOperatorName:
		return m.OperatorName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WinGameSlotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wingameslot.FieldGameID:
		return m.OldGameID(ctx)
	case wingameslot.FieldGameGroupID:
		return m.OldGameGroupID(ctx)
	case wingameslot.FieldPlatID:
		return m.OldPlatID(ctx)
	case wingameslot.FieldProvider:
		return m.OldProvider(ctx)
	case wingameslot.FieldName:
		return m.OldName(ctx)
	case wingameslot.FieldNameZh:
		return m.OldNameZh(ctx)
	case wingameslot.FieldImg:
		return m.OldImg(ctx)
	case wingameslot.FieldImgNew:
		return m.OldImgNew(ctx)
	case wingameslot.FieldIsNew:
		return m.OldIsNew(ctx)
	case wingameslot.FieldIsCasino:
		return m.OldIsCasino(ctx)
	case wingameslot.FieldGameTypeID:
		return m.OldGameTypeID(ctx)
	case wingameslot.FieldGameTypeName:
		return m.OldGameTypeName(ctx)
	case wingameslot.FieldFavoriteStar:
		return m.OldFavoriteStar(ctx)
	case wingameslot.FieldHotStar:
		return m.OldHotStar(ctx)
	case wingameslot.FieldSort:
		return m.OldSort(ctx)
	case wingameslot.FieldStatus:
		return m.OldStatus(ctx)
	case wingameslot.FieldDevice:
		return m.OldDevice(ctx)
	case wingameslot.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case wingameslot.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case wingameslot.FieldUpdatedUser:
		return m.OldUpdatedUser(ctx)
	case wingameslot.FieldMaintenance:
		return m.OldMaintenance(ctx)
	case wingameslot.FieldOperatorName:
		return m.OldOperatorName(ctx)
	}
	return nil, fmt.Errorf("unknown WinGameSlot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WinGameSlotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wingameslot.FieldGameID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGameID(v)
		return nil
	case wingameslot.FieldGameGroupID:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGameGroupID(v)
		return nil
	case wingameslot.FieldPlatID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatID(v)
		return nil
	case wingameslot.FieldProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case wingameslot.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case wingameslot.FieldNameZh:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameZh(v)
		return nil
	case wingameslot.FieldImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImg(v)
		return nil
	case wingameslot.FieldImgNew:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImgNew(v)
		return nil
	case wingameslot.FieldIsNew:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsNew(v)
		return nil
	case wingameslot.FieldIsCasino:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCasino(v)
		return nil
	case wingameslot.FieldGameTypeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGameTypeID(v)
		return nil
	case wingameslot.FieldGameTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGameTypeName(v)
		return nil
	case wingameslot.FieldFavoriteStar:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFavoriteStar(v)
		return nil
	case wingameslot.FieldHotStar:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHotStar(v)
		return nil
	case wingameslot.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case wingameslot.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case wingameslot.FieldDevice:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDevice(v)
		return nil
	case wingameslot.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case wingameslot.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case wingameslot.FieldUpdatedUser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedUser(v)
		return nil
	case wingameslot.FieldMaintenance:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintenance(v)
		return nil
	case wingameslot.FieldOperatorName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorName(v)
		return nil
	}
	return fmt.Errorf("unknown WinGameSlot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WinGameSlotMutation) AddedFields() []string {
	var fields []string
	if m.addgame_id != nil {
		fields = append(fields, wingameslot.FieldGameID)
	}
	if m.addgame_group_id != nil {
		fields = append(fields, wingameslot.FieldGameGroupID)
	}
	if m.addplat_id != nil {
		fields = append(fields, wingameslot.FieldPlatID)
	}
	if m.addis_casino != nil {
		fields = append(fields, wingameslot.FieldIsCasino)
	}
	if m.addfavorite_star != nil {
		fields = append(fields, wingameslot.FieldFavoriteStar)
	}
	if m.addhot_star != nil {
		fields = append(fields, wingameslot.FieldHotStar)
	}
	if m.addsort != nil {
		fields = append(fields, wingameslot.FieldSort)
	}
	if m.addstatus != nil {
		fields = append(fields, wingameslot.FieldStatus)
	}
	if m.adddevice != nil {
		fields = append(fields, wingameslot.FieldDevice)
	}
	if m.addcreated_at != nil {
		fields = append(fields, wingameslot.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, wingameslot.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WinGameSlotMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case wingameslot.FieldGameID:
		return m.AddedGameID()
	case wingameslot.FieldGameGroupID:
		return m.AddedGameGroupID()
	case wingameslot.FieldPlatID:
		return m.AddedPlatID()
	case wingameslot.FieldIsCasino:
		return m.AddedIsCasino()
	case wingameslot.FieldFavoriteStar:
		return m.AddedFavoriteStar()
	case wingameslot.FieldHotStar:
		return m.AddedHotStar()
	case wingameslot.FieldSort:
		return m.AddedSort()
	case wingameslot.FieldStatus:
		return m.AddedStatus()
	case wingameslot.FieldDevice:
		return m.AddedDevice()
	case wingameslot.FieldCreatedAt:
		return m.AddedCreatedAt()
	case wingameslot.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WinGameSlotMutation) AddField(name string, value ent.Value) error {
	switch name {
	case wingameslot.FieldGameID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGameID(v)
		return nil
	case wingameslot.FieldGameGroupID:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGameGroupID(v)
		return nil
	case wingameslot.FieldPlatID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlatID(v)
		return nil
	case wingameslot.FieldIsCasino:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsCasino(v)
		return nil
	case wingameslot.FieldFavoriteStar:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFavoriteStar(v)
		return nil
	case wingameslot.FieldHotStar:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHotStar(v)
		return nil
	case wingameslot.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case wingameslot.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case wingameslot.FieldDevice:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDevice(v)
		return nil
	case wingameslot.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case wingameslot.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WinGameSlot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WinGameSlotMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(wingameslot.FieldProvider) {
		fields = append(fields, wingameslot.FieldProvider)
	}
	if m.FieldCleared(wingameslot.FieldImgNew) {
		fields = append(fields, wingameslot.FieldImgNew)
	}
	if m.FieldCleared(wingameslot.FieldGameTypeID) {
		fields = append(fields, wingameslot.FieldGameTypeID)
	}
	if m.FieldCleared(wingameslot.FieldGameTypeName) {
		fields = append(fields, wingameslot.FieldGameTypeName)
	}
	if m.FieldCleared(wingameslot.FieldDevice) {
		fields = append(fields, wingameslot.FieldDevice)
	}
	if m.FieldCleared(wingameslot.FieldUpdatedUser) {
		fields = append(fields, wingameslot.FieldUpdatedUser)
	}
	if m.FieldCleared(wingameslot.FieldMaintenance) {
		fields = append(fields, wingameslot.FieldMaintenance)
	}
	if m.FieldCleared(wingameslot.FieldOperatorName) {
		fields = append(fields, wingameslot.FieldOperatorName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WinGameSlotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WinGameSlotMutation) ClearField(name string) error {
	switch name {
	case wingameslot.FieldProvider:
		m.ClearProvider()
		return nil
	case wingameslot.FieldImgNew:
		m.ClearImgNew()
		return nil
	case wingameslot.FieldGameTypeID:
		m.ClearGameTypeID()
		return nil
	case wingameslot.FieldGameTypeName:
		m.ClearGameTypeName()
		return nil
	case wingameslot.FieldDevice:
		m.ClearDevice()
		return nil
	case wingameslot.FieldUpdatedUser:
		m.ClearUpdatedUser()
		return nil
	case wingameslot.FieldMaintenance:
		m.ClearMaintenance()
		return nil
	case wingameslot.FieldOperatorName:
		m.ClearOperatorName()
		return nil
	}
	return fmt.Errorf("unknown WinGameSlot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WinGameSlotMutation) ResetField(name string) error {
	switch name {
	case wingameslot.FieldGameID:
		m.ResetGameID()
		return nil
	case wingameslot.FieldGameGroupID:
		m.ResetGameGroupID()
		return nil
	case wingameslot.FieldPlatID:
		m.ResetPlatID()
		return nil
	case wingameslot.FieldProvider:
		m.ResetProvider()
		return nil
	case wingameslot.FieldName:
		m.ResetName()
		return nil
	case wingameslot.FieldNameZh:
		m.ResetNameZh()
		return nil
	case wingameslot.FieldImg:
		m.ResetImg()
		return nil
	case wingameslot.FieldImgNew:
		m.ResetImgNew()
		return nil
	case wingameslot.FieldIsNew:
		m.ResetIsNew()
		return nil
	case wingameslot.FieldIsCasino:
		m.ResetIsCasino()
		return nil
	case wingameslot.FieldGameTypeID:
		m.ResetGameTypeID()
		return nil
	case wingameslot.FieldGameTypeName:
		m.ResetGameTypeName()
		return nil
	case wingameslot.FieldFavoriteStar:
		m.ResetFavoriteStar()
		return nil
	case wingameslot.FieldHotStar:
		m.ResetHotStar()
		return nil
	case wingameslot.FieldSort:
		m.ResetSort()
		return nil
	case wingameslot.FieldStatus:
		m.ResetStatus()
		return nil
	case wingameslot.FieldDevice:
		m.ResetDevice()
		return nil
	case wingameslot.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case wingameslot.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case wingameslot.FieldUpdatedUser:
		m.ResetUpdatedUser()
		return nil
	case wingameslot.FieldMaintenance:
		m.ResetMaintenance()
		return nil
	case wingameslot.FieldOperatorName:
		m.ResetOperatorName()
		return nil
	}
	return fmt.Errorf("unknown WinGameSlot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WinGameSlotMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WinGameSlotMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WinGameSlotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WinGameSlotMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WinGameSlotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WinGameSlotMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WinGameSlotMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WinGameSlot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WinGameSlotMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WinGameSlot edge %s", name)
}

// WinPlatListMutation represents an operation that mutates the WinPlatList nodes in the graph.
type WinPlatListMutation struct {
	config
	op            Op
	typ           string
	id            *int32
	code          *string
	name          *string
	_config       *string
	rate          *string
	sort          *int8
	addsort       *int8
	status        *int8
	addstatus     *int8
	created_at    *int32
	addcreated_at *int32
	updated_at    *int32
	addupdated_at *int32
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WinPlatList, error)
	predicates    []predicate.WinPlatList
}

var _ ent.Mutation = (*WinPlatListMutation)(nil)

// winplatlistOption allows management of the mutation configuration using functional options.
type winplatlistOption func(*WinPlatListMutation)

// newWinPlatListMutation creates new mutation for the WinPlatList entity.
func newWinPlatListMutation(c config, op Op, opts ...winplatlistOption) *WinPlatListMutation {
	m := &WinPlatListMutation{
		config:        c,
		op:            op,
		typ:           TypeWinPlatList,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWinPlatListID sets the ID field of the mutation.
func withWinPlatListID(id int32) winplatlistOption {
	return func(m *WinPlatListMutation) {
		var (
			err   error
			once  sync.Once
			value *WinPlatList
		)
		m.oldValue = func(ctx context.Context) (*WinPlatList, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WinPlatList.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWinPlatList sets the old WinPlatList of the mutation.
func withWinPlatList(node *WinPlatList) winplatlistOption {
	return func(m *WinPlatListMutation) {
		m.oldValue = func(context.Context) (*WinPlatList, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WinPlatListMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WinPlatListMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WinPlatList entities.
func (m *WinPlatListMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WinPlatListMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WinPlatListMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WinPlatList.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *WinPlatListMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *WinPlatListMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the WinPlatList entity.
// If the WinPlatList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinPlatListMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *WinPlatListMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *WinPlatListMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WinPlatListMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the WinPlatList entity.
// If the WinPlatList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinPlatListMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WinPlatListMutation) ResetName() {
	m.name = nil
}

// SetConfig sets the "config" field.
func (m *WinPlatListMutation) SetConfig(s string) {
	m._config = &s
}

// Config returns the value of the "config" field in the mutation.
func (m *WinPlatListMutation) Config() (r string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the WinPlatList entity.
// If the WinPlatList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinPlatListMutation) OldConfig(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *WinPlatListMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[winplatlist.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *WinPlatListMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[winplatlist.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *WinPlatListMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, winplatlist.FieldConfig)
}

// SetRate sets the "rate" field.
func (m *WinPlatListMutation) SetRate(s string) {
	m.rate = &s
}

// Rate returns the value of the "rate" field in the mutation.
func (m *WinPlatListMutation) Rate() (r string, exists bool) {
	v := m.rate
	if v == nil {
		return
	}
	return *v, true
}

// OldRate returns the old "rate" field's value of the WinPlatList entity.
// If the WinPlatList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinPlatListMutation) OldRate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRate: %w", err)
	}
	return oldValue.Rate, nil
}

// ClearRate clears the value of the "rate" field.
func (m *WinPlatListMutation) ClearRate() {
	m.rate = nil
	m.clearedFields[winplatlist.FieldRate] = struct{}{}
}

// RateCleared returns if the "rate" field was cleared in this mutation.
func (m *WinPlatListMutation) RateCleared() bool {
	_, ok := m.clearedFields[winplatlist.FieldRate]
	return ok
}

// ResetRate resets all changes to the "rate" field.
func (m *WinPlatListMutation) ResetRate() {
	m.rate = nil
	delete(m.clearedFields, winplatlist.FieldRate)
}

// SetSort sets the "sort" field.
func (m *WinPlatListMutation) SetSort(i int8) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *WinPlatListMutation) Sort() (r int8, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the WinPlatList entity.
// If the WinPlatList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinPlatListMutation) OldSort(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *WinPlatListMutation) AddSort(i int8) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *WinPlatListMutation) AddedSort() (r int8, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *WinPlatListMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetStatus sets the "status" field.
func (m *WinPlatListMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *WinPlatListMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the WinPlatList entity.
// If the WinPlatList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinPlatListMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *WinPlatListMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *WinPlatListMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *WinPlatListMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WinPlatListMutation) SetCreatedAt(i int32) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WinPlatListMutation) CreatedAt() (r int32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WinPlatList entity.
// If the WinPlatList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinPlatListMutation) OldCreatedAt(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *WinPlatListMutation) AddCreatedAt(i int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *WinPlatListMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WinPlatListMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WinPlatListMutation) SetUpdatedAt(i int32) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WinPlatListMutation) UpdatedAt() (r int32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WinPlatList entity.
// If the WinPlatList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinPlatListMutation) OldUpdatedAt(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *WinPlatListMutation) AddUpdatedAt(i int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *WinPlatListMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WinPlatListMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// Where appends a list predicates to the WinPlatListMutation builder.
func (m *WinPlatListMutation) Where(ps ...predicate.WinPlatList) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WinPlatListMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WinPlatListMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WinPlatList, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WinPlatListMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WinPlatListMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WinPlatList).
func (m *WinPlatListMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WinPlatListMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.code != nil {
		fields = append(fields, winplatlist.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, winplatlist.FieldName)
	}
	if m._config != nil {
		fields = append(fields, winplatlist.FieldConfig)
	}
	if m.rate != nil {
		fields = append(fields, winplatlist.FieldRate)
	}
	if m.sort != nil {
		fields = append(fields, winplatlist.FieldSort)
	}
	if m.status != nil {
		fields = append(fields, winplatlist.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, winplatlist.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, winplatlist.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WinPlatListMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case winplatlist.FieldCode:
		return m.Code()
	case winplatlist.FieldName:
		return m.Name()
	case winplatlist.FieldConfig:
		return m.Config()
	case winplatlist.FieldRate:
		return m.Rate()
	case winplatlist.FieldSort:
		return m.Sort()
	case winplatlist.FieldStatus:
		return m.Status()
	case winplatlist.FieldCreatedAt:
		return m.CreatedAt()
	case winplatlist.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WinPlatListMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case winplatlist.FieldCode:
		return m.OldCode(ctx)
	case winplatlist.FieldName:
		return m.OldName(ctx)
	case winplatlist.FieldConfig:
		return m.OldConfig(ctx)
	case winplatlist.FieldRate:
		return m.OldRate(ctx)
	case winplatlist.FieldSort:
		return m.OldSort(ctx)
	case winplatlist.FieldStatus:
		return m.OldStatus(ctx)
	case winplatlist.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case winplatlist.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WinPlatList field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WinPlatListMutation) SetField(name string, value ent.Value) error {
	switch name {
	case winplatlist.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case winplatlist.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case winplatlist.FieldConfig:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case winplatlist.FieldRate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRate(v)
		return nil
	case winplatlist.FieldSort:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case winplatlist.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case winplatlist.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case winplatlist.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WinPlatList field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WinPlatListMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, winplatlist.FieldSort)
	}
	if m.addstatus != nil {
		fields = append(fields, winplatlist.FieldStatus)
	}
	if m.addcreated_at != nil {
		fields = append(fields, winplatlist.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, winplatlist.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WinPlatListMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case winplatlist.FieldSort:
		return m.AddedSort()
	case winplatlist.FieldStatus:
		return m.AddedStatus()
	case winplatlist.FieldCreatedAt:
		return m.AddedCreatedAt()
	case winplatlist.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WinPlatListMutation) AddField(name string, value ent.Value) error {
	switch name {
	case winplatlist.FieldSort:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case winplatlist.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case winplatlist.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case winplatlist.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WinPlatList numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WinPlatListMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(winplatlist.FieldConfig) {
		fields = append(fields, winplatlist.FieldConfig)
	}
	if m.FieldCleared(winplatlist.FieldRate) {
		fields = append(fields, winplatlist.FieldRate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WinPlatListMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WinPlatListMutation) ClearField(name string) error {
	switch name {
	case winplatlist.FieldConfig:
		m.ClearConfig()
		return nil
	case winplatlist.FieldRate:
		m.ClearRate()
		return nil
	}
	return fmt.Errorf("unknown WinPlatList nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WinPlatListMutation) ResetField(name string) error {
	switch name {
	case winplatlist.FieldCode:
		m.ResetCode()
		return nil
	case winplatlist.FieldName:
		m.ResetName()
		return nil
	case winplatlist.FieldConfig:
		m.ResetConfig()
		return nil
	case winplatlist.FieldRate:
		m.ResetRate()
		return nil
	case winplatlist.FieldSort:
		m.ResetSort()
		return nil
	case winplatlist.FieldStatus:
		m.ResetStatus()
		return nil
	case winplatlist.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case winplatlist.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown WinPlatList field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WinPlatListMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WinPlatListMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WinPlatListMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WinPlatListMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WinPlatListMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WinPlatListMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WinPlatListMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WinPlatList unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WinPlatListMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WinPlatList edge %s", name)
}

// WinUserMutation represents an operation that mutates the WinUser nodes in the graph.
type WinUserMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int32
	username             *string
	avatar               *string
	fcoin                *float64
	addfcoin             *float64
	coin_commission      *float64
	addcoin_commission   *float64
	level_id             *int8
	addlevel_id          *int8
	role                 *int8
	addrole              *int8
	is_promoter          *bool
	flag                 *uint32
	addflag              *int32
	real_name            *string
	signature            *string
	birthday             *string
	area_code            *string
	mobile               *string
	email                *string
	sex                  *bool
	bind_bank            *bool
	address              *string
	score                *uint32
	addscore             *int32
	promo_code           *string
	sup_uid_1            *uint32
	addsup_uid_1         *int32
	sup_username_1       *string
	sup_uid_2            *uint32
	addsup_uid_2         *int32
	sup_uid_3            *uint32
	addsup_uid_3         *int32
	sup_uid_4            *uint32
	addsup_uid_4         *int32
	sup_uid_5            *uint32
	addsup_uid_5         *int32
	sup_uid_6            *uint32
	addsup_uid_6         *int32
	sup_uid_top          *int32
	addsup_uid_top       *int32
	sup_username_top     *string
	sup_level_top        *int32
	addsup_level_top     *int32
	password_hash        *string
	password_coin        *string
	ip                   *string
	ip_region            *string
	third_login_type     *string
	freeze_cause         *string
	freeze_at            *int32
	addfreeze_at         *int32
	operator_name        *string
	created_name         *string
	status               *int8
	addstatus            *int8
	last_login_ip        *string
	last_login_ip_region *string
	last_login_time      *int32
	addlast_login_time   *int32
	created_at           *int32
	addcreated_at        *int32
	updated_at           *int32
	addupdated_at        *int32
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*WinUser, error)
	predicates           []predicate.WinUser
}

var _ ent.Mutation = (*WinUserMutation)(nil)

// winuserOption allows management of the mutation configuration using functional options.
type winuserOption func(*WinUserMutation)

// newWinUserMutation creates new mutation for the WinUser entity.
func newWinUserMutation(c config, op Op, opts ...winuserOption) *WinUserMutation {
	m := &WinUserMutation{
		config:        c,
		op:            op,
		typ:           TypeWinUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWinUserID sets the ID field of the mutation.
func withWinUserID(id int32) winuserOption {
	return func(m *WinUserMutation) {
		var (
			err   error
			once  sync.Once
			value *WinUser
		)
		m.oldValue = func(ctx context.Context) (*WinUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WinUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWinUser sets the old WinUser of the mutation.
func withWinUser(node *WinUser) winuserOption {
	return func(m *WinUserMutation) {
		m.oldValue = func(context.Context) (*WinUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WinUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WinUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WinUser entities.
func (m *WinUserMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WinUserMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WinUserMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WinUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *WinUserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *WinUserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *WinUserMutation) ResetUsername() {
	m.username = nil
}

// SetAvatar sets the "avatar" field.
func (m *WinUserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *WinUserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *WinUserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[winuser.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *WinUserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[winuser.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *WinUserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, winuser.FieldAvatar)
}

// SetFcoin sets the "fcoin" field.
func (m *WinUserMutation) SetFcoin(f float64) {
	m.fcoin = &f
	m.addfcoin = nil
}

// Fcoin returns the value of the "fcoin" field in the mutation.
func (m *WinUserMutation) Fcoin() (r float64, exists bool) {
	v := m.fcoin
	if v == nil {
		return
	}
	return *v, true
}

// OldFcoin returns the old "fcoin" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldFcoin(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFcoin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFcoin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFcoin: %w", err)
	}
	return oldValue.Fcoin, nil
}

// AddFcoin adds f to the "fcoin" field.
func (m *WinUserMutation) AddFcoin(f float64) {
	if m.addfcoin != nil {
		*m.addfcoin += f
	} else {
		m.addfcoin = &f
	}
}

// AddedFcoin returns the value that was added to the "fcoin" field in this mutation.
func (m *WinUserMutation) AddedFcoin() (r float64, exists bool) {
	v := m.addfcoin
	if v == nil {
		return
	}
	return *v, true
}

// ResetFcoin resets all changes to the "fcoin" field.
func (m *WinUserMutation) ResetFcoin() {
	m.fcoin = nil
	m.addfcoin = nil
}

// SetCoinCommission sets the "coin_commission" field.
func (m *WinUserMutation) SetCoinCommission(f float64) {
	m.coin_commission = &f
	m.addcoin_commission = nil
}

// CoinCommission returns the value of the "coin_commission" field in the mutation.
func (m *WinUserMutation) CoinCommission() (r float64, exists bool) {
	v := m.coin_commission
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinCommission returns the old "coin_commission" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldCoinCommission(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinCommission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinCommission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinCommission: %w", err)
	}
	return oldValue.CoinCommission, nil
}

// AddCoinCommission adds f to the "coin_commission" field.
func (m *WinUserMutation) AddCoinCommission(f float64) {
	if m.addcoin_commission != nil {
		*m.addcoin_commission += f
	} else {
		m.addcoin_commission = &f
	}
}

// AddedCoinCommission returns the value that was added to the "coin_commission" field in this mutation.
func (m *WinUserMutation) AddedCoinCommission() (r float64, exists bool) {
	v := m.addcoin_commission
	if v == nil {
		return
	}
	return *v, true
}

// ResetCoinCommission resets all changes to the "coin_commission" field.
func (m *WinUserMutation) ResetCoinCommission() {
	m.coin_commission = nil
	m.addcoin_commission = nil
}

// SetLevelID sets the "level_id" field.
func (m *WinUserMutation) SetLevelID(i int8) {
	m.level_id = &i
	m.addlevel_id = nil
}

// LevelID returns the value of the "level_id" field in the mutation.
func (m *WinUserMutation) LevelID() (r int8, exists bool) {
	v := m.level_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLevelID returns the old "level_id" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldLevelID(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevelID: %w", err)
	}
	return oldValue.LevelID, nil
}

// AddLevelID adds i to the "level_id" field.
func (m *WinUserMutation) AddLevelID(i int8) {
	if m.addlevel_id != nil {
		*m.addlevel_id += i
	} else {
		m.addlevel_id = &i
	}
}

// AddedLevelID returns the value that was added to the "level_id" field in this mutation.
func (m *WinUserMutation) AddedLevelID() (r int8, exists bool) {
	v := m.addlevel_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevelID resets all changes to the "level_id" field.
func (m *WinUserMutation) ResetLevelID() {
	m.level_id = nil
	m.addlevel_id = nil
}

// SetRole sets the "role" field.
func (m *WinUserMutation) SetRole(i int8) {
	m.role = &i
	m.addrole = nil
}

// Role returns the value of the "role" field in the mutation.
func (m *WinUserMutation) Role() (r int8, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldRole(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// AddRole adds i to the "role" field.
func (m *WinUserMutation) AddRole(i int8) {
	if m.addrole != nil {
		*m.addrole += i
	} else {
		m.addrole = &i
	}
}

// AddedRole returns the value that was added to the "role" field in this mutation.
func (m *WinUserMutation) AddedRole() (r int8, exists bool) {
	v := m.addrole
	if v == nil {
		return
	}
	return *v, true
}

// ResetRole resets all changes to the "role" field.
func (m *WinUserMutation) ResetRole() {
	m.role = nil
	m.addrole = nil
}

// SetIsPromoter sets the "is_promoter" field.
func (m *WinUserMutation) SetIsPromoter(b bool) {
	m.is_promoter = &b
}

// IsPromoter returns the value of the "is_promoter" field in the mutation.
func (m *WinUserMutation) IsPromoter() (r bool, exists bool) {
	v := m.is_promoter
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPromoter returns the old "is_promoter" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldIsPromoter(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPromoter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPromoter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPromoter: %w", err)
	}
	return oldValue.IsPromoter, nil
}

// ResetIsPromoter resets all changes to the "is_promoter" field.
func (m *WinUserMutation) ResetIsPromoter() {
	m.is_promoter = nil
}

// SetFlag sets the "flag" field.
func (m *WinUserMutation) SetFlag(u uint32) {
	m.flag = &u
	m.addflag = nil
}

// Flag returns the value of the "flag" field in the mutation.
func (m *WinUserMutation) Flag() (r uint32, exists bool) {
	v := m.flag
	if v == nil {
		return
	}
	return *v, true
}

// OldFlag returns the old "flag" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldFlag(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlag: %w", err)
	}
	return oldValue.Flag, nil
}

// AddFlag adds u to the "flag" field.
func (m *WinUserMutation) AddFlag(u int32) {
	if m.addflag != nil {
		*m.addflag += u
	} else {
		m.addflag = &u
	}
}

// AddedFlag returns the value that was added to the "flag" field in this mutation.
func (m *WinUserMutation) AddedFlag() (r int32, exists bool) {
	v := m.addflag
	if v == nil {
		return
	}
	return *v, true
}

// ResetFlag resets all changes to the "flag" field.
func (m *WinUserMutation) ResetFlag() {
	m.flag = nil
	m.addflag = nil
}

// SetRealName sets the "real_name" field.
func (m *WinUserMutation) SetRealName(s string) {
	m.real_name = &s
}

// RealName returns the value of the "real_name" field in the mutation.
func (m *WinUserMutation) RealName() (r string, exists bool) {
	v := m.real_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRealName returns the old "real_name" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldRealName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRealName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRealName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRealName: %w", err)
	}
	return oldValue.RealName, nil
}

// ResetRealName resets all changes to the "real_name" field.
func (m *WinUserMutation) ResetRealName() {
	m.real_name = nil
}

// SetSignature sets the "signature" field.
func (m *WinUserMutation) SetSignature(s string) {
	m.signature = &s
}

// Signature returns the value of the "signature" field in the mutation.
func (m *WinUserMutation) Signature() (r string, exists bool) {
	v := m.signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "signature" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldSignature(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ResetSignature resets all changes to the "signature" field.
func (m *WinUserMutation) ResetSignature() {
	m.signature = nil
}

// SetBirthday sets the "birthday" field.
func (m *WinUserMutation) SetBirthday(s string) {
	m.birthday = &s
}

// Birthday returns the value of the "birthday" field in the mutation.
func (m *WinUserMutation) Birthday() (r string, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old "birthday" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldBirthday(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// ClearBirthday clears the value of the "birthday" field.
func (m *WinUserMutation) ClearBirthday() {
	m.birthday = nil
	m.clearedFields[winuser.FieldBirthday] = struct{}{}
}

// BirthdayCleared returns if the "birthday" field was cleared in this mutation.
func (m *WinUserMutation) BirthdayCleared() bool {
	_, ok := m.clearedFields[winuser.FieldBirthday]
	return ok
}

// ResetBirthday resets all changes to the "birthday" field.
func (m *WinUserMutation) ResetBirthday() {
	m.birthday = nil
	delete(m.clearedFields, winuser.FieldBirthday)
}

// SetAreaCode sets the "area_code" field.
func (m *WinUserMutation) SetAreaCode(s string) {
	m.area_code = &s
}

// AreaCode returns the value of the "area_code" field in the mutation.
func (m *WinUserMutation) AreaCode() (r string, exists bool) {
	v := m.area_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAreaCode returns the old "area_code" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldAreaCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAreaCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAreaCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAreaCode: %w", err)
	}
	return oldValue.AreaCode, nil
}

// ResetAreaCode resets all changes to the "area_code" field.
func (m *WinUserMutation) ResetAreaCode() {
	m.area_code = nil
}

// SetMobile sets the "mobile" field.
func (m *WinUserMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *WinUserMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ResetMobile resets all changes to the "mobile" field.
func (m *WinUserMutation) ResetMobile() {
	m.mobile = nil
}

// SetEmail sets the "email" field.
func (m *WinUserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *WinUserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *WinUserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[winuser.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *WinUserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[winuser.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *WinUserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, winuser.FieldEmail)
}

// SetSex sets the "sex" field.
func (m *WinUserMutation) SetSex(b bool) {
	m.sex = &b
}

// Sex returns the value of the "sex" field in the mutation.
func (m *WinUserMutation) Sex() (r bool, exists bool) {
	v := m.sex
	if v == nil {
		return
	}
	return *v, true
}

// OldSex returns the old "sex" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldSex(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSex: %w", err)
	}
	return oldValue.Sex, nil
}

// ResetSex resets all changes to the "sex" field.
func (m *WinUserMutation) ResetSex() {
	m.sex = nil
}

// SetBindBank sets the "bind_bank" field.
func (m *WinUserMutation) SetBindBank(b bool) {
	m.bind_bank = &b
}

// BindBank returns the value of the "bind_bank" field in the mutation.
func (m *WinUserMutation) BindBank() (r bool, exists bool) {
	v := m.bind_bank
	if v == nil {
		return
	}
	return *v, true
}

// OldBindBank returns the old "bind_bank" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldBindBank(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBindBank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBindBank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBindBank: %w", err)
	}
	return oldValue.BindBank, nil
}

// ResetBindBank resets all changes to the "bind_bank" field.
func (m *WinUserMutation) ResetBindBank() {
	m.bind_bank = nil
}

// SetAddress sets the "address" field.
func (m *WinUserMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *WinUserMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *WinUserMutation) ResetAddress() {
	m.address = nil
}

// SetScore sets the "score" field.
func (m *WinUserMutation) SetScore(u uint32) {
	m.score = &u
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *WinUserMutation) Score() (r uint32, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldScore(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds u to the "score" field.
func (m *WinUserMutation) AddScore(u int32) {
	if m.addscore != nil {
		*m.addscore += u
	} else {
		m.addscore = &u
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *WinUserMutation) AddedScore() (r int32, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ResetScore resets all changes to the "score" field.
func (m *WinUserMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
}

// SetPromoCode sets the "promo_code" field.
func (m *WinUserMutation) SetPromoCode(s string) {
	m.promo_code = &s
}

// PromoCode returns the value of the "promo_code" field in the mutation.
func (m *WinUserMutation) PromoCode() (r string, exists bool) {
	v := m.promo_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPromoCode returns the old "promo_code" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldPromoCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromoCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromoCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromoCode: %w", err)
	}
	return oldValue.PromoCode, nil
}

// ResetPromoCode resets all changes to the "promo_code" field.
func (m *WinUserMutation) ResetPromoCode() {
	m.promo_code = nil
}

// SetSupUID1 sets the "sup_uid_1" field.
func (m *WinUserMutation) SetSupUID1(u uint32) {
	m.sup_uid_1 = &u
	m.addsup_uid_1 = nil
}

// SupUID1 returns the value of the "sup_uid_1" field in the mutation.
func (m *WinUserMutation) SupUID1() (r uint32, exists bool) {
	v := m.sup_uid_1
	if v == nil {
		return
	}
	return *v, true
}

// OldSupUID1 returns the old "sup_uid_1" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldSupUID1(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupUID1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupUID1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupUID1: %w", err)
	}
	return oldValue.SupUID1, nil
}

// AddSupUID1 adds u to the "sup_uid_1" field.
func (m *WinUserMutation) AddSupUID1(u int32) {
	if m.addsup_uid_1 != nil {
		*m.addsup_uid_1 += u
	} else {
		m.addsup_uid_1 = &u
	}
}

// AddedSupUID1 returns the value that was added to the "sup_uid_1" field in this mutation.
func (m *WinUserMutation) AddedSupUID1() (r int32, exists bool) {
	v := m.addsup_uid_1
	if v == nil {
		return
	}
	return *v, true
}

// ResetSupUID1 resets all changes to the "sup_uid_1" field.
func (m *WinUserMutation) ResetSupUID1() {
	m.sup_uid_1 = nil
	m.addsup_uid_1 = nil
}

// SetSupUsername1 sets the "sup_username_1" field.
func (m *WinUserMutation) SetSupUsername1(s string) {
	m.sup_username_1 = &s
}

// SupUsername1 returns the value of the "sup_username_1" field in the mutation.
func (m *WinUserMutation) SupUsername1() (r string, exists bool) {
	v := m.sup_username_1
	if v == nil {
		return
	}
	return *v, true
}

// OldSupUsername1 returns the old "sup_username_1" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldSupUsername1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupUsername1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupUsername1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupUsername1: %w", err)
	}
	return oldValue.SupUsername1, nil
}

// ResetSupUsername1 resets all changes to the "sup_username_1" field.
func (m *WinUserMutation) ResetSupUsername1() {
	m.sup_username_1 = nil
}

// SetSupUID2 sets the "sup_uid_2" field.
func (m *WinUserMutation) SetSupUID2(u uint32) {
	m.sup_uid_2 = &u
	m.addsup_uid_2 = nil
}

// SupUID2 returns the value of the "sup_uid_2" field in the mutation.
func (m *WinUserMutation) SupUID2() (r uint32, exists bool) {
	v := m.sup_uid_2
	if v == nil {
		return
	}
	return *v, true
}

// OldSupUID2 returns the old "sup_uid_2" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldSupUID2(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupUID2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupUID2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupUID2: %w", err)
	}
	return oldValue.SupUID2, nil
}

// AddSupUID2 adds u to the "sup_uid_2" field.
func (m *WinUserMutation) AddSupUID2(u int32) {
	if m.addsup_uid_2 != nil {
		*m.addsup_uid_2 += u
	} else {
		m.addsup_uid_2 = &u
	}
}

// AddedSupUID2 returns the value that was added to the "sup_uid_2" field in this mutation.
func (m *WinUserMutation) AddedSupUID2() (r int32, exists bool) {
	v := m.addsup_uid_2
	if v == nil {
		return
	}
	return *v, true
}

// ResetSupUID2 resets all changes to the "sup_uid_2" field.
func (m *WinUserMutation) ResetSupUID2() {
	m.sup_uid_2 = nil
	m.addsup_uid_2 = nil
}

// SetSupUID3 sets the "sup_uid_3" field.
func (m *WinUserMutation) SetSupUID3(u uint32) {
	m.sup_uid_3 = &u
	m.addsup_uid_3 = nil
}

// SupUID3 returns the value of the "sup_uid_3" field in the mutation.
func (m *WinUserMutation) SupUID3() (r uint32, exists bool) {
	v := m.sup_uid_3
	if v == nil {
		return
	}
	return *v, true
}

// OldSupUID3 returns the old "sup_uid_3" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldSupUID3(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupUID3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupUID3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupUID3: %w", err)
	}
	return oldValue.SupUID3, nil
}

// AddSupUID3 adds u to the "sup_uid_3" field.
func (m *WinUserMutation) AddSupUID3(u int32) {
	if m.addsup_uid_3 != nil {
		*m.addsup_uid_3 += u
	} else {
		m.addsup_uid_3 = &u
	}
}

// AddedSupUID3 returns the value that was added to the "sup_uid_3" field in this mutation.
func (m *WinUserMutation) AddedSupUID3() (r int32, exists bool) {
	v := m.addsup_uid_3
	if v == nil {
		return
	}
	return *v, true
}

// ResetSupUID3 resets all changes to the "sup_uid_3" field.
func (m *WinUserMutation) ResetSupUID3() {
	m.sup_uid_3 = nil
	m.addsup_uid_3 = nil
}

// SetSupUID4 sets the "sup_uid_4" field.
func (m *WinUserMutation) SetSupUID4(u uint32) {
	m.sup_uid_4 = &u
	m.addsup_uid_4 = nil
}

// SupUID4 returns the value of the "sup_uid_4" field in the mutation.
func (m *WinUserMutation) SupUID4() (r uint32, exists bool) {
	v := m.sup_uid_4
	if v == nil {
		return
	}
	return *v, true
}

// OldSupUID4 returns the old "sup_uid_4" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldSupUID4(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupUID4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupUID4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupUID4: %w", err)
	}
	return oldValue.SupUID4, nil
}

// AddSupUID4 adds u to the "sup_uid_4" field.
func (m *WinUserMutation) AddSupUID4(u int32) {
	if m.addsup_uid_4 != nil {
		*m.addsup_uid_4 += u
	} else {
		m.addsup_uid_4 = &u
	}
}

// AddedSupUID4 returns the value that was added to the "sup_uid_4" field in this mutation.
func (m *WinUserMutation) AddedSupUID4() (r int32, exists bool) {
	v := m.addsup_uid_4
	if v == nil {
		return
	}
	return *v, true
}

// ResetSupUID4 resets all changes to the "sup_uid_4" field.
func (m *WinUserMutation) ResetSupUID4() {
	m.sup_uid_4 = nil
	m.addsup_uid_4 = nil
}

// SetSupUID5 sets the "sup_uid_5" field.
func (m *WinUserMutation) SetSupUID5(u uint32) {
	m.sup_uid_5 = &u
	m.addsup_uid_5 = nil
}

// SupUID5 returns the value of the "sup_uid_5" field in the mutation.
func (m *WinUserMutation) SupUID5() (r uint32, exists bool) {
	v := m.sup_uid_5
	if v == nil {
		return
	}
	return *v, true
}

// OldSupUID5 returns the old "sup_uid_5" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldSupUID5(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupUID5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupUID5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupUID5: %w", err)
	}
	return oldValue.SupUID5, nil
}

// AddSupUID5 adds u to the "sup_uid_5" field.
func (m *WinUserMutation) AddSupUID5(u int32) {
	if m.addsup_uid_5 != nil {
		*m.addsup_uid_5 += u
	} else {
		m.addsup_uid_5 = &u
	}
}

// AddedSupUID5 returns the value that was added to the "sup_uid_5" field in this mutation.
func (m *WinUserMutation) AddedSupUID5() (r int32, exists bool) {
	v := m.addsup_uid_5
	if v == nil {
		return
	}
	return *v, true
}

// ResetSupUID5 resets all changes to the "sup_uid_5" field.
func (m *WinUserMutation) ResetSupUID5() {
	m.sup_uid_5 = nil
	m.addsup_uid_5 = nil
}

// SetSupUID6 sets the "sup_uid_6" field.
func (m *WinUserMutation) SetSupUID6(u uint32) {
	m.sup_uid_6 = &u
	m.addsup_uid_6 = nil
}

// SupUID6 returns the value of the "sup_uid_6" field in the mutation.
func (m *WinUserMutation) SupUID6() (r uint32, exists bool) {
	v := m.sup_uid_6
	if v == nil {
		return
	}
	return *v, true
}

// OldSupUID6 returns the old "sup_uid_6" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldSupUID6(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupUID6 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupUID6 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupUID6: %w", err)
	}
	return oldValue.SupUID6, nil
}

// AddSupUID6 adds u to the "sup_uid_6" field.
func (m *WinUserMutation) AddSupUID6(u int32) {
	if m.addsup_uid_6 != nil {
		*m.addsup_uid_6 += u
	} else {
		m.addsup_uid_6 = &u
	}
}

// AddedSupUID6 returns the value that was added to the "sup_uid_6" field in this mutation.
func (m *WinUserMutation) AddedSupUID6() (r int32, exists bool) {
	v := m.addsup_uid_6
	if v == nil {
		return
	}
	return *v, true
}

// ResetSupUID6 resets all changes to the "sup_uid_6" field.
func (m *WinUserMutation) ResetSupUID6() {
	m.sup_uid_6 = nil
	m.addsup_uid_6 = nil
}

// SetSupUIDTop sets the "sup_uid_top" field.
func (m *WinUserMutation) SetSupUIDTop(i int32) {
	m.sup_uid_top = &i
	m.addsup_uid_top = nil
}

// SupUIDTop returns the value of the "sup_uid_top" field in the mutation.
func (m *WinUserMutation) SupUIDTop() (r int32, exists bool) {
	v := m.sup_uid_top
	if v == nil {
		return
	}
	return *v, true
}

// OldSupUIDTop returns the old "sup_uid_top" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldSupUIDTop(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupUIDTop is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupUIDTop requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupUIDTop: %w", err)
	}
	return oldValue.SupUIDTop, nil
}

// AddSupUIDTop adds i to the "sup_uid_top" field.
func (m *WinUserMutation) AddSupUIDTop(i int32) {
	if m.addsup_uid_top != nil {
		*m.addsup_uid_top += i
	} else {
		m.addsup_uid_top = &i
	}
}

// AddedSupUIDTop returns the value that was added to the "sup_uid_top" field in this mutation.
func (m *WinUserMutation) AddedSupUIDTop() (r int32, exists bool) {
	v := m.addsup_uid_top
	if v == nil {
		return
	}
	return *v, true
}

// ResetSupUIDTop resets all changes to the "sup_uid_top" field.
func (m *WinUserMutation) ResetSupUIDTop() {
	m.sup_uid_top = nil
	m.addsup_uid_top = nil
}

// SetSupUsernameTop sets the "sup_username_top" field.
func (m *WinUserMutation) SetSupUsernameTop(s string) {
	m.sup_username_top = &s
}

// SupUsernameTop returns the value of the "sup_username_top" field in the mutation.
func (m *WinUserMutation) SupUsernameTop() (r string, exists bool) {
	v := m.sup_username_top
	if v == nil {
		return
	}
	return *v, true
}

// OldSupUsernameTop returns the old "sup_username_top" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldSupUsernameTop(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupUsernameTop is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupUsernameTop requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupUsernameTop: %w", err)
	}
	return oldValue.SupUsernameTop, nil
}

// ResetSupUsernameTop resets all changes to the "sup_username_top" field.
func (m *WinUserMutation) ResetSupUsernameTop() {
	m.sup_username_top = nil
}

// SetSupLevelTop sets the "sup_level_top" field.
func (m *WinUserMutation) SetSupLevelTop(i int32) {
	m.sup_level_top = &i
	m.addsup_level_top = nil
}

// SupLevelTop returns the value of the "sup_level_top" field in the mutation.
func (m *WinUserMutation) SupLevelTop() (r int32, exists bool) {
	v := m.sup_level_top
	if v == nil {
		return
	}
	return *v, true
}

// OldSupLevelTop returns the old "sup_level_top" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldSupLevelTop(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupLevelTop is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupLevelTop requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupLevelTop: %w", err)
	}
	return oldValue.SupLevelTop, nil
}

// AddSupLevelTop adds i to the "sup_level_top" field.
func (m *WinUserMutation) AddSupLevelTop(i int32) {
	if m.addsup_level_top != nil {
		*m.addsup_level_top += i
	} else {
		m.addsup_level_top = &i
	}
}

// AddedSupLevelTop returns the value that was added to the "sup_level_top" field in this mutation.
func (m *WinUserMutation) AddedSupLevelTop() (r int32, exists bool) {
	v := m.addsup_level_top
	if v == nil {
		return
	}
	return *v, true
}

// ResetSupLevelTop resets all changes to the "sup_level_top" field.
func (m *WinUserMutation) ResetSupLevelTop() {
	m.sup_level_top = nil
	m.addsup_level_top = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *WinUserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *WinUserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *WinUserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetPasswordCoin sets the "password_coin" field.
func (m *WinUserMutation) SetPasswordCoin(s string) {
	m.password_coin = &s
}

// PasswordCoin returns the value of the "password_coin" field in the mutation.
func (m *WinUserMutation) PasswordCoin() (r string, exists bool) {
	v := m.password_coin
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordCoin returns the old "password_coin" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldPasswordCoin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordCoin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordCoin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordCoin: %w", err)
	}
	return oldValue.PasswordCoin, nil
}

// ResetPasswordCoin resets all changes to the "password_coin" field.
func (m *WinUserMutation) ResetPasswordCoin() {
	m.password_coin = nil
}

// SetIP sets the "ip" field.
func (m *WinUserMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *WinUserMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *WinUserMutation) ResetIP() {
	m.ip = nil
}

// SetIPRegion sets the "ip_region" field.
func (m *WinUserMutation) SetIPRegion(s string) {
	m.ip_region = &s
}

// IPRegion returns the value of the "ip_region" field in the mutation.
func (m *WinUserMutation) IPRegion() (r string, exists bool) {
	v := m.ip_region
	if v == nil {
		return
	}
	return *v, true
}

// OldIPRegion returns the old "ip_region" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldIPRegion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPRegion: %w", err)
	}
	return oldValue.IPRegion, nil
}

// ClearIPRegion clears the value of the "ip_region" field.
func (m *WinUserMutation) ClearIPRegion() {
	m.ip_region = nil
	m.clearedFields[winuser.FieldIPRegion] = struct{}{}
}

// IPRegionCleared returns if the "ip_region" field was cleared in this mutation.
func (m *WinUserMutation) IPRegionCleared() bool {
	_, ok := m.clearedFields[winuser.FieldIPRegion]
	return ok
}

// ResetIPRegion resets all changes to the "ip_region" field.
func (m *WinUserMutation) ResetIPRegion() {
	m.ip_region = nil
	delete(m.clearedFields, winuser.FieldIPRegion)
}

// SetThirdLoginType sets the "third_login_type" field.
func (m *WinUserMutation) SetThirdLoginType(s string) {
	m.third_login_type = &s
}

// ThirdLoginType returns the value of the "third_login_type" field in the mutation.
func (m *WinUserMutation) ThirdLoginType() (r string, exists bool) {
	v := m.third_login_type
	if v == nil {
		return
	}
	return *v, true
}

// OldThirdLoginType returns the old "third_login_type" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldThirdLoginType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThirdLoginType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThirdLoginType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThirdLoginType: %w", err)
	}
	return oldValue.ThirdLoginType, nil
}

// ResetThirdLoginType resets all changes to the "third_login_type" field.
func (m *WinUserMutation) ResetThirdLoginType() {
	m.third_login_type = nil
}

// SetFreezeCause sets the "freeze_cause" field.
func (m *WinUserMutation) SetFreezeCause(s string) {
	m.freeze_cause = &s
}

// FreezeCause returns the value of the "freeze_cause" field in the mutation.
func (m *WinUserMutation) FreezeCause() (r string, exists bool) {
	v := m.freeze_cause
	if v == nil {
		return
	}
	return *v, true
}

// OldFreezeCause returns the old "freeze_cause" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldFreezeCause(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFreezeCause is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFreezeCause requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFreezeCause: %w", err)
	}
	return oldValue.FreezeCause, nil
}

// ClearFreezeCause clears the value of the "freeze_cause" field.
func (m *WinUserMutation) ClearFreezeCause() {
	m.freeze_cause = nil
	m.clearedFields[winuser.FieldFreezeCause] = struct{}{}
}

// FreezeCauseCleared returns if the "freeze_cause" field was cleared in this mutation.
func (m *WinUserMutation) FreezeCauseCleared() bool {
	_, ok := m.clearedFields[winuser.FieldFreezeCause]
	return ok
}

// ResetFreezeCause resets all changes to the "freeze_cause" field.
func (m *WinUserMutation) ResetFreezeCause() {
	m.freeze_cause = nil
	delete(m.clearedFields, winuser.FieldFreezeCause)
}

// SetFreezeAt sets the "freeze_at" field.
func (m *WinUserMutation) SetFreezeAt(i int32) {
	m.freeze_at = &i
	m.addfreeze_at = nil
}

// FreezeAt returns the value of the "freeze_at" field in the mutation.
func (m *WinUserMutation) FreezeAt() (r int32, exists bool) {
	v := m.freeze_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFreezeAt returns the old "freeze_at" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldFreezeAt(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFreezeAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFreezeAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFreezeAt: %w", err)
	}
	return oldValue.FreezeAt, nil
}

// AddFreezeAt adds i to the "freeze_at" field.
func (m *WinUserMutation) AddFreezeAt(i int32) {
	if m.addfreeze_at != nil {
		*m.addfreeze_at += i
	} else {
		m.addfreeze_at = &i
	}
}

// AddedFreezeAt returns the value that was added to the "freeze_at" field in this mutation.
func (m *WinUserMutation) AddedFreezeAt() (r int32, exists bool) {
	v := m.addfreeze_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearFreezeAt clears the value of the "freeze_at" field.
func (m *WinUserMutation) ClearFreezeAt() {
	m.freeze_at = nil
	m.addfreeze_at = nil
	m.clearedFields[winuser.FieldFreezeAt] = struct{}{}
}

// FreezeAtCleared returns if the "freeze_at" field was cleared in this mutation.
func (m *WinUserMutation) FreezeAtCleared() bool {
	_, ok := m.clearedFields[winuser.FieldFreezeAt]
	return ok
}

// ResetFreezeAt resets all changes to the "freeze_at" field.
func (m *WinUserMutation) ResetFreezeAt() {
	m.freeze_at = nil
	m.addfreeze_at = nil
	delete(m.clearedFields, winuser.FieldFreezeAt)
}

// SetOperatorName sets the "operator_name" field.
func (m *WinUserMutation) SetOperatorName(s string) {
	m.operator_name = &s
}

// OperatorName returns the value of the "operator_name" field in the mutation.
func (m *WinUserMutation) OperatorName() (r string, exists bool) {
	v := m.operator_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorName returns the old "operator_name" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldOperatorName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorName: %w", err)
	}
	return oldValue.OperatorName, nil
}

// ClearOperatorName clears the value of the "operator_name" field.
func (m *WinUserMutation) ClearOperatorName() {
	m.operator_name = nil
	m.clearedFields[winuser.FieldOperatorName] = struct{}{}
}

// OperatorNameCleared returns if the "operator_name" field was cleared in this mutation.
func (m *WinUserMutation) OperatorNameCleared() bool {
	_, ok := m.clearedFields[winuser.FieldOperatorName]
	return ok
}

// ResetOperatorName resets all changes to the "operator_name" field.
func (m *WinUserMutation) ResetOperatorName() {
	m.operator_name = nil
	delete(m.clearedFields, winuser.FieldOperatorName)
}

// SetCreatedName sets the "created_name" field.
func (m *WinUserMutation) SetCreatedName(s string) {
	m.created_name = &s
}

// CreatedName returns the value of the "created_name" field in the mutation.
func (m *WinUserMutation) CreatedName() (r string, exists bool) {
	v := m.created_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedName returns the old "created_name" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldCreatedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedName: %w", err)
	}
	return oldValue.CreatedName, nil
}

// ClearCreatedName clears the value of the "created_name" field.
func (m *WinUserMutation) ClearCreatedName() {
	m.created_name = nil
	m.clearedFields[winuser.FieldCreatedName] = struct{}{}
}

// CreatedNameCleared returns if the "created_name" field was cleared in this mutation.
func (m *WinUserMutation) CreatedNameCleared() bool {
	_, ok := m.clearedFields[winuser.FieldCreatedName]
	return ok
}

// ResetCreatedName resets all changes to the "created_name" field.
func (m *WinUserMutation) ResetCreatedName() {
	m.created_name = nil
	delete(m.clearedFields, winuser.FieldCreatedName)
}

// SetStatus sets the "status" field.
func (m *WinUserMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *WinUserMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *WinUserMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *WinUserMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *WinUserMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetLastLoginIP sets the "last_login_ip" field.
func (m *WinUserMutation) SetLastLoginIP(s string) {
	m.last_login_ip = &s
}

// LastLoginIP returns the value of the "last_login_ip" field in the mutation.
func (m *WinUserMutation) LastLoginIP() (r string, exists bool) {
	v := m.last_login_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginIP returns the old "last_login_ip" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldLastLoginIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginIP: %w", err)
	}
	return oldValue.LastLoginIP, nil
}

// ClearLastLoginIP clears the value of the "last_login_ip" field.
func (m *WinUserMutation) ClearLastLoginIP() {
	m.last_login_ip = nil
	m.clearedFields[winuser.FieldLastLoginIP] = struct{}{}
}

// LastLoginIPCleared returns if the "last_login_ip" field was cleared in this mutation.
func (m *WinUserMutation) LastLoginIPCleared() bool {
	_, ok := m.clearedFields[winuser.FieldLastLoginIP]
	return ok
}

// ResetLastLoginIP resets all changes to the "last_login_ip" field.
func (m *WinUserMutation) ResetLastLoginIP() {
	m.last_login_ip = nil
	delete(m.clearedFields, winuser.FieldLastLoginIP)
}

// SetLastLoginIPRegion sets the "last_login_ip_region" field.
func (m *WinUserMutation) SetLastLoginIPRegion(s string) {
	m.last_login_ip_region = &s
}

// LastLoginIPRegion returns the value of the "last_login_ip_region" field in the mutation.
func (m *WinUserMutation) LastLoginIPRegion() (r string, exists bool) {
	v := m.last_login_ip_region
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginIPRegion returns the old "last_login_ip_region" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldLastLoginIPRegion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginIPRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginIPRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginIPRegion: %w", err)
	}
	return oldValue.LastLoginIPRegion, nil
}

// ClearLastLoginIPRegion clears the value of the "last_login_ip_region" field.
func (m *WinUserMutation) ClearLastLoginIPRegion() {
	m.last_login_ip_region = nil
	m.clearedFields[winuser.FieldLastLoginIPRegion] = struct{}{}
}

// LastLoginIPRegionCleared returns if the "last_login_ip_region" field was cleared in this mutation.
func (m *WinUserMutation) LastLoginIPRegionCleared() bool {
	_, ok := m.clearedFields[winuser.FieldLastLoginIPRegion]
	return ok
}

// ResetLastLoginIPRegion resets all changes to the "last_login_ip_region" field.
func (m *WinUserMutation) ResetLastLoginIPRegion() {
	m.last_login_ip_region = nil
	delete(m.clearedFields, winuser.FieldLastLoginIPRegion)
}

// SetLastLoginTime sets the "last_login_time" field.
func (m *WinUserMutation) SetLastLoginTime(i int32) {
	m.last_login_time = &i
	m.addlast_login_time = nil
}

// LastLoginTime returns the value of the "last_login_time" field in the mutation.
func (m *WinUserMutation) LastLoginTime() (r int32, exists bool) {
	v := m.last_login_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginTime returns the old "last_login_time" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldLastLoginTime(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginTime: %w", err)
	}
	return oldValue.LastLoginTime, nil
}

// AddLastLoginTime adds i to the "last_login_time" field.
func (m *WinUserMutation) AddLastLoginTime(i int32) {
	if m.addlast_login_time != nil {
		*m.addlast_login_time += i
	} else {
		m.addlast_login_time = &i
	}
}

// AddedLastLoginTime returns the value that was added to the "last_login_time" field in this mutation.
func (m *WinUserMutation) AddedLastLoginTime() (r int32, exists bool) {
	v := m.addlast_login_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearLastLoginTime clears the value of the "last_login_time" field.
func (m *WinUserMutation) ClearLastLoginTime() {
	m.last_login_time = nil
	m.addlast_login_time = nil
	m.clearedFields[winuser.FieldLastLoginTime] = struct{}{}
}

// LastLoginTimeCleared returns if the "last_login_time" field was cleared in this mutation.
func (m *WinUserMutation) LastLoginTimeCleared() bool {
	_, ok := m.clearedFields[winuser.FieldLastLoginTime]
	return ok
}

// ResetLastLoginTime resets all changes to the "last_login_time" field.
func (m *WinUserMutation) ResetLastLoginTime() {
	m.last_login_time = nil
	m.addlast_login_time = nil
	delete(m.clearedFields, winuser.FieldLastLoginTime)
}

// SetCreatedAt sets the "created_at" field.
func (m *WinUserMutation) SetCreatedAt(i int32) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WinUserMutation) CreatedAt() (r int32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldCreatedAt(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *WinUserMutation) AddCreatedAt(i int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *WinUserMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WinUserMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WinUserMutation) SetUpdatedAt(i int32) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WinUserMutation) UpdatedAt() (r int32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WinUser entity.
// If the WinUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserMutation) OldUpdatedAt(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *WinUserMutation) AddUpdatedAt(i int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *WinUserMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WinUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// Where appends a list predicates to the WinUserMutation builder.
func (m *WinUserMutation) Where(ps ...predicate.WinUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WinUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WinUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WinUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WinUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WinUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WinUser).
func (m *WinUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WinUserMutation) Fields() []string {
	fields := make([]string, 0, 44)
	if m.username != nil {
		fields = append(fields, winuser.FieldUsername)
	}
	if m.avatar != nil {
		fields = append(fields, winuser.FieldAvatar)
	}
	if m.fcoin != nil {
		fields = append(fields, winuser.FieldFcoin)
	}
	if m.coin_commission != nil {
		fields = append(fields, winuser.FieldCoinCommission)
	}
	if m.level_id != nil {
		fields = append(fields, winuser.FieldLevelID)
	}
	if m.role != nil {
		fields = append(fields, winuser.FieldRole)
	}
	if m.is_promoter != nil {
		fields = append(fields, winuser.FieldIsPromoter)
	}
	if m.flag != nil {
		fields = append(fields, winuser.FieldFlag)
	}
	if m.real_name != nil {
		fields = append(fields, winuser.FieldRealName)
	}
	if m.signature != nil {
		fields = append(fields, winuser.FieldSignature)
	}
	if m.birthday != nil {
		fields = append(fields, winuser.FieldBirthday)
	}
	if m.area_code != nil {
		fields = append(fields, winuser.FieldAreaCode)
	}
	if m.mobile != nil {
		fields = append(fields, winuser.FieldMobile)
	}
	if m.email != nil {
		fields = append(fields, winuser.FieldEmail)
	}
	if m.sex != nil {
		fields = append(fields, winuser.FieldSex)
	}
	if m.bind_bank != nil {
		fields = append(fields, winuser.FieldBindBank)
	}
	if m.address != nil {
		fields = append(fields, winuser.FieldAddress)
	}
	if m.score != nil {
		fields = append(fields, winuser.FieldScore)
	}
	if m.promo_code != nil {
		fields = append(fields, winuser.FieldPromoCode)
	}
	if m.sup_uid_1 != nil {
		fields = append(fields, winuser.FieldSupUID1)
	}
	if m.sup_username_1 != nil {
		fields = append(fields, winuser.FieldSupUsername1)
	}
	if m.sup_uid_2 != nil {
		fields = append(fields, winuser.FieldSupUID2)
	}
	if m.sup_uid_3 != nil {
		fields = append(fields, winuser.FieldSupUID3)
	}
	if m.sup_uid_4 != nil {
		fields = append(fields, winuser.FieldSupUID4)
	}
	if m.sup_uid_5 != nil {
		fields = append(fields, winuser.FieldSupUID5)
	}
	if m.sup_uid_6 != nil {
		fields = append(fields, winuser.FieldSupUID6)
	}
	if m.sup_uid_top != nil {
		fields = append(fields, winuser.FieldSupUIDTop)
	}
	if m.sup_username_top != nil {
		fields = append(fields, winuser.FieldSupUsernameTop)
	}
	if m.sup_level_top != nil {
		fields = append(fields, winuser.FieldSupLevelTop)
	}
	if m.password_hash != nil {
		fields = append(fields, winuser.FieldPasswordHash)
	}
	if m.password_coin != nil {
		fields = append(fields, winuser.FieldPasswordCoin)
	}
	if m.ip != nil {
		fields = append(fields, winuser.FieldIP)
	}
	if m.ip_region != nil {
		fields = append(fields, winuser.FieldIPRegion)
	}
	if m.third_login_type != nil {
		fields = append(fields, winuser.FieldThirdLoginType)
	}
	if m.freeze_cause != nil {
		fields = append(fields, winuser.FieldFreezeCause)
	}
	if m.freeze_at != nil {
		fields = append(fields, winuser.FieldFreezeAt)
	}
	if m.operator_name != nil {
		fields = append(fields, winuser.FieldOperatorName)
	}
	if m.created_name != nil {
		fields = append(fields, winuser.FieldCreatedName)
	}
	if m.status != nil {
		fields = append(fields, winuser.FieldStatus)
	}
	if m.last_login_ip != nil {
		fields = append(fields, winuser.FieldLastLoginIP)
	}
	if m.last_login_ip_region != nil {
		fields = append(fields, winuser.FieldLastLoginIPRegion)
	}
	if m.last_login_time != nil {
		fields = append(fields, winuser.FieldLastLoginTime)
	}
	if m.created_at != nil {
		fields = append(fields, winuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, winuser.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WinUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case winuser.FieldUsername:
		return m.Username()
	case winuser.FieldAvatar:
		return m.Avatar()
	case winuser.FieldFcoin:
		return m.Fcoin()
	case winuser.FieldCoinCommission:
		return m.CoinCommission()
	case winuser.FieldLevelID:
		return m.LevelID()
	case winuser.FieldRole:
		return m.Role()
	case winuser.FieldIsPromoter:
		return m.IsPromoter()
	case winuser.FieldFlag:
		return m.Flag()
	case winuser.FieldRealName:
		return m.RealName()
	case winuser.FieldSignature:
		return m.Signature()
	case winuser.FieldBirthday:
		return m.Birthday()
	case winuser.FieldAreaCode:
		return m.AreaCode()
	case winuser.FieldMobile:
		return m.Mobile()
	case winuser.FieldEmail:
		return m.Email()
	case winuser.FieldSex:
		return m.Sex()
	case winuser.FieldBindBank:
		return m.BindBank()
	case winuser.FieldAddress:
		return m.Address()
	case winuser.FieldScore:
		return m.Score()
	case winuser.FieldPromoCode:
		return m.PromoCode()
	case winuser.FieldSupUID1:
		return m.SupUID1()
	case winuser.FieldSupUsername1:
		return m.SupUsername1()
	case winuser.FieldSupUID2:
		return m.SupUID2()
	case winuser.FieldSupUID3:
		return m.SupUID3()
	case winuser.FieldSupUID4:
		return m.SupUID4()
	case winuser.FieldSupUID5:
		return m.SupUID5()
	case winuser.FieldSupUID6:
		return m.SupUID6()
	case winuser.FieldSupUIDTop:
		return m.SupUIDTop()
	case winuser.FieldSupUsernameTop:
		return m.SupUsernameTop()
	case winuser.FieldSupLevelTop:
		return m.SupLevelTop()
	case winuser.FieldPasswordHash:
		return m.PasswordHash()
	case winuser.FieldPasswordCoin:
		return m.PasswordCoin()
	case winuser.FieldIP:
		return m.IP()
	case winuser.FieldIPRegion:
		return m.IPRegion()
	case winuser.FieldThirdLoginType:
		return m.ThirdLoginType()
	case winuser.FieldFreezeCause:
		return m.FreezeCause()
	case winuser.FieldFreezeAt:
		return m.FreezeAt()
	case winuser.FieldOperatorName:
		return m.OperatorName()
	case winuser.FieldCreatedName:
		return m.CreatedName()
	case winuser.FieldStatus:
		return m.Status()
	case winuser.FieldLastLoginIP:
		return m.LastLoginIP()
	case winuser.FieldLastLoginIPRegion:
		return m.LastLoginIPRegion()
	case winuser.FieldLastLoginTime:
		return m.LastLoginTime()
	case winuser.FieldCreatedAt:
		return m.CreatedAt()
	case winuser.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WinUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case winuser.FieldUsername:
		return m.OldUsername(ctx)
	case winuser.FieldAvatar:
		return m.OldAvatar(ctx)
	case winuser.FieldFcoin:
		return m.OldFcoin(ctx)
	case winuser.FieldCoinCommission:
		return m.OldCoinCommission(ctx)
	case winuser.FieldLevelID:
		return m.OldLevelID(ctx)
	case winuser.FieldRole:
		return m.OldRole(ctx)
	case winuser.FieldIsPromoter:
		return m.OldIsPromoter(ctx)
	case winuser.FieldFlag:
		return m.OldFlag(ctx)
	case winuser.FieldRealName:
		return m.OldRealName(ctx)
	case winuser.FieldSignature:
		return m.OldSignature(ctx)
	case winuser.FieldBirthday:
		return m.OldBirthday(ctx)
	case winuser.FieldAreaCode:
		return m.OldAreaCode(ctx)
	case winuser.FieldMobile:
		return m.OldMobile(ctx)
	case winuser.FieldEmail:
		return m.OldEmail(ctx)
	case winuser.FieldSex:
		return m.OldSex(ctx)
	case winuser.FieldBindBank:
		return m.OldBindBank(ctx)
	case winuser.FieldAddress:
		return m.OldAddress(ctx)
	case winuser.FieldScore:
		return m.OldScore(ctx)
	case winuser.FieldPromoCode:
		return m.OldPromoCode(ctx)
	case winuser.FieldSupUID1:
		return m.OldSupUID1(ctx)
	case winuser.FieldSupUsername1:
		return m.OldSupUsername1(ctx)
	case winuser.FieldSupUID2:
		return m.OldSupUID2(ctx)
	case winuser.FieldSupUID3:
		return m.OldSupUID3(ctx)
	case winuser.FieldSupUID4:
		return m.OldSupUID4(ctx)
	case winuser.FieldSupUID5:
		return m.OldSupUID5(ctx)
	case winuser.FieldSupUID6:
		return m.OldSupUID6(ctx)
	case winuser.FieldSupUIDTop:
		return m.OldSupUIDTop(ctx)
	case winuser.FieldSupUsernameTop:
		return m.OldSupUsernameTop(ctx)
	case winuser.FieldSupLevelTop:
		return m.OldSupLevelTop(ctx)
	case winuser.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case winuser.FieldPasswordCoin:
		return m.OldPasswordCoin(ctx)
	case winuser.FieldIP:
		return m.OldIP(ctx)
	case winuser.FieldIPRegion:
		return m.OldIPRegion(ctx)
	case winuser.FieldThirdLoginType:
		return m.OldThirdLoginType(ctx)
	case winuser.FieldFreezeCause:
		return m.OldFreezeCause(ctx)
	case winuser.FieldFreezeAt:
		return m.OldFreezeAt(ctx)
	case winuser.FieldOperatorName:
		return m.OldOperatorName(ctx)
	case winuser.FieldCreatedName:
		return m.OldCreatedName(ctx)
	case winuser.FieldStatus:
		return m.OldStatus(ctx)
	case winuser.FieldLastLoginIP:
		return m.OldLastLoginIP(ctx)
	case winuser.FieldLastLoginIPRegion:
		return m.OldLastLoginIPRegion(ctx)
	case winuser.FieldLastLoginTime:
		return m.OldLastLoginTime(ctx)
	case winuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case winuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WinUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WinUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case winuser.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case winuser.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case winuser.FieldFcoin:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFcoin(v)
		return nil
	case winuser.FieldCoinCommission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinCommission(v)
		return nil
	case winuser.FieldLevelID:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevelID(v)
		return nil
	case winuser.FieldRole:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case winuser.FieldIsPromoter:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPromoter(v)
		return nil
	case winuser.FieldFlag:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlag(v)
		return nil
	case winuser.FieldRealName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRealName(v)
		return nil
	case winuser.FieldSignature:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	case winuser.FieldBirthday:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	case winuser.FieldAreaCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAreaCode(v)
		return nil
	case winuser.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case winuser.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case winuser.FieldSex:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSex(v)
		return nil
	case winuser.FieldBindBank:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBindBank(v)
		return nil
	case winuser.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case winuser.FieldScore:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case winuser.FieldPromoCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromoCode(v)
		return nil
	case winuser.FieldSupUID1:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupUID1(v)
		return nil
	case winuser.FieldSupUsername1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupUsername1(v)
		return nil
	case winuser.FieldSupUID2:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupUID2(v)
		return nil
	case winuser.FieldSupUID3:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupUID3(v)
		return nil
	case winuser.FieldSupUID4:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupUID4(v)
		return nil
	case winuser.FieldSupUID5:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupUID5(v)
		return nil
	case winuser.FieldSupUID6:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupUID6(v)
		return nil
	case winuser.FieldSupUIDTop:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupUIDTop(v)
		return nil
	case winuser.FieldSupUsernameTop:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupUsernameTop(v)
		return nil
	case winuser.FieldSupLevelTop:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupLevelTop(v)
		return nil
	case winuser.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case winuser.FieldPasswordCoin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordCoin(v)
		return nil
	case winuser.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case winuser.FieldIPRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPRegion(v)
		return nil
	case winuser.FieldThirdLoginType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThirdLoginType(v)
		return nil
	case winuser.FieldFreezeCause:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFreezeCause(v)
		return nil
	case winuser.FieldFreezeAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFreezeAt(v)
		return nil
	case winuser.FieldOperatorName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorName(v)
		return nil
	case winuser.FieldCreatedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedName(v)
		return nil
	case winuser.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case winuser.FieldLastLoginIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginIP(v)
		return nil
	case winuser.FieldLastLoginIPRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginIPRegion(v)
		return nil
	case winuser.FieldLastLoginTime:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginTime(v)
		return nil
	case winuser.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case winuser.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WinUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WinUserMutation) AddedFields() []string {
	var fields []string
	if m.addfcoin != nil {
		fields = append(fields, winuser.FieldFcoin)
	}
	if m.addcoin_commission != nil {
		fields = append(fields, winuser.FieldCoinCommission)
	}
	if m.addlevel_id != nil {
		fields = append(fields, winuser.FieldLevelID)
	}
	if m.addrole != nil {
		fields = append(fields, winuser.FieldRole)
	}
	if m.addflag != nil {
		fields = append(fields, winuser.FieldFlag)
	}
	if m.addscore != nil {
		fields = append(fields, winuser.FieldScore)
	}
	if m.addsup_uid_1 != nil {
		fields = append(fields, winuser.FieldSupUID1)
	}
	if m.addsup_uid_2 != nil {
		fields = append(fields, winuser.FieldSupUID2)
	}
	if m.addsup_uid_3 != nil {
		fields = append(fields, winuser.FieldSupUID3)
	}
	if m.addsup_uid_4 != nil {
		fields = append(fields, winuser.FieldSupUID4)
	}
	if m.addsup_uid_5 != nil {
		fields = append(fields, winuser.FieldSupUID5)
	}
	if m.addsup_uid_6 != nil {
		fields = append(fields, winuser.FieldSupUID6)
	}
	if m.addsup_uid_top != nil {
		fields = append(fields, winuser.FieldSupUIDTop)
	}
	if m.addsup_level_top != nil {
		fields = append(fields, winuser.FieldSupLevelTop)
	}
	if m.addfreeze_at != nil {
		fields = append(fields, winuser.FieldFreezeAt)
	}
	if m.addstatus != nil {
		fields = append(fields, winuser.FieldStatus)
	}
	if m.addlast_login_time != nil {
		fields = append(fields, winuser.FieldLastLoginTime)
	}
	if m.addcreated_at != nil {
		fields = append(fields, winuser.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, winuser.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WinUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case winuser.FieldFcoin:
		return m.AddedFcoin()
	case winuser.FieldCoinCommission:
		return m.AddedCoinCommission()
	case winuser.FieldLevelID:
		return m.AddedLevelID()
	case winuser.FieldRole:
		return m.AddedRole()
	case winuser.FieldFlag:
		return m.AddedFlag()
	case winuser.FieldScore:
		return m.AddedScore()
	case winuser.FieldSupUID1:
		return m.AddedSupUID1()
	case winuser.FieldSupUID2:
		return m.AddedSupUID2()
	case winuser.FieldSupUID3:
		return m.AddedSupUID3()
	case winuser.FieldSupUID4:
		return m.AddedSupUID4()
	case winuser.FieldSupUID5:
		return m.AddedSupUID5()
	case winuser.FieldSupUID6:
		return m.AddedSupUID6()
	case winuser.FieldSupUIDTop:
		return m.AddedSupUIDTop()
	case winuser.FieldSupLevelTop:
		return m.AddedSupLevelTop()
	case winuser.FieldFreezeAt:
		return m.AddedFreezeAt()
	case winuser.FieldStatus:
		return m.AddedStatus()
	case winuser.FieldLastLoginTime:
		return m.AddedLastLoginTime()
	case winuser.FieldCreatedAt:
		return m.AddedCreatedAt()
	case winuser.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WinUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case winuser.FieldFcoin:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFcoin(v)
		return nil
	case winuser.FieldCoinCommission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoinCommission(v)
		return nil
	case winuser.FieldLevelID:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevelID(v)
		return nil
	case winuser.FieldRole:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRole(v)
		return nil
	case winuser.FieldFlag:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFlag(v)
		return nil
	case winuser.FieldScore:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	case winuser.FieldSupUID1:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSupUID1(v)
		return nil
	case winuser.FieldSupUID2:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSupUID2(v)
		return nil
	case winuser.FieldSupUID3:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSupUID3(v)
		return nil
	case winuser.FieldSupUID4:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSupUID4(v)
		return nil
	case winuser.FieldSupUID5:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSupUID5(v)
		return nil
	case winuser.FieldSupUID6:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSupUID6(v)
		return nil
	case winuser.FieldSupUIDTop:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSupUIDTop(v)
		return nil
	case winuser.FieldSupLevelTop:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSupLevelTop(v)
		return nil
	case winuser.FieldFreezeAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFreezeAt(v)
		return nil
	case winuser.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case winuser.FieldLastLoginTime:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastLoginTime(v)
		return nil
	case winuser.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case winuser.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WinUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WinUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(winuser.FieldAvatar) {
		fields = append(fields, winuser.FieldAvatar)
	}
	if m.FieldCleared(winuser.FieldBirthday) {
		fields = append(fields, winuser.FieldBirthday)
	}
	if m.FieldCleared(winuser.FieldEmail) {
		fields = append(fields, winuser.FieldEmail)
	}
	if m.FieldCleared(winuser.FieldIPRegion) {
		fields = append(fields, winuser.FieldIPRegion)
	}
	if m.FieldCleared(winuser.FieldFreezeCause) {
		fields = append(fields, winuser.FieldFreezeCause)
	}
	if m.FieldCleared(winuser.FieldFreezeAt) {
		fields = append(fields, winuser.FieldFreezeAt)
	}
	if m.FieldCleared(winuser.FieldOperatorName) {
		fields = append(fields, winuser.FieldOperatorName)
	}
	if m.FieldCleared(winuser.FieldCreatedName) {
		fields = append(fields, winuser.FieldCreatedName)
	}
	if m.FieldCleared(winuser.FieldLastLoginIP) {
		fields = append(fields, winuser.FieldLastLoginIP)
	}
	if m.FieldCleared(winuser.FieldLastLoginIPRegion) {
		fields = append(fields, winuser.FieldLastLoginIPRegion)
	}
	if m.FieldCleared(winuser.FieldLastLoginTime) {
		fields = append(fields, winuser.FieldLastLoginTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WinUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WinUserMutation) ClearField(name string) error {
	switch name {
	case winuser.FieldAvatar:
		m.ClearAvatar()
		return nil
	case winuser.FieldBirthday:
		m.ClearBirthday()
		return nil
	case winuser.FieldEmail:
		m.ClearEmail()
		return nil
	case winuser.FieldIPRegion:
		m.ClearIPRegion()
		return nil
	case winuser.FieldFreezeCause:
		m.ClearFreezeCause()
		return nil
	case winuser.FieldFreezeAt:
		m.ClearFreezeAt()
		return nil
	case winuser.FieldOperatorName:
		m.ClearOperatorName()
		return nil
	case winuser.FieldCreatedName:
		m.ClearCreatedName()
		return nil
	case winuser.FieldLastLoginIP:
		m.ClearLastLoginIP()
		return nil
	case winuser.FieldLastLoginIPRegion:
		m.ClearLastLoginIPRegion()
		return nil
	case winuser.FieldLastLoginTime:
		m.ClearLastLoginTime()
		return nil
	}
	return fmt.Errorf("unknown WinUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WinUserMutation) ResetField(name string) error {
	switch name {
	case winuser.FieldUsername:
		m.ResetUsername()
		return nil
	case winuser.FieldAvatar:
		m.ResetAvatar()
		return nil
	case winuser.FieldFcoin:
		m.ResetFcoin()
		return nil
	case winuser.FieldCoinCommission:
		m.ResetCoinCommission()
		return nil
	case winuser.FieldLevelID:
		m.ResetLevelID()
		return nil
	case winuser.FieldRole:
		m.ResetRole()
		return nil
	case winuser.FieldIsPromoter:
		m.ResetIsPromoter()
		return nil
	case winuser.FieldFlag:
		m.ResetFlag()
		return nil
	case winuser.FieldRealName:
		m.ResetRealName()
		return nil
	case winuser.FieldSignature:
		m.ResetSignature()
		return nil
	case winuser.FieldBirthday:
		m.ResetBirthday()
		return nil
	case winuser.FieldAreaCode:
		m.ResetAreaCode()
		return nil
	case winuser.FieldMobile:
		m.ResetMobile()
		return nil
	case winuser.FieldEmail:
		m.ResetEmail()
		return nil
	case winuser.FieldSex:
		m.ResetSex()
		return nil
	case winuser.FieldBindBank:
		m.ResetBindBank()
		return nil
	case winuser.FieldAddress:
		m.ResetAddress()
		return nil
	case winuser.FieldScore:
		m.ResetScore()
		return nil
	case winuser.FieldPromoCode:
		m.ResetPromoCode()
		return nil
	case winuser.FieldSupUID1:
		m.ResetSupUID1()
		return nil
	case winuser.FieldSupUsername1:
		m.ResetSupUsername1()
		return nil
	case winuser.FieldSupUID2:
		m.ResetSupUID2()
		return nil
	case winuser.FieldSupUID3:
		m.ResetSupUID3()
		return nil
	case winuser.FieldSupUID4:
		m.ResetSupUID4()
		return nil
	case winuser.FieldSupUID5:
		m.ResetSupUID5()
		return nil
	case winuser.FieldSupUID6:
		m.ResetSupUID6()
		return nil
	case winuser.FieldSupUIDTop:
		m.ResetSupUIDTop()
		return nil
	case winuser.FieldSupUsernameTop:
		m.ResetSupUsernameTop()
		return nil
	case winuser.FieldSupLevelTop:
		m.ResetSupLevelTop()
		return nil
	case winuser.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case winuser.FieldPasswordCoin:
		m.ResetPasswordCoin()
		return nil
	case winuser.FieldIP:
		m.ResetIP()
		return nil
	case winuser.FieldIPRegion:
		m.ResetIPRegion()
		return nil
	case winuser.FieldThirdLoginType:
		m.ResetThirdLoginType()
		return nil
	case winuser.FieldFreezeCause:
		m.ResetFreezeCause()
		return nil
	case winuser.FieldFreezeAt:
		m.ResetFreezeAt()
		return nil
	case winuser.FieldOperatorName:
		m.ResetOperatorName()
		return nil
	case winuser.FieldCreatedName:
		m.ResetCreatedName()
		return nil
	case winuser.FieldStatus:
		m.ResetStatus()
		return nil
	case winuser.FieldLastLoginIP:
		m.ResetLastLoginIP()
		return nil
	case winuser.FieldLastLoginIPRegion:
		m.ResetLastLoginIPRegion()
		return nil
	case winuser.FieldLastLoginTime:
		m.ResetLastLoginTime()
		return nil
	case winuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case winuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown WinUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WinUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WinUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WinUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WinUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WinUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WinUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WinUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WinUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WinUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WinUser edge %s", name)
}

// WinUserWalletMutation represents an operation that mutates the WinUserWallet nodes in the graph.
type WinUserWalletMutation struct {
	config
	op            Op
	typ           string
	id            *int32
	username      *string
	coin          *float64
	addcoin       *float64
	version       *int
	addversion    *int
	modify_at     *int
	addmodify_at  *int
	created_at    *int32
	addcreated_at *int32
	updated_at    *int32
	addupdated_at *int32
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WinUserWallet, error)
	predicates    []predicate.WinUserWallet
}

var _ ent.Mutation = (*WinUserWalletMutation)(nil)

// winuserwalletOption allows management of the mutation configuration using functional options.
type winuserwalletOption func(*WinUserWalletMutation)

// newWinUserWalletMutation creates new mutation for the WinUserWallet entity.
func newWinUserWalletMutation(c config, op Op, opts ...winuserwalletOption) *WinUserWalletMutation {
	m := &WinUserWalletMutation{
		config:        c,
		op:            op,
		typ:           TypeWinUserWallet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWinUserWalletID sets the ID field of the mutation.
func withWinUserWalletID(id int32) winuserwalletOption {
	return func(m *WinUserWalletMutation) {
		var (
			err   error
			once  sync.Once
			value *WinUserWallet
		)
		m.oldValue = func(ctx context.Context) (*WinUserWallet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WinUserWallet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWinUserWallet sets the old WinUserWallet of the mutation.
func withWinUserWallet(node *WinUserWallet) winuserwalletOption {
	return func(m *WinUserWalletMutation) {
		m.oldValue = func(context.Context) (*WinUserWallet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WinUserWalletMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WinUserWalletMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WinUserWallet entities.
func (m *WinUserWalletMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WinUserWalletMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WinUserWalletMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WinUserWallet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *WinUserWalletMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *WinUserWalletMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the WinUserWallet entity.
// If the WinUserWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserWalletMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *WinUserWalletMutation) ResetUsername() {
	m.username = nil
}

// SetCoin sets the "coin" field.
func (m *WinUserWalletMutation) SetCoin(f float64) {
	m.coin = &f
	m.addcoin = nil
}

// Coin returns the value of the "coin" field in the mutation.
func (m *WinUserWalletMutation) Coin() (r float64, exists bool) {
	v := m.coin
	if v == nil {
		return
	}
	return *v, true
}

// OldCoin returns the old "coin" field's value of the WinUserWallet entity.
// If the WinUserWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserWalletMutation) OldCoin(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoin: %w", err)
	}
	return oldValue.Coin, nil
}

// AddCoin adds f to the "coin" field.
func (m *WinUserWalletMutation) AddCoin(f float64) {
	if m.addcoin != nil {
		*m.addcoin += f
	} else {
		m.addcoin = &f
	}
}

// AddedCoin returns the value that was added to the "coin" field in this mutation.
func (m *WinUserWalletMutation) AddedCoin() (r float64, exists bool) {
	v := m.addcoin
	if v == nil {
		return
	}
	return *v, true
}

// ResetCoin resets all changes to the "coin" field.
func (m *WinUserWalletMutation) ResetCoin() {
	m.coin = nil
	m.addcoin = nil
}

// SetVersion sets the "version" field.
func (m *WinUserWalletMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *WinUserWalletMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the WinUserWallet entity.
// If the WinUserWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserWalletMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *WinUserWalletMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *WinUserWalletMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ClearVersion clears the value of the "version" field.
func (m *WinUserWalletMutation) ClearVersion() {
	m.version = nil
	m.addversion = nil
	m.clearedFields[winuserwallet.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *WinUserWalletMutation) VersionCleared() bool {
	_, ok := m.clearedFields[winuserwallet.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *WinUserWalletMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
	delete(m.clearedFields, winuserwallet.FieldVersion)
}

// SetModifyAt sets the "modify_at" field.
func (m *WinUserWalletMutation) SetModifyAt(i int) {
	m.modify_at = &i
	m.addmodify_at = nil
}

// ModifyAt returns the value of the "modify_at" field in the mutation.
func (m *WinUserWalletMutation) ModifyAt() (r int, exists bool) {
	v := m.modify_at
	if v == nil {
		return
	}
	return *v, true
}

// OldModifyAt returns the old "modify_at" field's value of the WinUserWallet entity.
// If the WinUserWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserWalletMutation) OldModifyAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifyAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifyAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifyAt: %w", err)
	}
	return oldValue.ModifyAt, nil
}

// AddModifyAt adds i to the "modify_at" field.
func (m *WinUserWalletMutation) AddModifyAt(i int) {
	if m.addmodify_at != nil {
		*m.addmodify_at += i
	} else {
		m.addmodify_at = &i
	}
}

// AddedModifyAt returns the value that was added to the "modify_at" field in this mutation.
func (m *WinUserWalletMutation) AddedModifyAt() (r int, exists bool) {
	v := m.addmodify_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetModifyAt resets all changes to the "modify_at" field.
func (m *WinUserWalletMutation) ResetModifyAt() {
	m.modify_at = nil
	m.addmodify_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WinUserWalletMutation) SetCreatedAt(i int32) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WinUserWalletMutation) CreatedAt() (r int32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WinUserWallet entity.
// If the WinUserWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserWalletMutation) OldCreatedAt(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *WinUserWalletMutation) AddCreatedAt(i int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *WinUserWalletMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WinUserWalletMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WinUserWalletMutation) SetUpdatedAt(i int32) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WinUserWalletMutation) UpdatedAt() (r int32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WinUserWallet entity.
// If the WinUserWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WinUserWalletMutation) OldUpdatedAt(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *WinUserWalletMutation) AddUpdatedAt(i int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *WinUserWalletMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WinUserWalletMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// Where appends a list predicates to the WinUserWalletMutation builder.
func (m *WinUserWalletMutation) Where(ps ...predicate.WinUserWallet) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WinUserWalletMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WinUserWalletMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WinUserWallet, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WinUserWalletMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WinUserWalletMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WinUserWallet).
func (m *WinUserWalletMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WinUserWalletMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.username != nil {
		fields = append(fields, winuserwallet.FieldUsername)
	}
	if m.coin != nil {
		fields = append(fields, winuserwallet.FieldCoin)
	}
	if m.version != nil {
		fields = append(fields, winuserwallet.FieldVersion)
	}
	if m.modify_at != nil {
		fields = append(fields, winuserwallet.FieldModifyAt)
	}
	if m.created_at != nil {
		fields = append(fields, winuserwallet.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, winuserwallet.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WinUserWalletMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case winuserwallet.FieldUsername:
		return m.Username()
	case winuserwallet.FieldCoin:
		return m.Coin()
	case winuserwallet.FieldVersion:
		return m.Version()
	case winuserwallet.FieldModifyAt:
		return m.ModifyAt()
	case winuserwallet.FieldCreatedAt:
		return m.CreatedAt()
	case winuserwallet.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WinUserWalletMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case winuserwallet.FieldUsername:
		return m.OldUsername(ctx)
	case winuserwallet.FieldCoin:
		return m.OldCoin(ctx)
	case winuserwallet.FieldVersion:
		return m.OldVersion(ctx)
	case winuserwallet.FieldModifyAt:
		return m.OldModifyAt(ctx)
	case winuserwallet.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case winuserwallet.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WinUserWallet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WinUserWalletMutation) SetField(name string, value ent.Value) error {
	switch name {
	case winuserwallet.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case winuserwallet.FieldCoin:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoin(v)
		return nil
	case winuserwallet.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case winuserwallet.FieldModifyAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifyAt(v)
		return nil
	case winuserwallet.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case winuserwallet.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WinUserWallet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WinUserWalletMutation) AddedFields() []string {
	var fields []string
	if m.addcoin != nil {
		fields = append(fields, winuserwallet.FieldCoin)
	}
	if m.addversion != nil {
		fields = append(fields, winuserwallet.FieldVersion)
	}
	if m.addmodify_at != nil {
		fields = append(fields, winuserwallet.FieldModifyAt)
	}
	if m.addcreated_at != nil {
		fields = append(fields, winuserwallet.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, winuserwallet.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WinUserWalletMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case winuserwallet.FieldCoin:
		return m.AddedCoin()
	case winuserwallet.FieldVersion:
		return m.AddedVersion()
	case winuserwallet.FieldModifyAt:
		return m.AddedModifyAt()
	case winuserwallet.FieldCreatedAt:
		return m.AddedCreatedAt()
	case winuserwallet.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WinUserWalletMutation) AddField(name string, value ent.Value) error {
	switch name {
	case winuserwallet.FieldCoin:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoin(v)
		return nil
	case winuserwallet.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case winuserwallet.FieldModifyAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddModifyAt(v)
		return nil
	case winuserwallet.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case winuserwallet.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WinUserWallet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WinUserWalletMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(winuserwallet.FieldVersion) {
		fields = append(fields, winuserwallet.FieldVersion)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WinUserWalletMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WinUserWalletMutation) ClearField(name string) error {
	switch name {
	case winuserwallet.FieldVersion:
		m.ClearVersion()
		return nil
	}
	return fmt.Errorf("unknown WinUserWallet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WinUserWalletMutation) ResetField(name string) error {
	switch name {
	case winuserwallet.FieldUsername:
		m.ResetUsername()
		return nil
	case winuserwallet.FieldCoin:
		m.ResetCoin()
		return nil
	case winuserwallet.FieldVersion:
		m.ResetVersion()
		return nil
	case winuserwallet.FieldModifyAt:
		m.ResetModifyAt()
		return nil
	case winuserwallet.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case winuserwallet.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown WinUserWallet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WinUserWalletMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WinUserWalletMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WinUserWalletMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WinUserWalletMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WinUserWalletMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WinUserWalletMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WinUserWalletMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WinUserWallet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WinUserWalletMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WinUserWallet edge %s", name)
}
