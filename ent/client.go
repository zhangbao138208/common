// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"strings"

	"gitlab.skig.tech/zero-core/common/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"gitlab.skig.tech/zero-core/common/ent/common"
	"gitlab.skig.tech/zero-core/common/ent/winbetslip"
	"gitlab.skig.tech/zero-core/common/ent/winbetslipsdetail"
	"gitlab.skig.tech/zero-core/common/ent/wincoinlog"
	"gitlab.skig.tech/zero-core/common/ent/winconfig"
	"gitlab.skig.tech/zero-core/common/ent/windict"
	"gitlab.skig.tech/zero-core/common/ent/windictitem"
	"gitlab.skig.tech/zero-core/common/ent/wingamelist"
	"gitlab.skig.tech/zero-core/common/ent/wingameslot"
	"gitlab.skig.tech/zero-core/common/ent/winplatlist"
	"gitlab.skig.tech/zero-core/common/ent/winuser"
	"gitlab.skig.tech/zero-core/common/ent/winuserwallet"

	stdsql "database/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Common is the client for interacting with the Common builders.
	Common *CommonClient
	// WinBetslip is the client for interacting with the WinBetslip builders.
	WinBetslip *WinBetslipClient
	// WinBetslipsDetail is the client for interacting with the WinBetslipsDetail builders.
	WinBetslipsDetail *WinBetslipsDetailClient
	// WinCoinLog is the client for interacting with the WinCoinLog builders.
	WinCoinLog *WinCoinLogClient
	// WinConfig is the client for interacting with the WinConfig builders.
	WinConfig *WinConfigClient
	// WinDict is the client for interacting with the WinDict builders.
	WinDict *WinDictClient
	// WinDictItem is the client for interacting with the WinDictItem builders.
	WinDictItem *WinDictItemClient
	// WinGameList is the client for interacting with the WinGameList builders.
	WinGameList *WinGameListClient
	// WinGameSlot is the client for interacting with the WinGameSlot builders.
	WinGameSlot *WinGameSlotClient
	// WinPlatList is the client for interacting with the WinPlatList builders.
	WinPlatList *WinPlatListClient
	// WinUser is the client for interacting with the WinUser builders.
	WinUser *WinUserClient
	// WinUserWallet is the client for interacting with the WinUserWallet builders.
	WinUserWallet *WinUserWalletClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Common = NewCommonClient(c.config)
	c.WinBetslip = NewWinBetslipClient(c.config)
	c.WinBetslipsDetail = NewWinBetslipsDetailClient(c.config)
	c.WinCoinLog = NewWinCoinLogClient(c.config)
	c.WinConfig = NewWinConfigClient(c.config)
	c.WinDict = NewWinDictClient(c.config)
	c.WinDictItem = NewWinDictItemClient(c.config)
	c.WinGameList = NewWinGameListClient(c.config)
	c.WinGameSlot = NewWinGameSlotClient(c.config)
	c.WinPlatList = NewWinPlatListClient(c.config)
	c.WinUser = NewWinUserClient(c.config)
	c.WinUserWallet = NewWinUserWalletClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// ExecContext allows calling the underlying ExecContext method of the driver if it is supported by it.
// See, database/sql#DB.ExecContext for more information.
func (c *config) ExecContext(ctx context.Context, query string, args ...any) (stdsql.Result, error) {
	ex, ok := c.driver.(interface {
		ExecContext(context.Context, string, ...any) (stdsql.Result, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.ExecContext is not supported")
	}
	return ex.ExecContext(ctx, query, args...)
}

// QueryContext allows calling the underlying QueryContext method of the driver if it is supported by it.
// See, database/sql#DB.QueryContext for more information.
func (c *config) QueryContext(ctx context.Context, query string, args ...any) (*stdsql.Rows, error) {
	q, ok := c.driver.(interface {
		QueryContext(context.Context, string, ...any) (*stdsql.Rows, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.QueryContext is not supported")
	}
	return q.QueryContext(ctx, query, args...)
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		Common:            NewCommonClient(cfg),
		WinBetslip:        NewWinBetslipClient(cfg),
		WinBetslipsDetail: NewWinBetslipsDetailClient(cfg),
		WinCoinLog:        NewWinCoinLogClient(cfg),
		WinConfig:         NewWinConfigClient(cfg),
		WinDict:           NewWinDictClient(cfg),
		WinDictItem:       NewWinDictItemClient(cfg),
		WinGameList:       NewWinGameListClient(cfg),
		WinGameSlot:       NewWinGameSlotClient(cfg),
		WinPlatList:       NewWinPlatListClient(cfg),
		WinUser:           NewWinUserClient(cfg),
		WinUserWallet:     NewWinUserWalletClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		Common:            NewCommonClient(cfg),
		WinBetslip:        NewWinBetslipClient(cfg),
		WinBetslipsDetail: NewWinBetslipsDetailClient(cfg),
		WinCoinLog:        NewWinCoinLogClient(cfg),
		WinConfig:         NewWinConfigClient(cfg),
		WinDict:           NewWinDictClient(cfg),
		WinDictItem:       NewWinDictItemClient(cfg),
		WinGameList:       NewWinGameListClient(cfg),
		WinGameSlot:       NewWinGameSlotClient(cfg),
		WinPlatList:       NewWinPlatListClient(cfg),
		WinUser:           NewWinUserClient(cfg),
		WinUserWallet:     NewWinUserWalletClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Common.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Common, c.WinBetslip, c.WinBetslipsDetail, c.WinCoinLog, c.WinConfig,
		c.WinDict, c.WinDictItem, c.WinGameList, c.WinGameSlot, c.WinPlatList,
		c.WinUser, c.WinUserWallet,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Common, c.WinBetslip, c.WinBetslipsDetail, c.WinCoinLog, c.WinConfig,
		c.WinDict, c.WinDictItem, c.WinGameList, c.WinGameSlot, c.WinPlatList,
		c.WinUser, c.WinUserWallet,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *CommonMutation:
		return c.Common.mutate(ctx, m)
	case *WinBetslipMutation:
		return c.WinBetslip.mutate(ctx, m)
	case *WinBetslipsDetailMutation:
		return c.WinBetslipsDetail.mutate(ctx, m)
	case *WinCoinLogMutation:
		return c.WinCoinLog.mutate(ctx, m)
	case *WinConfigMutation:
		return c.WinConfig.mutate(ctx, m)
	case *WinDictMutation:
		return c.WinDict.mutate(ctx, m)
	case *WinDictItemMutation:
		return c.WinDictItem.mutate(ctx, m)
	case *WinGameListMutation:
		return c.WinGameList.mutate(ctx, m)
	case *WinGameSlotMutation:
		return c.WinGameSlot.mutate(ctx, m)
	case *WinPlatListMutation:
		return c.WinPlatList.mutate(ctx, m)
	case *WinUserMutation:
		return c.WinUser.mutate(ctx, m)
	case *WinUserWalletMutation:
		return c.WinUserWallet.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// CommonClient is a client for the Common schema.
type CommonClient struct {
	config
}

// CreateManyOnConflict by CommonCreate slice
func (c *CommonClient) CreateManyOnConflict(ctx context.Context, objs []*CommonCreate, extra string, ignore bool) error {
	tx, err := c.config.driver.Tx(ctx)
	if err != nil {
		return err
	}
	sIndex := 0
	if objs[0].mutation.id == nil {
		sIndex = 1
	}
	//columns := common.Columns[sIndex:]
	var columns []string
	//inserter := sql.Insert(common.Table).Columns(columns...)
	inserter := sql.Insert(common.Table)
	for i, obj := range objs {
		//obj.defaults()

		values := []interface{}{}
		_, spec := obj.createSpec()
		if sIndex == 0 {
			values = append(values, spec.ID.Value)
			if i == 0 {
				columns = append(columns, spec.ID.Column)
			}
		}
		for _, field := range spec.Fields {
			values = append(values, field.Value)
			if i == 0 {
				columns = append(columns, field.Column)
			}
		}
		if len(values) != len(columns) {
			//return errors.New("CreateManyOnConflict common: Columns length not match")
		}
		inserter.Values(values...)
	}
	inserter.Columns(columns...)
	var res sql.Result
	sql, args := inserter.Query()
	if ignore {
		sql = strings.Replace(sql, "INSERT INTO", "INSERT IGNORE INTO", 1)
	}
	sql = sql + " " + extra
	if err := tx.Exec(ctx, sql, args, &res); err != nil {
		if err_roll := tx.Rollback(); err_roll != nil {
			return errors.New(err.Error() + "\n" + err_roll.Error())
		}
		return err
	}
	return tx.Commit()
}

// NewCommonClient returns a client for the Common from the given config.
func NewCommonClient(c config) *CommonClient {
	return &CommonClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `common.Hooks(f(g(h())))`.
func (c *CommonClient) Use(hooks ...Hook) {
	c.hooks.Common = append(c.hooks.Common, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `common.Intercept(f(g(h())))`.
func (c *CommonClient) Intercept(interceptors ...Interceptor) {
	c.inters.Common = append(c.inters.Common, interceptors...)
}

// Create returns a builder for creating a Common entity.
func (c *CommonClient) Create() *CommonCreate {
	mutation := newCommonMutation(c.config, OpCreate)
	return &CommonCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Common entities.
func (c *CommonClient) CreateBulk(builders ...*CommonCreate) *CommonCreateBulk {
	return &CommonCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Common.
func (c *CommonClient) Update() *CommonUpdate {
	mutation := newCommonMutation(c.config, OpUpdate)
	return &CommonUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CommonClient) UpdateOne(co *Common) *CommonUpdateOne {
	mutation := newCommonMutation(c.config, OpUpdateOne, withCommon(co))
	return &CommonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CommonClient) UpdateOneID(id int) *CommonUpdateOne {
	mutation := newCommonMutation(c.config, OpUpdateOne, withCommonID(id))
	return &CommonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Common.
func (c *CommonClient) Delete() *CommonDelete {
	mutation := newCommonMutation(c.config, OpDelete)
	return &CommonDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CommonClient) DeleteOne(co *Common) *CommonDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CommonClient) DeleteOneID(id int) *CommonDeleteOne {
	builder := c.Delete().Where(common.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CommonDeleteOne{builder}
}

// Query returns a query builder for Common.
func (c *CommonClient) Query() *CommonQuery {
	return &CommonQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCommon},
		inters: c.Interceptors(),
	}
}

// Get returns a Common entity by its id.
func (c *CommonClient) Get(ctx context.Context, id int) (*Common, error) {
	return c.Query().Where(common.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CommonClient) GetX(ctx context.Context, id int) *Common {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CommonClient) Hooks() []Hook {
	return c.hooks.Common
}

// Interceptors returns the client interceptors.
func (c *CommonClient) Interceptors() []Interceptor {
	return c.inters.Common
}

func (c *CommonClient) mutate(ctx context.Context, m *CommonMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CommonCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CommonUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CommonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CommonDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Common mutation op: %q", m.Op())
	}
}

// WinBetslipClient is a client for the WinBetslip schema.
type WinBetslipClient struct {
	config
}

// CreateManyOnConflict by WinBetslipCreate slice
func (c *WinBetslipClient) CreateManyOnConflict(ctx context.Context, objs []*WinBetslipCreate, extra string, ignore bool) error {
	tx, err := c.config.driver.Tx(ctx)
	if err != nil {
		return err
	}
	sIndex := 0
	if objs[0].mutation.id == nil {
		sIndex = 1
	}
	//columns := winbetslip.Columns[sIndex:]
	var columns []string
	//inserter := sql.Insert(winbetslip.Table).Columns(columns...)
	inserter := sql.Insert(winbetslip.Table)
	for i, obj := range objs {
		//obj.defaults()

		values := []interface{}{}
		_, spec := obj.createSpec()
		if sIndex == 0 {
			values = append(values, spec.ID.Value)
			if i == 0 {
				columns = append(columns, spec.ID.Column)
			}
		}
		for _, field := range spec.Fields {
			values = append(values, field.Value)
			if i == 0 {
				columns = append(columns, field.Column)
			}
		}
		if len(values) != len(columns) {
			//return errors.New("CreateManyOnConflict winbetslip: Columns length not match")
		}
		inserter.Values(values...)
	}
	inserter.Columns(columns...)
	var res sql.Result
	sql, args := inserter.Query()
	if ignore {
		sql = strings.Replace(sql, "INSERT INTO", "INSERT IGNORE INTO", 1)
	}
	sql = sql + " " + extra
	if err := tx.Exec(ctx, sql, args, &res); err != nil {
		if err_roll := tx.Rollback(); err_roll != nil {
			return errors.New(err.Error() + "\n" + err_roll.Error())
		}
		return err
	}
	return tx.Commit()
}

// NewWinBetslipClient returns a client for the WinBetslip from the given config.
func NewWinBetslipClient(c config) *WinBetslipClient {
	return &WinBetslipClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `winbetslip.Hooks(f(g(h())))`.
func (c *WinBetslipClient) Use(hooks ...Hook) {
	c.hooks.WinBetslip = append(c.hooks.WinBetslip, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `winbetslip.Intercept(f(g(h())))`.
func (c *WinBetslipClient) Intercept(interceptors ...Interceptor) {
	c.inters.WinBetslip = append(c.inters.WinBetslip, interceptors...)
}

// Create returns a builder for creating a WinBetslip entity.
func (c *WinBetslipClient) Create() *WinBetslipCreate {
	mutation := newWinBetslipMutation(c.config, OpCreate)
	return &WinBetslipCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WinBetslip entities.
func (c *WinBetslipClient) CreateBulk(builders ...*WinBetslipCreate) *WinBetslipCreateBulk {
	return &WinBetslipCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WinBetslip.
func (c *WinBetslipClient) Update() *WinBetslipUpdate {
	mutation := newWinBetslipMutation(c.config, OpUpdate)
	return &WinBetslipUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WinBetslipClient) UpdateOne(wb *WinBetslip) *WinBetslipUpdateOne {
	mutation := newWinBetslipMutation(c.config, OpUpdateOne, withWinBetslip(wb))
	return &WinBetslipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WinBetslipClient) UpdateOneID(id int) *WinBetslipUpdateOne {
	mutation := newWinBetslipMutation(c.config, OpUpdateOne, withWinBetslipID(id))
	return &WinBetslipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WinBetslip.
func (c *WinBetslipClient) Delete() *WinBetslipDelete {
	mutation := newWinBetslipMutation(c.config, OpDelete)
	return &WinBetslipDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WinBetslipClient) DeleteOne(wb *WinBetslip) *WinBetslipDeleteOne {
	return c.DeleteOneID(wb.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WinBetslipClient) DeleteOneID(id int) *WinBetslipDeleteOne {
	builder := c.Delete().Where(winbetslip.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WinBetslipDeleteOne{builder}
}

// Query returns a query builder for WinBetslip.
func (c *WinBetslipClient) Query() *WinBetslipQuery {
	return &WinBetslipQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWinBetslip},
		inters: c.Interceptors(),
	}
}

// Get returns a WinBetslip entity by its id.
func (c *WinBetslipClient) Get(ctx context.Context, id int) (*WinBetslip, error) {
	return c.Query().Where(winbetslip.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WinBetslipClient) GetX(ctx context.Context, id int) *WinBetslip {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WinBetslipClient) Hooks() []Hook {
	return c.hooks.WinBetslip
}

// Interceptors returns the client interceptors.
func (c *WinBetslipClient) Interceptors() []Interceptor {
	return c.inters.WinBetslip
}

func (c *WinBetslipClient) mutate(ctx context.Context, m *WinBetslipMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WinBetslipCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WinBetslipUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WinBetslipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WinBetslipDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WinBetslip mutation op: %q", m.Op())
	}
}

// WinBetslipsDetailClient is a client for the WinBetslipsDetail schema.
type WinBetslipsDetailClient struct {
	config
}

// CreateManyOnConflict by WinBetslipsDetailCreate slice
func (c *WinBetslipsDetailClient) CreateManyOnConflict(ctx context.Context, objs []*WinBetslipsDetailCreate, extra string, ignore bool) error {
	tx, err := c.config.driver.Tx(ctx)
	if err != nil {
		return err
	}
	sIndex := 0
	if objs[0].mutation.id == nil {
		sIndex = 1
	}
	//columns := winbetslipsdetail.Columns[sIndex:]
	var columns []string
	//inserter := sql.Insert(winbetslipsdetail.Table).Columns(columns...)
	inserter := sql.Insert(winbetslipsdetail.Table)
	for i, obj := range objs {
		//obj.defaults()

		values := []interface{}{}
		_, spec := obj.createSpec()
		if sIndex == 0 {
			values = append(values, spec.ID.Value)
			if i == 0 {
				columns = append(columns, spec.ID.Column)
			}
		}
		for _, field := range spec.Fields {
			values = append(values, field.Value)
			if i == 0 {
				columns = append(columns, field.Column)
			}
		}
		if len(values) != len(columns) {
			//return errors.New("CreateManyOnConflict winbetslipsdetail: Columns length not match")
		}
		inserter.Values(values...)
	}
	inserter.Columns(columns...)
	var res sql.Result
	sql, args := inserter.Query()
	if ignore {
		sql = strings.Replace(sql, "INSERT INTO", "INSERT IGNORE INTO", 1)
	}
	sql = sql + " " + extra
	if err := tx.Exec(ctx, sql, args, &res); err != nil {
		if err_roll := tx.Rollback(); err_roll != nil {
			return errors.New(err.Error() + "\n" + err_roll.Error())
		}
		return err
	}
	return tx.Commit()
}

// NewWinBetslipsDetailClient returns a client for the WinBetslipsDetail from the given config.
func NewWinBetslipsDetailClient(c config) *WinBetslipsDetailClient {
	return &WinBetslipsDetailClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `winbetslipsdetail.Hooks(f(g(h())))`.
func (c *WinBetslipsDetailClient) Use(hooks ...Hook) {
	c.hooks.WinBetslipsDetail = append(c.hooks.WinBetslipsDetail, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `winbetslipsdetail.Intercept(f(g(h())))`.
func (c *WinBetslipsDetailClient) Intercept(interceptors ...Interceptor) {
	c.inters.WinBetslipsDetail = append(c.inters.WinBetslipsDetail, interceptors...)
}

// Create returns a builder for creating a WinBetslipsDetail entity.
func (c *WinBetslipsDetailClient) Create() *WinBetslipsDetailCreate {
	mutation := newWinBetslipsDetailMutation(c.config, OpCreate)
	return &WinBetslipsDetailCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WinBetslipsDetail entities.
func (c *WinBetslipsDetailClient) CreateBulk(builders ...*WinBetslipsDetailCreate) *WinBetslipsDetailCreateBulk {
	return &WinBetslipsDetailCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WinBetslipsDetail.
func (c *WinBetslipsDetailClient) Update() *WinBetslipsDetailUpdate {
	mutation := newWinBetslipsDetailMutation(c.config, OpUpdate)
	return &WinBetslipsDetailUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WinBetslipsDetailClient) UpdateOne(wbd *WinBetslipsDetail) *WinBetslipsDetailUpdateOne {
	mutation := newWinBetslipsDetailMutation(c.config, OpUpdateOne, withWinBetslipsDetail(wbd))
	return &WinBetslipsDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WinBetslipsDetailClient) UpdateOneID(id int) *WinBetslipsDetailUpdateOne {
	mutation := newWinBetslipsDetailMutation(c.config, OpUpdateOne, withWinBetslipsDetailID(id))
	return &WinBetslipsDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WinBetslipsDetail.
func (c *WinBetslipsDetailClient) Delete() *WinBetslipsDetailDelete {
	mutation := newWinBetslipsDetailMutation(c.config, OpDelete)
	return &WinBetslipsDetailDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WinBetslipsDetailClient) DeleteOne(wbd *WinBetslipsDetail) *WinBetslipsDetailDeleteOne {
	return c.DeleteOneID(wbd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WinBetslipsDetailClient) DeleteOneID(id int) *WinBetslipsDetailDeleteOne {
	builder := c.Delete().Where(winbetslipsdetail.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WinBetslipsDetailDeleteOne{builder}
}

// Query returns a query builder for WinBetslipsDetail.
func (c *WinBetslipsDetailClient) Query() *WinBetslipsDetailQuery {
	return &WinBetslipsDetailQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWinBetslipsDetail},
		inters: c.Interceptors(),
	}
}

// Get returns a WinBetslipsDetail entity by its id.
func (c *WinBetslipsDetailClient) Get(ctx context.Context, id int) (*WinBetslipsDetail, error) {
	return c.Query().Where(winbetslipsdetail.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WinBetslipsDetailClient) GetX(ctx context.Context, id int) *WinBetslipsDetail {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WinBetslipsDetailClient) Hooks() []Hook {
	return c.hooks.WinBetslipsDetail
}

// Interceptors returns the client interceptors.
func (c *WinBetslipsDetailClient) Interceptors() []Interceptor {
	return c.inters.WinBetslipsDetail
}

func (c *WinBetslipsDetailClient) mutate(ctx context.Context, m *WinBetslipsDetailMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WinBetslipsDetailCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WinBetslipsDetailUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WinBetslipsDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WinBetslipsDetailDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WinBetslipsDetail mutation op: %q", m.Op())
	}
}

// WinCoinLogClient is a client for the WinCoinLog schema.
type WinCoinLogClient struct {
	config
}

// CreateManyOnConflict by WinCoinLogCreate slice
func (c *WinCoinLogClient) CreateManyOnConflict(ctx context.Context, objs []*WinCoinLogCreate, extra string, ignore bool) error {
	tx, err := c.config.driver.Tx(ctx)
	if err != nil {
		return err
	}
	sIndex := 0
	if objs[0].mutation.id == nil {
		sIndex = 1
	}
	//columns := wincoinlog.Columns[sIndex:]
	var columns []string
	//inserter := sql.Insert(wincoinlog.Table).Columns(columns...)
	inserter := sql.Insert(wincoinlog.Table)
	for i, obj := range objs {
		//obj.defaults()

		values := []interface{}{}
		_, spec := obj.createSpec()
		if sIndex == 0 {
			values = append(values, spec.ID.Value)
			if i == 0 {
				columns = append(columns, spec.ID.Column)
			}
		}
		for _, field := range spec.Fields {
			values = append(values, field.Value)
			if i == 0 {
				columns = append(columns, field.Column)
			}
		}
		if len(values) != len(columns) {
			//return errors.New("CreateManyOnConflict wincoinlog: Columns length not match")
		}
		inserter.Values(values...)
	}
	inserter.Columns(columns...)
	var res sql.Result
	sql, args := inserter.Query()
	if ignore {
		sql = strings.Replace(sql, "INSERT INTO", "INSERT IGNORE INTO", 1)
	}
	sql = sql + " " + extra
	if err := tx.Exec(ctx, sql, args, &res); err != nil {
		if err_roll := tx.Rollback(); err_roll != nil {
			return errors.New(err.Error() + "\n" + err_roll.Error())
		}
		return err
	}
	return tx.Commit()
}

// NewWinCoinLogClient returns a client for the WinCoinLog from the given config.
func NewWinCoinLogClient(c config) *WinCoinLogClient {
	return &WinCoinLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `wincoinlog.Hooks(f(g(h())))`.
func (c *WinCoinLogClient) Use(hooks ...Hook) {
	c.hooks.WinCoinLog = append(c.hooks.WinCoinLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `wincoinlog.Intercept(f(g(h())))`.
func (c *WinCoinLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.WinCoinLog = append(c.inters.WinCoinLog, interceptors...)
}

// Create returns a builder for creating a WinCoinLog entity.
func (c *WinCoinLogClient) Create() *WinCoinLogCreate {
	mutation := newWinCoinLogMutation(c.config, OpCreate)
	return &WinCoinLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WinCoinLog entities.
func (c *WinCoinLogClient) CreateBulk(builders ...*WinCoinLogCreate) *WinCoinLogCreateBulk {
	return &WinCoinLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WinCoinLog.
func (c *WinCoinLogClient) Update() *WinCoinLogUpdate {
	mutation := newWinCoinLogMutation(c.config, OpUpdate)
	return &WinCoinLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WinCoinLogClient) UpdateOne(wcl *WinCoinLog) *WinCoinLogUpdateOne {
	mutation := newWinCoinLogMutation(c.config, OpUpdateOne, withWinCoinLog(wcl))
	return &WinCoinLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WinCoinLogClient) UpdateOneID(id int) *WinCoinLogUpdateOne {
	mutation := newWinCoinLogMutation(c.config, OpUpdateOne, withWinCoinLogID(id))
	return &WinCoinLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WinCoinLog.
func (c *WinCoinLogClient) Delete() *WinCoinLogDelete {
	mutation := newWinCoinLogMutation(c.config, OpDelete)
	return &WinCoinLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WinCoinLogClient) DeleteOne(wcl *WinCoinLog) *WinCoinLogDeleteOne {
	return c.DeleteOneID(wcl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WinCoinLogClient) DeleteOneID(id int) *WinCoinLogDeleteOne {
	builder := c.Delete().Where(wincoinlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WinCoinLogDeleteOne{builder}
}

// Query returns a query builder for WinCoinLog.
func (c *WinCoinLogClient) Query() *WinCoinLogQuery {
	return &WinCoinLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWinCoinLog},
		inters: c.Interceptors(),
	}
}

// Get returns a WinCoinLog entity by its id.
func (c *WinCoinLogClient) Get(ctx context.Context, id int) (*WinCoinLog, error) {
	return c.Query().Where(wincoinlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WinCoinLogClient) GetX(ctx context.Context, id int) *WinCoinLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WinCoinLogClient) Hooks() []Hook {
	return c.hooks.WinCoinLog
}

// Interceptors returns the client interceptors.
func (c *WinCoinLogClient) Interceptors() []Interceptor {
	return c.inters.WinCoinLog
}

func (c *WinCoinLogClient) mutate(ctx context.Context, m *WinCoinLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WinCoinLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WinCoinLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WinCoinLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WinCoinLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WinCoinLog mutation op: %q", m.Op())
	}
}

// WinConfigClient is a client for the WinConfig schema.
type WinConfigClient struct {
	config
}

// CreateManyOnConflict by WinConfigCreate slice
func (c *WinConfigClient) CreateManyOnConflict(ctx context.Context, objs []*WinConfigCreate, extra string, ignore bool) error {
	tx, err := c.config.driver.Tx(ctx)
	if err != nil {
		return err
	}
	sIndex := 0
	if objs[0].mutation.id == nil {
		sIndex = 1
	}
	//columns := winconfig.Columns[sIndex:]
	var columns []string
	//inserter := sql.Insert(winconfig.Table).Columns(columns...)
	inserter := sql.Insert(winconfig.Table)
	for i, obj := range objs {
		//obj.defaults()

		values := []interface{}{}
		_, spec := obj.createSpec()
		if sIndex == 0 {
			values = append(values, spec.ID.Value)
			if i == 0 {
				columns = append(columns, spec.ID.Column)
			}
		}
		for _, field := range spec.Fields {
			values = append(values, field.Value)
			if i == 0 {
				columns = append(columns, field.Column)
			}
		}
		if len(values) != len(columns) {
			//return errors.New("CreateManyOnConflict winconfig: Columns length not match")
		}
		inserter.Values(values...)
	}
	inserter.Columns(columns...)
	var res sql.Result
	sql, args := inserter.Query()
	if ignore {
		sql = strings.Replace(sql, "INSERT INTO", "INSERT IGNORE INTO", 1)
	}
	sql = sql + " " + extra
	if err := tx.Exec(ctx, sql, args, &res); err != nil {
		if err_roll := tx.Rollback(); err_roll != nil {
			return errors.New(err.Error() + "\n" + err_roll.Error())
		}
		return err
	}
	return tx.Commit()
}

// NewWinConfigClient returns a client for the WinConfig from the given config.
func NewWinConfigClient(c config) *WinConfigClient {
	return &WinConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `winconfig.Hooks(f(g(h())))`.
func (c *WinConfigClient) Use(hooks ...Hook) {
	c.hooks.WinConfig = append(c.hooks.WinConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `winconfig.Intercept(f(g(h())))`.
func (c *WinConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.WinConfig = append(c.inters.WinConfig, interceptors...)
}

// Create returns a builder for creating a WinConfig entity.
func (c *WinConfigClient) Create() *WinConfigCreate {
	mutation := newWinConfigMutation(c.config, OpCreate)
	return &WinConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WinConfig entities.
func (c *WinConfigClient) CreateBulk(builders ...*WinConfigCreate) *WinConfigCreateBulk {
	return &WinConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WinConfig.
func (c *WinConfigClient) Update() *WinConfigUpdate {
	mutation := newWinConfigMutation(c.config, OpUpdate)
	return &WinConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WinConfigClient) UpdateOne(wc *WinConfig) *WinConfigUpdateOne {
	mutation := newWinConfigMutation(c.config, OpUpdateOne, withWinConfig(wc))
	return &WinConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WinConfigClient) UpdateOneID(id int32) *WinConfigUpdateOne {
	mutation := newWinConfigMutation(c.config, OpUpdateOne, withWinConfigID(id))
	return &WinConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WinConfig.
func (c *WinConfigClient) Delete() *WinConfigDelete {
	mutation := newWinConfigMutation(c.config, OpDelete)
	return &WinConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WinConfigClient) DeleteOne(wc *WinConfig) *WinConfigDeleteOne {
	return c.DeleteOneID(wc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WinConfigClient) DeleteOneID(id int32) *WinConfigDeleteOne {
	builder := c.Delete().Where(winconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WinConfigDeleteOne{builder}
}

// Query returns a query builder for WinConfig.
func (c *WinConfigClient) Query() *WinConfigQuery {
	return &WinConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWinConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a WinConfig entity by its id.
func (c *WinConfigClient) Get(ctx context.Context, id int32) (*WinConfig, error) {
	return c.Query().Where(winconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WinConfigClient) GetX(ctx context.Context, id int32) *WinConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WinConfigClient) Hooks() []Hook {
	return c.hooks.WinConfig
}

// Interceptors returns the client interceptors.
func (c *WinConfigClient) Interceptors() []Interceptor {
	inters := c.inters.WinConfig
	return append(inters[:len(inters):len(inters)], winconfig.Interceptors[:]...)
}

func (c *WinConfigClient) mutate(ctx context.Context, m *WinConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WinConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WinConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WinConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WinConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WinConfig mutation op: %q", m.Op())
	}
}

// WinDictClient is a client for the WinDict schema.
type WinDictClient struct {
	config
}

// CreateManyOnConflict by WinDictCreate slice
func (c *WinDictClient) CreateManyOnConflict(ctx context.Context, objs []*WinDictCreate, extra string, ignore bool) error {
	tx, err := c.config.driver.Tx(ctx)
	if err != nil {
		return err
	}
	sIndex := 0
	if objs[0].mutation.id == nil {
		sIndex = 1
	}
	//columns := windict.Columns[sIndex:]
	var columns []string
	//inserter := sql.Insert(windict.Table).Columns(columns...)
	inserter := sql.Insert(windict.Table)
	for i, obj := range objs {
		//obj.defaults()

		values := []interface{}{}
		_, spec := obj.createSpec()
		if sIndex == 0 {
			values = append(values, spec.ID.Value)
			if i == 0 {
				columns = append(columns, spec.ID.Column)
			}
		}
		for _, field := range spec.Fields {
			values = append(values, field.Value)
			if i == 0 {
				columns = append(columns, field.Column)
			}
		}
		if len(values) != len(columns) {
			//return errors.New("CreateManyOnConflict windict: Columns length not match")
		}
		inserter.Values(values...)
	}
	inserter.Columns(columns...)
	var res sql.Result
	sql, args := inserter.Query()
	if ignore {
		sql = strings.Replace(sql, "INSERT INTO", "INSERT IGNORE INTO", 1)
	}
	sql = sql + " " + extra
	if err := tx.Exec(ctx, sql, args, &res); err != nil {
		if err_roll := tx.Rollback(); err_roll != nil {
			return errors.New(err.Error() + "\n" + err_roll.Error())
		}
		return err
	}
	return tx.Commit()
}

// NewWinDictClient returns a client for the WinDict from the given config.
func NewWinDictClient(c config) *WinDictClient {
	return &WinDictClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `windict.Hooks(f(g(h())))`.
func (c *WinDictClient) Use(hooks ...Hook) {
	c.hooks.WinDict = append(c.hooks.WinDict, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `windict.Intercept(f(g(h())))`.
func (c *WinDictClient) Intercept(interceptors ...Interceptor) {
	c.inters.WinDict = append(c.inters.WinDict, interceptors...)
}

// Create returns a builder for creating a WinDict entity.
func (c *WinDictClient) Create() *WinDictCreate {
	mutation := newWinDictMutation(c.config, OpCreate)
	return &WinDictCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WinDict entities.
func (c *WinDictClient) CreateBulk(builders ...*WinDictCreate) *WinDictCreateBulk {
	return &WinDictCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WinDict.
func (c *WinDictClient) Update() *WinDictUpdate {
	mutation := newWinDictMutation(c.config, OpUpdate)
	return &WinDictUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WinDictClient) UpdateOne(wd *WinDict) *WinDictUpdateOne {
	mutation := newWinDictMutation(c.config, OpUpdateOne, withWinDict(wd))
	return &WinDictUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WinDictClient) UpdateOneID(id int32) *WinDictUpdateOne {
	mutation := newWinDictMutation(c.config, OpUpdateOne, withWinDictID(id))
	return &WinDictUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WinDict.
func (c *WinDictClient) Delete() *WinDictDelete {
	mutation := newWinDictMutation(c.config, OpDelete)
	return &WinDictDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WinDictClient) DeleteOne(wd *WinDict) *WinDictDeleteOne {
	return c.DeleteOneID(wd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WinDictClient) DeleteOneID(id int32) *WinDictDeleteOne {
	builder := c.Delete().Where(windict.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WinDictDeleteOne{builder}
}

// Query returns a query builder for WinDict.
func (c *WinDictClient) Query() *WinDictQuery {
	return &WinDictQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWinDict},
		inters: c.Interceptors(),
	}
}

// Get returns a WinDict entity by its id.
func (c *WinDictClient) Get(ctx context.Context, id int32) (*WinDict, error) {
	return c.Query().Where(windict.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WinDictClient) GetX(ctx context.Context, id int32) *WinDict {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WinDictClient) Hooks() []Hook {
	return c.hooks.WinDict
}

// Interceptors returns the client interceptors.
func (c *WinDictClient) Interceptors() []Interceptor {
	return c.inters.WinDict
}

func (c *WinDictClient) mutate(ctx context.Context, m *WinDictMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WinDictCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WinDictUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WinDictUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WinDictDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WinDict mutation op: %q", m.Op())
	}
}

// WinDictItemClient is a client for the WinDictItem schema.
type WinDictItemClient struct {
	config
}

// CreateManyOnConflict by WinDictItemCreate slice
func (c *WinDictItemClient) CreateManyOnConflict(ctx context.Context, objs []*WinDictItemCreate, extra string, ignore bool) error {
	tx, err := c.config.driver.Tx(ctx)
	if err != nil {
		return err
	}
	sIndex := 0
	if objs[0].mutation.id == nil {
		sIndex = 1
	}
	//columns := windictitem.Columns[sIndex:]
	var columns []string
	//inserter := sql.Insert(windictitem.Table).Columns(columns...)
	inserter := sql.Insert(windictitem.Table)
	for i, obj := range objs {
		//obj.defaults()

		values := []interface{}{}
		_, spec := obj.createSpec()
		if sIndex == 0 {
			values = append(values, spec.ID.Value)
			if i == 0 {
				columns = append(columns, spec.ID.Column)
			}
		}
		for _, field := range spec.Fields {
			values = append(values, field.Value)
			if i == 0 {
				columns = append(columns, field.Column)
			}
		}
		if len(values) != len(columns) {
			//return errors.New("CreateManyOnConflict windictitem: Columns length not match")
		}
		inserter.Values(values...)
	}
	inserter.Columns(columns...)
	var res sql.Result
	sql, args := inserter.Query()
	if ignore {
		sql = strings.Replace(sql, "INSERT INTO", "INSERT IGNORE INTO", 1)
	}
	sql = sql + " " + extra
	if err := tx.Exec(ctx, sql, args, &res); err != nil {
		if err_roll := tx.Rollback(); err_roll != nil {
			return errors.New(err.Error() + "\n" + err_roll.Error())
		}
		return err
	}
	return tx.Commit()
}

// NewWinDictItemClient returns a client for the WinDictItem from the given config.
func NewWinDictItemClient(c config) *WinDictItemClient {
	return &WinDictItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `windictitem.Hooks(f(g(h())))`.
func (c *WinDictItemClient) Use(hooks ...Hook) {
	c.hooks.WinDictItem = append(c.hooks.WinDictItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `windictitem.Intercept(f(g(h())))`.
func (c *WinDictItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.WinDictItem = append(c.inters.WinDictItem, interceptors...)
}

// Create returns a builder for creating a WinDictItem entity.
func (c *WinDictItemClient) Create() *WinDictItemCreate {
	mutation := newWinDictItemMutation(c.config, OpCreate)
	return &WinDictItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WinDictItem entities.
func (c *WinDictItemClient) CreateBulk(builders ...*WinDictItemCreate) *WinDictItemCreateBulk {
	return &WinDictItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WinDictItem.
func (c *WinDictItemClient) Update() *WinDictItemUpdate {
	mutation := newWinDictItemMutation(c.config, OpUpdate)
	return &WinDictItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WinDictItemClient) UpdateOne(wdi *WinDictItem) *WinDictItemUpdateOne {
	mutation := newWinDictItemMutation(c.config, OpUpdateOne, withWinDictItem(wdi))
	return &WinDictItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WinDictItemClient) UpdateOneID(id int32) *WinDictItemUpdateOne {
	mutation := newWinDictItemMutation(c.config, OpUpdateOne, withWinDictItemID(id))
	return &WinDictItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WinDictItem.
func (c *WinDictItemClient) Delete() *WinDictItemDelete {
	mutation := newWinDictItemMutation(c.config, OpDelete)
	return &WinDictItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WinDictItemClient) DeleteOne(wdi *WinDictItem) *WinDictItemDeleteOne {
	return c.DeleteOneID(wdi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WinDictItemClient) DeleteOneID(id int32) *WinDictItemDeleteOne {
	builder := c.Delete().Where(windictitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WinDictItemDeleteOne{builder}
}

// Query returns a query builder for WinDictItem.
func (c *WinDictItemClient) Query() *WinDictItemQuery {
	return &WinDictItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWinDictItem},
		inters: c.Interceptors(),
	}
}

// Get returns a WinDictItem entity by its id.
func (c *WinDictItemClient) Get(ctx context.Context, id int32) (*WinDictItem, error) {
	return c.Query().Where(windictitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WinDictItemClient) GetX(ctx context.Context, id int32) *WinDictItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WinDictItemClient) Hooks() []Hook {
	return c.hooks.WinDictItem
}

// Interceptors returns the client interceptors.
func (c *WinDictItemClient) Interceptors() []Interceptor {
	return c.inters.WinDictItem
}

func (c *WinDictItemClient) mutate(ctx context.Context, m *WinDictItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WinDictItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WinDictItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WinDictItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WinDictItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WinDictItem mutation op: %q", m.Op())
	}
}

// WinGameListClient is a client for the WinGameList schema.
type WinGameListClient struct {
	config
}

// CreateManyOnConflict by WinGameListCreate slice
func (c *WinGameListClient) CreateManyOnConflict(ctx context.Context, objs []*WinGameListCreate, extra string, ignore bool) error {
	tx, err := c.config.driver.Tx(ctx)
	if err != nil {
		return err
	}
	sIndex := 0
	if objs[0].mutation.id == nil {
		sIndex = 1
	}
	//columns := wingamelist.Columns[sIndex:]
	var columns []string
	//inserter := sql.Insert(wingamelist.Table).Columns(columns...)
	inserter := sql.Insert(wingamelist.Table)
	for i, obj := range objs {
		//obj.defaults()

		values := []interface{}{}
		_, spec := obj.createSpec()
		if sIndex == 0 {
			values = append(values, spec.ID.Value)
			if i == 0 {
				columns = append(columns, spec.ID.Column)
			}
		}
		for _, field := range spec.Fields {
			values = append(values, field.Value)
			if i == 0 {
				columns = append(columns, field.Column)
			}
		}
		if len(values) != len(columns) {
			//return errors.New("CreateManyOnConflict wingamelist: Columns length not match")
		}
		inserter.Values(values...)
	}
	inserter.Columns(columns...)
	var res sql.Result
	sql, args := inserter.Query()
	if ignore {
		sql = strings.Replace(sql, "INSERT INTO", "INSERT IGNORE INTO", 1)
	}
	sql = sql + " " + extra
	if err := tx.Exec(ctx, sql, args, &res); err != nil {
		if err_roll := tx.Rollback(); err_roll != nil {
			return errors.New(err.Error() + "\n" + err_roll.Error())
		}
		return err
	}
	return tx.Commit()
}

// NewWinGameListClient returns a client for the WinGameList from the given config.
func NewWinGameListClient(c config) *WinGameListClient {
	return &WinGameListClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `wingamelist.Hooks(f(g(h())))`.
func (c *WinGameListClient) Use(hooks ...Hook) {
	c.hooks.WinGameList = append(c.hooks.WinGameList, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `wingamelist.Intercept(f(g(h())))`.
func (c *WinGameListClient) Intercept(interceptors ...Interceptor) {
	c.inters.WinGameList = append(c.inters.WinGameList, interceptors...)
}

// Create returns a builder for creating a WinGameList entity.
func (c *WinGameListClient) Create() *WinGameListCreate {
	mutation := newWinGameListMutation(c.config, OpCreate)
	return &WinGameListCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WinGameList entities.
func (c *WinGameListClient) CreateBulk(builders ...*WinGameListCreate) *WinGameListCreateBulk {
	return &WinGameListCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WinGameList.
func (c *WinGameListClient) Update() *WinGameListUpdate {
	mutation := newWinGameListMutation(c.config, OpUpdate)
	return &WinGameListUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WinGameListClient) UpdateOne(wgl *WinGameList) *WinGameListUpdateOne {
	mutation := newWinGameListMutation(c.config, OpUpdateOne, withWinGameList(wgl))
	return &WinGameListUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WinGameListClient) UpdateOneID(id int32) *WinGameListUpdateOne {
	mutation := newWinGameListMutation(c.config, OpUpdateOne, withWinGameListID(id))
	return &WinGameListUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WinGameList.
func (c *WinGameListClient) Delete() *WinGameListDelete {
	mutation := newWinGameListMutation(c.config, OpDelete)
	return &WinGameListDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WinGameListClient) DeleteOne(wgl *WinGameList) *WinGameListDeleteOne {
	return c.DeleteOneID(wgl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WinGameListClient) DeleteOneID(id int32) *WinGameListDeleteOne {
	builder := c.Delete().Where(wingamelist.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WinGameListDeleteOne{builder}
}

// Query returns a query builder for WinGameList.
func (c *WinGameListClient) Query() *WinGameListQuery {
	return &WinGameListQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWinGameList},
		inters: c.Interceptors(),
	}
}

// Get returns a WinGameList entity by its id.
func (c *WinGameListClient) Get(ctx context.Context, id int32) (*WinGameList, error) {
	return c.Query().Where(wingamelist.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WinGameListClient) GetX(ctx context.Context, id int32) *WinGameList {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WinGameListClient) Hooks() []Hook {
	return c.hooks.WinGameList
}

// Interceptors returns the client interceptors.
func (c *WinGameListClient) Interceptors() []Interceptor {
	return c.inters.WinGameList
}

func (c *WinGameListClient) mutate(ctx context.Context, m *WinGameListMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WinGameListCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WinGameListUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WinGameListUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WinGameListDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WinGameList mutation op: %q", m.Op())
	}
}

// WinGameSlotClient is a client for the WinGameSlot schema.
type WinGameSlotClient struct {
	config
}

// CreateManyOnConflict by WinGameSlotCreate slice
func (c *WinGameSlotClient) CreateManyOnConflict(ctx context.Context, objs []*WinGameSlotCreate, extra string, ignore bool) error {
	tx, err := c.config.driver.Tx(ctx)
	if err != nil {
		return err
	}
	sIndex := 0
	if objs[0].mutation.id == nil {
		sIndex = 1
	}
	//columns := wingameslot.Columns[sIndex:]
	var columns []string
	//inserter := sql.Insert(wingameslot.Table).Columns(columns...)
	inserter := sql.Insert(wingameslot.Table)
	for i, obj := range objs {
		//obj.defaults()

		values := []interface{}{}
		_, spec := obj.createSpec()
		if sIndex == 0 {
			values = append(values, spec.ID.Value)
			if i == 0 {
				columns = append(columns, spec.ID.Column)
			}
		}
		for _, field := range spec.Fields {
			values = append(values, field.Value)
			if i == 0 {
				columns = append(columns, field.Column)
			}
		}
		if len(values) != len(columns) {
			//return errors.New("CreateManyOnConflict wingameslot: Columns length not match")
		}
		inserter.Values(values...)
	}
	inserter.Columns(columns...)
	var res sql.Result
	sql, args := inserter.Query()
	if ignore {
		sql = strings.Replace(sql, "INSERT INTO", "INSERT IGNORE INTO", 1)
	}
	sql = sql + " " + extra
	if err := tx.Exec(ctx, sql, args, &res); err != nil {
		if err_roll := tx.Rollback(); err_roll != nil {
			return errors.New(err.Error() + "\n" + err_roll.Error())
		}
		return err
	}
	return tx.Commit()
}

// NewWinGameSlotClient returns a client for the WinGameSlot from the given config.
func NewWinGameSlotClient(c config) *WinGameSlotClient {
	return &WinGameSlotClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `wingameslot.Hooks(f(g(h())))`.
func (c *WinGameSlotClient) Use(hooks ...Hook) {
	c.hooks.WinGameSlot = append(c.hooks.WinGameSlot, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `wingameslot.Intercept(f(g(h())))`.
func (c *WinGameSlotClient) Intercept(interceptors ...Interceptor) {
	c.inters.WinGameSlot = append(c.inters.WinGameSlot, interceptors...)
}

// Create returns a builder for creating a WinGameSlot entity.
func (c *WinGameSlotClient) Create() *WinGameSlotCreate {
	mutation := newWinGameSlotMutation(c.config, OpCreate)
	return &WinGameSlotCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WinGameSlot entities.
func (c *WinGameSlotClient) CreateBulk(builders ...*WinGameSlotCreate) *WinGameSlotCreateBulk {
	return &WinGameSlotCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WinGameSlot.
func (c *WinGameSlotClient) Update() *WinGameSlotUpdate {
	mutation := newWinGameSlotMutation(c.config, OpUpdate)
	return &WinGameSlotUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WinGameSlotClient) UpdateOne(wgs *WinGameSlot) *WinGameSlotUpdateOne {
	mutation := newWinGameSlotMutation(c.config, OpUpdateOne, withWinGameSlot(wgs))
	return &WinGameSlotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WinGameSlotClient) UpdateOneID(id string) *WinGameSlotUpdateOne {
	mutation := newWinGameSlotMutation(c.config, OpUpdateOne, withWinGameSlotID(id))
	return &WinGameSlotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WinGameSlot.
func (c *WinGameSlotClient) Delete() *WinGameSlotDelete {
	mutation := newWinGameSlotMutation(c.config, OpDelete)
	return &WinGameSlotDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WinGameSlotClient) DeleteOne(wgs *WinGameSlot) *WinGameSlotDeleteOne {
	return c.DeleteOneID(wgs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WinGameSlotClient) DeleteOneID(id string) *WinGameSlotDeleteOne {
	builder := c.Delete().Where(wingameslot.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WinGameSlotDeleteOne{builder}
}

// Query returns a query builder for WinGameSlot.
func (c *WinGameSlotClient) Query() *WinGameSlotQuery {
	return &WinGameSlotQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWinGameSlot},
		inters: c.Interceptors(),
	}
}

// Get returns a WinGameSlot entity by its id.
func (c *WinGameSlotClient) Get(ctx context.Context, id string) (*WinGameSlot, error) {
	return c.Query().Where(wingameslot.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WinGameSlotClient) GetX(ctx context.Context, id string) *WinGameSlot {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WinGameSlotClient) Hooks() []Hook {
	return c.hooks.WinGameSlot
}

// Interceptors returns the client interceptors.
func (c *WinGameSlotClient) Interceptors() []Interceptor {
	inters := c.inters.WinGameSlot
	return append(inters[:len(inters):len(inters)], wingameslot.Interceptors[:]...)
}

func (c *WinGameSlotClient) mutate(ctx context.Context, m *WinGameSlotMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WinGameSlotCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WinGameSlotUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WinGameSlotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WinGameSlotDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WinGameSlot mutation op: %q", m.Op())
	}
}

// WinPlatListClient is a client for the WinPlatList schema.
type WinPlatListClient struct {
	config
}

// CreateManyOnConflict by WinPlatListCreate slice
func (c *WinPlatListClient) CreateManyOnConflict(ctx context.Context, objs []*WinPlatListCreate, extra string, ignore bool) error {
	tx, err := c.config.driver.Tx(ctx)
	if err != nil {
		return err
	}
	sIndex := 0
	if objs[0].mutation.id == nil {
		sIndex = 1
	}
	//columns := winplatlist.Columns[sIndex:]
	var columns []string
	//inserter := sql.Insert(winplatlist.Table).Columns(columns...)
	inserter := sql.Insert(winplatlist.Table)
	for i, obj := range objs {
		//obj.defaults()

		values := []interface{}{}
		_, spec := obj.createSpec()
		if sIndex == 0 {
			values = append(values, spec.ID.Value)
			if i == 0 {
				columns = append(columns, spec.ID.Column)
			}
		}
		for _, field := range spec.Fields {
			values = append(values, field.Value)
			if i == 0 {
				columns = append(columns, field.Column)
			}
		}
		if len(values) != len(columns) {
			//return errors.New("CreateManyOnConflict winplatlist: Columns length not match")
		}
		inserter.Values(values...)
	}
	inserter.Columns(columns...)
	var res sql.Result
	sql, args := inserter.Query()
	if ignore {
		sql = strings.Replace(sql, "INSERT INTO", "INSERT IGNORE INTO", 1)
	}
	sql = sql + " " + extra
	if err := tx.Exec(ctx, sql, args, &res); err != nil {
		if err_roll := tx.Rollback(); err_roll != nil {
			return errors.New(err.Error() + "\n" + err_roll.Error())
		}
		return err
	}
	return tx.Commit()
}

// NewWinPlatListClient returns a client for the WinPlatList from the given config.
func NewWinPlatListClient(c config) *WinPlatListClient {
	return &WinPlatListClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `winplatlist.Hooks(f(g(h())))`.
func (c *WinPlatListClient) Use(hooks ...Hook) {
	c.hooks.WinPlatList = append(c.hooks.WinPlatList, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `winplatlist.Intercept(f(g(h())))`.
func (c *WinPlatListClient) Intercept(interceptors ...Interceptor) {
	c.inters.WinPlatList = append(c.inters.WinPlatList, interceptors...)
}

// Create returns a builder for creating a WinPlatList entity.
func (c *WinPlatListClient) Create() *WinPlatListCreate {
	mutation := newWinPlatListMutation(c.config, OpCreate)
	return &WinPlatListCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WinPlatList entities.
func (c *WinPlatListClient) CreateBulk(builders ...*WinPlatListCreate) *WinPlatListCreateBulk {
	return &WinPlatListCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WinPlatList.
func (c *WinPlatListClient) Update() *WinPlatListUpdate {
	mutation := newWinPlatListMutation(c.config, OpUpdate)
	return &WinPlatListUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WinPlatListClient) UpdateOne(wpl *WinPlatList) *WinPlatListUpdateOne {
	mutation := newWinPlatListMutation(c.config, OpUpdateOne, withWinPlatList(wpl))
	return &WinPlatListUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WinPlatListClient) UpdateOneID(id int32) *WinPlatListUpdateOne {
	mutation := newWinPlatListMutation(c.config, OpUpdateOne, withWinPlatListID(id))
	return &WinPlatListUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WinPlatList.
func (c *WinPlatListClient) Delete() *WinPlatListDelete {
	mutation := newWinPlatListMutation(c.config, OpDelete)
	return &WinPlatListDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WinPlatListClient) DeleteOne(wpl *WinPlatList) *WinPlatListDeleteOne {
	return c.DeleteOneID(wpl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WinPlatListClient) DeleteOneID(id int32) *WinPlatListDeleteOne {
	builder := c.Delete().Where(winplatlist.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WinPlatListDeleteOne{builder}
}

// Query returns a query builder for WinPlatList.
func (c *WinPlatListClient) Query() *WinPlatListQuery {
	return &WinPlatListQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWinPlatList},
		inters: c.Interceptors(),
	}
}

// Get returns a WinPlatList entity by its id.
func (c *WinPlatListClient) Get(ctx context.Context, id int32) (*WinPlatList, error) {
	return c.Query().Where(winplatlist.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WinPlatListClient) GetX(ctx context.Context, id int32) *WinPlatList {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WinPlatListClient) Hooks() []Hook {
	return c.hooks.WinPlatList
}

// Interceptors returns the client interceptors.
func (c *WinPlatListClient) Interceptors() []Interceptor {
	inters := c.inters.WinPlatList
	return append(inters[:len(inters):len(inters)], winplatlist.Interceptors[:]...)
}

func (c *WinPlatListClient) mutate(ctx context.Context, m *WinPlatListMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WinPlatListCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WinPlatListUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WinPlatListUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WinPlatListDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WinPlatList mutation op: %q", m.Op())
	}
}

// WinUserClient is a client for the WinUser schema.
type WinUserClient struct {
	config
}

// CreateManyOnConflict by WinUserCreate slice
func (c *WinUserClient) CreateManyOnConflict(ctx context.Context, objs []*WinUserCreate, extra string, ignore bool) error {
	tx, err := c.config.driver.Tx(ctx)
	if err != nil {
		return err
	}
	sIndex := 0
	if objs[0].mutation.id == nil {
		sIndex = 1
	}
	//columns := winuser.Columns[sIndex:]
	var columns []string
	//inserter := sql.Insert(winuser.Table).Columns(columns...)
	inserter := sql.Insert(winuser.Table)
	for i, obj := range objs {
		//obj.defaults()

		values := []interface{}{}
		_, spec := obj.createSpec()
		if sIndex == 0 {
			values = append(values, spec.ID.Value)
			if i == 0 {
				columns = append(columns, spec.ID.Column)
			}
		}
		for _, field := range spec.Fields {
			values = append(values, field.Value)
			if i == 0 {
				columns = append(columns, field.Column)
			}
		}
		if len(values) != len(columns) {
			//return errors.New("CreateManyOnConflict winuser: Columns length not match")
		}
		inserter.Values(values...)
	}
	inserter.Columns(columns...)
	var res sql.Result
	sql, args := inserter.Query()
	if ignore {
		sql = strings.Replace(sql, "INSERT INTO", "INSERT IGNORE INTO", 1)
	}
	sql = sql + " " + extra
	if err := tx.Exec(ctx, sql, args, &res); err != nil {
		if err_roll := tx.Rollback(); err_roll != nil {
			return errors.New(err.Error() + "\n" + err_roll.Error())
		}
		return err
	}
	return tx.Commit()
}

// NewWinUserClient returns a client for the WinUser from the given config.
func NewWinUserClient(c config) *WinUserClient {
	return &WinUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `winuser.Hooks(f(g(h())))`.
func (c *WinUserClient) Use(hooks ...Hook) {
	c.hooks.WinUser = append(c.hooks.WinUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `winuser.Intercept(f(g(h())))`.
func (c *WinUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.WinUser = append(c.inters.WinUser, interceptors...)
}

// Create returns a builder for creating a WinUser entity.
func (c *WinUserClient) Create() *WinUserCreate {
	mutation := newWinUserMutation(c.config, OpCreate)
	return &WinUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WinUser entities.
func (c *WinUserClient) CreateBulk(builders ...*WinUserCreate) *WinUserCreateBulk {
	return &WinUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WinUser.
func (c *WinUserClient) Update() *WinUserUpdate {
	mutation := newWinUserMutation(c.config, OpUpdate)
	return &WinUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WinUserClient) UpdateOne(wu *WinUser) *WinUserUpdateOne {
	mutation := newWinUserMutation(c.config, OpUpdateOne, withWinUser(wu))
	return &WinUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WinUserClient) UpdateOneID(id int32) *WinUserUpdateOne {
	mutation := newWinUserMutation(c.config, OpUpdateOne, withWinUserID(id))
	return &WinUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WinUser.
func (c *WinUserClient) Delete() *WinUserDelete {
	mutation := newWinUserMutation(c.config, OpDelete)
	return &WinUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WinUserClient) DeleteOne(wu *WinUser) *WinUserDeleteOne {
	return c.DeleteOneID(wu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WinUserClient) DeleteOneID(id int32) *WinUserDeleteOne {
	builder := c.Delete().Where(winuser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WinUserDeleteOne{builder}
}

// Query returns a query builder for WinUser.
func (c *WinUserClient) Query() *WinUserQuery {
	return &WinUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWinUser},
		inters: c.Interceptors(),
	}
}

// Get returns a WinUser entity by its id.
func (c *WinUserClient) Get(ctx context.Context, id int32) (*WinUser, error) {
	return c.Query().Where(winuser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WinUserClient) GetX(ctx context.Context, id int32) *WinUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WinUserClient) Hooks() []Hook {
	return c.hooks.WinUser
}

// Interceptors returns the client interceptors.
func (c *WinUserClient) Interceptors() []Interceptor {
	return c.inters.WinUser
}

func (c *WinUserClient) mutate(ctx context.Context, m *WinUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WinUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WinUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WinUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WinUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WinUser mutation op: %q", m.Op())
	}
}

// WinUserWalletClient is a client for the WinUserWallet schema.
type WinUserWalletClient struct {
	config
}

// CreateManyOnConflict by WinUserWalletCreate slice
func (c *WinUserWalletClient) CreateManyOnConflict(ctx context.Context, objs []*WinUserWalletCreate, extra string, ignore bool) error {
	tx, err := c.config.driver.Tx(ctx)
	if err != nil {
		return err
	}
	sIndex := 0
	if objs[0].mutation.id == nil {
		sIndex = 1
	}
	//columns := winuserwallet.Columns[sIndex:]
	var columns []string
	//inserter := sql.Insert(winuserwallet.Table).Columns(columns...)
	inserter := sql.Insert(winuserwallet.Table)
	for i, obj := range objs {
		//obj.defaults()

		values := []interface{}{}
		_, spec := obj.createSpec()
		if sIndex == 0 {
			values = append(values, spec.ID.Value)
			if i == 0 {
				columns = append(columns, spec.ID.Column)
			}
		}
		for _, field := range spec.Fields {
			values = append(values, field.Value)
			if i == 0 {
				columns = append(columns, field.Column)
			}
		}
		if len(values) != len(columns) {
			//return errors.New("CreateManyOnConflict winuserwallet: Columns length not match")
		}
		inserter.Values(values...)
	}
	inserter.Columns(columns...)
	var res sql.Result
	sql, args := inserter.Query()
	if ignore {
		sql = strings.Replace(sql, "INSERT INTO", "INSERT IGNORE INTO", 1)
	}
	sql = sql + " " + extra
	if err := tx.Exec(ctx, sql, args, &res); err != nil {
		if err_roll := tx.Rollback(); err_roll != nil {
			return errors.New(err.Error() + "\n" + err_roll.Error())
		}
		return err
	}
	return tx.Commit()
}

// NewWinUserWalletClient returns a client for the WinUserWallet from the given config.
func NewWinUserWalletClient(c config) *WinUserWalletClient {
	return &WinUserWalletClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `winuserwallet.Hooks(f(g(h())))`.
func (c *WinUserWalletClient) Use(hooks ...Hook) {
	c.hooks.WinUserWallet = append(c.hooks.WinUserWallet, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `winuserwallet.Intercept(f(g(h())))`.
func (c *WinUserWalletClient) Intercept(interceptors ...Interceptor) {
	c.inters.WinUserWallet = append(c.inters.WinUserWallet, interceptors...)
}

// Create returns a builder for creating a WinUserWallet entity.
func (c *WinUserWalletClient) Create() *WinUserWalletCreate {
	mutation := newWinUserWalletMutation(c.config, OpCreate)
	return &WinUserWalletCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WinUserWallet entities.
func (c *WinUserWalletClient) CreateBulk(builders ...*WinUserWalletCreate) *WinUserWalletCreateBulk {
	return &WinUserWalletCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WinUserWallet.
func (c *WinUserWalletClient) Update() *WinUserWalletUpdate {
	mutation := newWinUserWalletMutation(c.config, OpUpdate)
	return &WinUserWalletUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WinUserWalletClient) UpdateOne(wuw *WinUserWallet) *WinUserWalletUpdateOne {
	mutation := newWinUserWalletMutation(c.config, OpUpdateOne, withWinUserWallet(wuw))
	return &WinUserWalletUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WinUserWalletClient) UpdateOneID(id int32) *WinUserWalletUpdateOne {
	mutation := newWinUserWalletMutation(c.config, OpUpdateOne, withWinUserWalletID(id))
	return &WinUserWalletUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WinUserWallet.
func (c *WinUserWalletClient) Delete() *WinUserWalletDelete {
	mutation := newWinUserWalletMutation(c.config, OpDelete)
	return &WinUserWalletDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WinUserWalletClient) DeleteOne(wuw *WinUserWallet) *WinUserWalletDeleteOne {
	return c.DeleteOneID(wuw.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WinUserWalletClient) DeleteOneID(id int32) *WinUserWalletDeleteOne {
	builder := c.Delete().Where(winuserwallet.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WinUserWalletDeleteOne{builder}
}

// Query returns a query builder for WinUserWallet.
func (c *WinUserWalletClient) Query() *WinUserWalletQuery {
	return &WinUserWalletQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWinUserWallet},
		inters: c.Interceptors(),
	}
}

// Get returns a WinUserWallet entity by its id.
func (c *WinUserWalletClient) Get(ctx context.Context, id int32) (*WinUserWallet, error) {
	return c.Query().Where(winuserwallet.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WinUserWalletClient) GetX(ctx context.Context, id int32) *WinUserWallet {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WinUserWalletClient) Hooks() []Hook {
	return c.hooks.WinUserWallet
}

// Interceptors returns the client interceptors.
func (c *WinUserWalletClient) Interceptors() []Interceptor {
	return c.inters.WinUserWallet
}

func (c *WinUserWalletClient) mutate(ctx context.Context, m *WinUserWalletMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WinUserWalletCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WinUserWalletUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WinUserWalletUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WinUserWalletDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WinUserWallet mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Common, WinBetslip, WinBetslipsDetail, WinCoinLog, WinConfig, WinDict,
		WinDictItem, WinGameList, WinGameSlot, WinPlatList, WinUser,
		WinUserWallet []ent.Hook
	}
	inters struct {
		Common, WinBetslip, WinBetslipsDetail, WinCoinLog, WinConfig, WinDict,
		WinDictItem, WinGameList, WinGameSlot, WinPlatList, WinUser,
		WinUserWallet []ent.Interceptor
	}
)
