// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"gitlab.skig.tech/zero-core/common/zorm/model"
)

func newWinUser(db *gorm.DB, opts ...gen.DOOption) winUser {
	_winUser := winUser{}

	_winUser.winUserDo.UseDB(db, opts...)
	_winUser.winUserDo.UseModel(&model.WinUser{})

	tableName := _winUser.winUserDo.TableName()
	_winUser.ALL = field.NewAsterisk(tableName)
	_winUser.ID = field.NewInt64(tableName, "id")
	_winUser.Username = field.NewString(tableName, "username")
	_winUser.MerchantID = field.NewInt64(tableName, "merchant_id")
	_winUser.Avatar = field.NewString(tableName, "avatar")
	_winUser.Fcoin = field.NewField(tableName, "fcoin")
	_winUser.CoinCommission = field.NewField(tableName, "coin_commission")
	_winUser.LevelID = field.NewInt64(tableName, "level_id")
	_winUser.Role = field.NewInt64(tableName, "role")
	_winUser.IsPromoter = field.NewInt64(tableName, "is_promoter")
	_winUser.Flag = field.NewInt64(tableName, "flag")
	_winUser.RealName = field.NewString(tableName, "real_name")
	_winUser.Signature = field.NewString(tableName, "signature")
	_winUser.Birthday = field.NewString(tableName, "birthday")
	_winUser.AreaCode = field.NewString(tableName, "area_code")
	_winUser.Mobile = field.NewString(tableName, "mobile")
	_winUser.Email = field.NewString(tableName, "email")
	_winUser.Sex = field.NewInt64(tableName, "sex")
	_winUser.BindBank = field.NewInt64(tableName, "bind_bank")
	_winUser.Address = field.NewString(tableName, "address")
	_winUser.Score = field.NewInt64(tableName, "score")
	_winUser.PromoCode = field.NewString(tableName, "promo_code")
	_winUser.SupUid1 = field.NewInt64(tableName, "sup_uid_1")
	_winUser.SupUsername1 = field.NewString(tableName, "sup_username_1")
	_winUser.SupUid2 = field.NewInt64(tableName, "sup_uid_2")
	_winUser.SupUid3 = field.NewInt64(tableName, "sup_uid_3")
	_winUser.SupUid4 = field.NewInt64(tableName, "sup_uid_4")
	_winUser.SupUid5 = field.NewInt64(tableName, "sup_uid_5")
	_winUser.SupUid6 = field.NewInt64(tableName, "sup_uid_6")
	_winUser.SupUIDTop = field.NewInt64(tableName, "sup_uid_top")
	_winUser.SupUsernameTop = field.NewString(tableName, "sup_username_top")
	_winUser.SupLevelTop = field.NewInt64(tableName, "sup_level_top")
	_winUser.PasswordHash = field.NewString(tableName, "password_hash")
	_winUser.PasswordCoin = field.NewString(tableName, "password_coin")
	_winUser.IP = field.NewString(tableName, "ip")
	_winUser.IPRegion = field.NewString(tableName, "ip_region")
	_winUser.ThirdLoginType = field.NewString(tableName, "third_login_type")
	_winUser.FreezeCause = field.NewString(tableName, "freeze_cause")
	_winUser.FreezeAt = field.NewInt64(tableName, "freeze_at")
	_winUser.OperatorName = field.NewString(tableName, "operator_name")
	_winUser.CreatedName = field.NewString(tableName, "created_name")
	_winUser.Status = field.NewInt64(tableName, "status")
	_winUser.LastLoginIP = field.NewString(tableName, "last_login_ip")
	_winUser.LastLoginIPRegion = field.NewString(tableName, "last_login_ip_region")
	_winUser.LastLoginTime = field.NewInt64(tableName, "last_login_time")
	_winUser.LastLoginDeviceID = field.NewString(tableName, "last_login_device_id")
	_winUser.CreatedAt = field.NewInt64(tableName, "created_at")
	_winUser.UpdatedAt = field.NewInt64(tableName, "updated_at")

	_winUser.fillFieldMap()

	return _winUser
}

type winUser struct {
	winUserDo

	ALL               field.Asterisk
	ID                field.Int64
	Username          field.String // 用户名
	MerchantID        field.Int64  // 商户id
	Avatar            field.String // 头像
	Fcoin             field.Field  // 冻结金额
	CoinCommission    field.Field  // 佣金可提现金额
	LevelID           field.Int64  // 会员等级
	Role              field.Int64  // 角色:0-会员 1-代理 2-总代理 4-测试
	IsPromoter        field.Int64  // 是否推广:0-不是 1-是
	Flag              field.Int64  // 会员旗
	RealName          field.String // 真实姓名
	Signature         field.String // 个性签名
	Birthday          field.String // 生日
	AreaCode          field.String // 区号
	Mobile            field.String // 手机号码
	Email             field.String // 邮箱
	Sex               field.Int64  // 性别:1-男 0-女 2-未知
	BindBank          field.Int64  // 是否绑定银行卡:1-已绑定 0-未绑定
	Address           field.String // 家庭地址
	Score             field.Int64  // 积分
	PromoCode         field.String // 推广码
	SupUid1           field.Int64  // 上1级代理
	SupUsername1      field.String // 上1级代理
	SupUid2           field.Int64  // 上2级代理
	SupUid3           field.Int64  // 上3级代理
	SupUid4           field.Int64  // 上4级代理
	SupUid5           field.Int64  // 上5级代理
	SupUid6           field.Int64  // 上6级代理
	SupUIDTop         field.Int64  // 顶级推广用户名
	SupUsernameTop    field.String // 顶级推广用户名
	SupLevelTop       field.Int64  // 顶级推广层级
	PasswordHash      field.String // 登录密码
	PasswordCoin      field.String // 取款密码
	IP                field.String // IP地址
	IPRegion          field.String // IP归属地
	ThirdLoginType    field.String // 三方登陆类型
	FreezeCause       field.String
	FreezeAt          field.Int64  // 冻结时间
	OperatorName      field.String // 操作人姓名
	CreatedName       field.String // 创建人
	Status            field.Int64  // 状态:10-正常 9-冻结 8-删除
	LastLoginIP       field.String // 最后登陆ip
	LastLoginIPRegion field.String // 最后登录IP归属地
	LastLoginTime     field.Int64  // 最后登陆时间
	LastLoginDeviceID field.String // 最后登录设备id
	CreatedAt         field.Int64
	UpdatedAt         field.Int64

	fieldMap map[string]field.Expr
}

func (w winUser) Table(newTableName string) *winUser {
	w.winUserDo.UseTable(newTableName)
	return w.updateTableName(newTableName)
}

func (w winUser) As(alias string) *winUser {
	w.winUserDo.DO = *(w.winUserDo.As(alias).(*gen.DO))
	return w.updateTableName(alias)
}

func (w *winUser) updateTableName(table string) *winUser {
	w.ALL = field.NewAsterisk(table)
	w.ID = field.NewInt64(table, "id")
	w.Username = field.NewString(table, "username")
	w.MerchantID = field.NewInt64(table, "merchant_id")
	w.Avatar = field.NewString(table, "avatar")
	w.Fcoin = field.NewField(table, "fcoin")
	w.CoinCommission = field.NewField(table, "coin_commission")
	w.LevelID = field.NewInt64(table, "level_id")
	w.Role = field.NewInt64(table, "role")
	w.IsPromoter = field.NewInt64(table, "is_promoter")
	w.Flag = field.NewInt64(table, "flag")
	w.RealName = field.NewString(table, "real_name")
	w.Signature = field.NewString(table, "signature")
	w.Birthday = field.NewString(table, "birthday")
	w.AreaCode = field.NewString(table, "area_code")
	w.Mobile = field.NewString(table, "mobile")
	w.Email = field.NewString(table, "email")
	w.Sex = field.NewInt64(table, "sex")
	w.BindBank = field.NewInt64(table, "bind_bank")
	w.Address = field.NewString(table, "address")
	w.Score = field.NewInt64(table, "score")
	w.PromoCode = field.NewString(table, "promo_code")
	w.SupUid1 = field.NewInt64(table, "sup_uid_1")
	w.SupUsername1 = field.NewString(table, "sup_username_1")
	w.SupUid2 = field.NewInt64(table, "sup_uid_2")
	w.SupUid3 = field.NewInt64(table, "sup_uid_3")
	w.SupUid4 = field.NewInt64(table, "sup_uid_4")
	w.SupUid5 = field.NewInt64(table, "sup_uid_5")
	w.SupUid6 = field.NewInt64(table, "sup_uid_6")
	w.SupUIDTop = field.NewInt64(table, "sup_uid_top")
	w.SupUsernameTop = field.NewString(table, "sup_username_top")
	w.SupLevelTop = field.NewInt64(table, "sup_level_top")
	w.PasswordHash = field.NewString(table, "password_hash")
	w.PasswordCoin = field.NewString(table, "password_coin")
	w.IP = field.NewString(table, "ip")
	w.IPRegion = field.NewString(table, "ip_region")
	w.ThirdLoginType = field.NewString(table, "third_login_type")
	w.FreezeCause = field.NewString(table, "freeze_cause")
	w.FreezeAt = field.NewInt64(table, "freeze_at")
	w.OperatorName = field.NewString(table, "operator_name")
	w.CreatedName = field.NewString(table, "created_name")
	w.Status = field.NewInt64(table, "status")
	w.LastLoginIP = field.NewString(table, "last_login_ip")
	w.LastLoginIPRegion = field.NewString(table, "last_login_ip_region")
	w.LastLoginTime = field.NewInt64(table, "last_login_time")
	w.LastLoginDeviceID = field.NewString(table, "last_login_device_id")
	w.CreatedAt = field.NewInt64(table, "created_at")
	w.UpdatedAt = field.NewInt64(table, "updated_at")

	w.fillFieldMap()

	return w
}

func (w *winUser) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := w.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (w *winUser) fillFieldMap() {
	w.fieldMap = make(map[string]field.Expr, 47)
	w.fieldMap["id"] = w.ID
	w.fieldMap["username"] = w.Username
	w.fieldMap["merchant_id"] = w.MerchantID
	w.fieldMap["avatar"] = w.Avatar
	w.fieldMap["fcoin"] = w.Fcoin
	w.fieldMap["coin_commission"] = w.CoinCommission
	w.fieldMap["level_id"] = w.LevelID
	w.fieldMap["role"] = w.Role
	w.fieldMap["is_promoter"] = w.IsPromoter
	w.fieldMap["flag"] = w.Flag
	w.fieldMap["real_name"] = w.RealName
	w.fieldMap["signature"] = w.Signature
	w.fieldMap["birthday"] = w.Birthday
	w.fieldMap["area_code"] = w.AreaCode
	w.fieldMap["mobile"] = w.Mobile
	w.fieldMap["email"] = w.Email
	w.fieldMap["sex"] = w.Sex
	w.fieldMap["bind_bank"] = w.BindBank
	w.fieldMap["address"] = w.Address
	w.fieldMap["score"] = w.Score
	w.fieldMap["promo_code"] = w.PromoCode
	w.fieldMap["sup_uid_1"] = w.SupUid1
	w.fieldMap["sup_username_1"] = w.SupUsername1
	w.fieldMap["sup_uid_2"] = w.SupUid2
	w.fieldMap["sup_uid_3"] = w.SupUid3
	w.fieldMap["sup_uid_4"] = w.SupUid4
	w.fieldMap["sup_uid_5"] = w.SupUid5
	w.fieldMap["sup_uid_6"] = w.SupUid6
	w.fieldMap["sup_uid_top"] = w.SupUIDTop
	w.fieldMap["sup_username_top"] = w.SupUsernameTop
	w.fieldMap["sup_level_top"] = w.SupLevelTop
	w.fieldMap["password_hash"] = w.PasswordHash
	w.fieldMap["password_coin"] = w.PasswordCoin
	w.fieldMap["ip"] = w.IP
	w.fieldMap["ip_region"] = w.IPRegion
	w.fieldMap["third_login_type"] = w.ThirdLoginType
	w.fieldMap["freeze_cause"] = w.FreezeCause
	w.fieldMap["freeze_at"] = w.FreezeAt
	w.fieldMap["operator_name"] = w.OperatorName
	w.fieldMap["created_name"] = w.CreatedName
	w.fieldMap["status"] = w.Status
	w.fieldMap["last_login_ip"] = w.LastLoginIP
	w.fieldMap["last_login_ip_region"] = w.LastLoginIPRegion
	w.fieldMap["last_login_time"] = w.LastLoginTime
	w.fieldMap["last_login_device_id"] = w.LastLoginDeviceID
	w.fieldMap["created_at"] = w.CreatedAt
	w.fieldMap["updated_at"] = w.UpdatedAt
}

func (w winUser) clone(db *gorm.DB) winUser {
	w.winUserDo.ReplaceConnPool(db.Statement.ConnPool)
	return w
}

func (w winUser) replaceDB(db *gorm.DB) winUser {
	w.winUserDo.ReplaceDB(db)
	return w
}

type winUserDo struct{ gen.DO }

type IWinUserDo interface {
	gen.SubQuery
	Debug() IWinUserDo
	WithContext(ctx context.Context) IWinUserDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IWinUserDo
	WriteDB() IWinUserDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IWinUserDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IWinUserDo
	Not(conds ...gen.Condition) IWinUserDo
	Or(conds ...gen.Condition) IWinUserDo
	Select(conds ...field.Expr) IWinUserDo
	Where(conds ...gen.Condition) IWinUserDo
	Order(conds ...field.Expr) IWinUserDo
	Distinct(cols ...field.Expr) IWinUserDo
	Omit(cols ...field.Expr) IWinUserDo
	Join(table schema.Tabler, on ...field.Expr) IWinUserDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IWinUserDo
	RightJoin(table schema.Tabler, on ...field.Expr) IWinUserDo
	Group(cols ...field.Expr) IWinUserDo
	Having(conds ...gen.Condition) IWinUserDo
	Limit(limit int) IWinUserDo
	Offset(offset int) IWinUserDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IWinUserDo
	Unscoped() IWinUserDo
	Create(values ...*model.WinUser) error
	CreateInBatches(values []*model.WinUser, batchSize int) error
	Save(values ...*model.WinUser) error
	First() (*model.WinUser, error)
	Take() (*model.WinUser, error)
	Last() (*model.WinUser, error)
	Find() ([]*model.WinUser, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.WinUser, err error)
	FindInBatches(result *[]*model.WinUser, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.WinUser) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IWinUserDo
	Assign(attrs ...field.AssignExpr) IWinUserDo
	Joins(fields ...field.RelationField) IWinUserDo
	Preload(fields ...field.RelationField) IWinUserDo
	FirstOrInit() (*model.WinUser, error)
	FirstOrCreate() (*model.WinUser, error)
	FindByPage(offset int, limit int) (result []*model.WinUser, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IWinUserDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (w winUserDo) Debug() IWinUserDo {
	return w.withDO(w.DO.Debug())
}

func (w winUserDo) WithContext(ctx context.Context) IWinUserDo {
	return w.withDO(w.DO.WithContext(ctx))
}

func (w winUserDo) ReadDB() IWinUserDo {
	return w.Clauses(dbresolver.Read)
}

func (w winUserDo) WriteDB() IWinUserDo {
	return w.Clauses(dbresolver.Write)
}

func (w winUserDo) Session(config *gorm.Session) IWinUserDo {
	return w.withDO(w.DO.Session(config))
}

func (w winUserDo) Clauses(conds ...clause.Expression) IWinUserDo {
	return w.withDO(w.DO.Clauses(conds...))
}

func (w winUserDo) Returning(value interface{}, columns ...string) IWinUserDo {
	return w.withDO(w.DO.Returning(value, columns...))
}

func (w winUserDo) Not(conds ...gen.Condition) IWinUserDo {
	return w.withDO(w.DO.Not(conds...))
}

func (w winUserDo) Or(conds ...gen.Condition) IWinUserDo {
	return w.withDO(w.DO.Or(conds...))
}

func (w winUserDo) Select(conds ...field.Expr) IWinUserDo {
	return w.withDO(w.DO.Select(conds...))
}

func (w winUserDo) Where(conds ...gen.Condition) IWinUserDo {
	return w.withDO(w.DO.Where(conds...))
}

func (w winUserDo) Order(conds ...field.Expr) IWinUserDo {
	return w.withDO(w.DO.Order(conds...))
}

func (w winUserDo) Distinct(cols ...field.Expr) IWinUserDo {
	return w.withDO(w.DO.Distinct(cols...))
}

func (w winUserDo) Omit(cols ...field.Expr) IWinUserDo {
	return w.withDO(w.DO.Omit(cols...))
}

func (w winUserDo) Join(table schema.Tabler, on ...field.Expr) IWinUserDo {
	return w.withDO(w.DO.Join(table, on...))
}

func (w winUserDo) LeftJoin(table schema.Tabler, on ...field.Expr) IWinUserDo {
	return w.withDO(w.DO.LeftJoin(table, on...))
}

func (w winUserDo) RightJoin(table schema.Tabler, on ...field.Expr) IWinUserDo {
	return w.withDO(w.DO.RightJoin(table, on...))
}

func (w winUserDo) Group(cols ...field.Expr) IWinUserDo {
	return w.withDO(w.DO.Group(cols...))
}

func (w winUserDo) Having(conds ...gen.Condition) IWinUserDo {
	return w.withDO(w.DO.Having(conds...))
}

func (w winUserDo) Limit(limit int) IWinUserDo {
	return w.withDO(w.DO.Limit(limit))
}

func (w winUserDo) Offset(offset int) IWinUserDo {
	return w.withDO(w.DO.Offset(offset))
}

func (w winUserDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IWinUserDo {
	return w.withDO(w.DO.Scopes(funcs...))
}

func (w winUserDo) Unscoped() IWinUserDo {
	return w.withDO(w.DO.Unscoped())
}

func (w winUserDo) Create(values ...*model.WinUser) error {
	if len(values) == 0 {
		return nil
	}
	return w.DO.Create(values)
}

func (w winUserDo) CreateInBatches(values []*model.WinUser, batchSize int) error {
	return w.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (w winUserDo) Save(values ...*model.WinUser) error {
	if len(values) == 0 {
		return nil
	}
	return w.DO.Save(values)
}

func (w winUserDo) First() (*model.WinUser, error) {
	if result, err := w.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.WinUser), nil
	}
}

func (w winUserDo) Take() (*model.WinUser, error) {
	if result, err := w.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.WinUser), nil
	}
}

func (w winUserDo) Last() (*model.WinUser, error) {
	if result, err := w.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.WinUser), nil
	}
}

func (w winUserDo) Find() ([]*model.WinUser, error) {
	result, err := w.DO.Find()
	return result.([]*model.WinUser), err
}

func (w winUserDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.WinUser, err error) {
	buf := make([]*model.WinUser, 0, batchSize)
	err = w.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (w winUserDo) FindInBatches(result *[]*model.WinUser, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return w.DO.FindInBatches(result, batchSize, fc)
}

func (w winUserDo) Attrs(attrs ...field.AssignExpr) IWinUserDo {
	return w.withDO(w.DO.Attrs(attrs...))
}

func (w winUserDo) Assign(attrs ...field.AssignExpr) IWinUserDo {
	return w.withDO(w.DO.Assign(attrs...))
}

func (w winUserDo) Joins(fields ...field.RelationField) IWinUserDo {
	for _, _f := range fields {
		w = *w.withDO(w.DO.Joins(_f))
	}
	return &w
}

func (w winUserDo) Preload(fields ...field.RelationField) IWinUserDo {
	for _, _f := range fields {
		w = *w.withDO(w.DO.Preload(_f))
	}
	return &w
}

func (w winUserDo) FirstOrInit() (*model.WinUser, error) {
	if result, err := w.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.WinUser), nil
	}
}

func (w winUserDo) FirstOrCreate() (*model.WinUser, error) {
	if result, err := w.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.WinUser), nil
	}
}

func (w winUserDo) FindByPage(offset int, limit int) (result []*model.WinUser, count int64, err error) {
	result, err = w.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = w.Offset(-1).Limit(-1).Count()
	return
}

func (w winUserDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = w.Count()
	if err != nil {
		return
	}

	err = w.Offset(offset).Limit(limit).Scan(result)
	return
}

func (w winUserDo) Scan(result interface{}) (err error) {
	return w.DO.Scan(result)
}

func (w winUserDo) Delete(models ...*model.WinUser) (result gen.ResultInfo, err error) {
	return w.DO.Delete(models)
}

func (w *winUserDo) withDO(do gen.Dao) *winUserDo {
	w.DO = *do.(*gen.DO)
	return w
}
