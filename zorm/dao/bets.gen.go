// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"gitlab.skig.tech/zero-core/common/zorm/model"
)

func newBet(db *gorm.DB, opts ...gen.DOOption) bet {
	_bet := bet{}

	_bet.betDo.UseDB(db, opts...)
	_bet.betDo.UseModel(&model.Bet{})

	tableName := _bet.betDo.TableName()
	_bet.ALL = field.NewAsterisk(tableName)
	_bet.ID = field.NewInt64(tableName, "id")
	_bet.RoundID = field.NewString(tableName, "round_id")
	_bet.TransactionID = field.NewString(tableName, "transaction_id")
	_bet.GamePlatID = field.NewInt64(tableName, "game_plat_id")
	_bet.XbStatus = field.NewInt64(tableName, "xb_status")
	_bet.XbUID = field.NewInt64(tableName, "xb_uid")
	_bet.XbUsername = field.NewString(tableName, "xb_username")
	_bet.XbProfit = field.NewField(tableName, "xb_profit")
	_bet.Stake = field.NewField(tableName, "stake")
	_bet.ValidStake = field.NewField(tableName, "valid_stake")
	_bet.Payout = field.NewField(tableName, "payout")
	_bet.CoinRefund = field.NewField(tableName, "coin_refund")
	_bet.CoinBefore = field.NewField(tableName, "coin_before")
	_bet.GameID = field.NewString(tableName, "game_id")
	_bet.GameName = field.NewString(tableName, "game_name")
	_bet.AmountType = field.NewInt64(tableName, "amount_type")
	_bet.GameTypeID = field.NewString(tableName, "game_type_id")
	_bet.GameGroupID = field.NewInt64(tableName, "game_group_id")
	_bet.SportType = field.NewString(tableName, "sport_type")
	_bet.DtStarted = field.NewInt64(tableName, "dt_started")
	_bet.DtCompleted = field.NewInt64(tableName, "dt_completed")
	_bet.WinTransactionID = field.NewString(tableName, "win_transaction_id")
	_bet.BetJSON = field.NewString(tableName, "bet_json")
	_bet.RewardJSON = field.NewString(tableName, "reward_json")
	_bet.CreateTimeStr = field.NewString(tableName, "create_time_str")
	_bet.CreatedAt = field.NewInt64(tableName, "created_at")
	_bet.Diff = field.NewField(tableName, "diff")
	_bet.UpdatedAt = field.NewInt64(tableName, "updated_at")

	_bet.fillFieldMap()

	return _bet
}

type bet struct {
	betDo

	ALL              field.Asterisk
	ID               field.Int64  // 主键
	RoundID          field.String // 回合id
	TransactionID    field.String // 注单号 对应三方拉单transaction_id
	GamePlatID       field.Int64  // 游戏平台id
	XbStatus         field.Int64  // 注单状态 1:待开彩  2:完成  3: 退款
	XbUID            field.Int64  // 对应user表id
	XbUsername       field.String // 对应user表username
	XbProfit         field.Field  // 盈亏金额
	Stake            field.Field  // 投注
	ValidStake       field.Field  // 有效投注金额
	Payout           field.Field  // 派彩
	CoinRefund       field.Field  // 退款金额
	CoinBefore       field.Field  // 投注前金额
	GameID           field.String // 游戏id 对应game_list表id
	GameName         field.String // 游戏名称
	AmountType       field.Int64  // 投注方式 1:现金，2:奖金 3:免费旋转 4:活动免费旋转
	GameTypeID       field.String // 游戏子类型id 对应game_slot 表id
	GameGroupID      field.Int64  // 游戏大类类型:1-体育 2-电子 3-真人 4-捕鱼 5-棋牌 6-电竞 7-彩票 8-动物 9-快速 10-技能',
	SportType        field.String // 体育投注类型
	DtStarted        field.Int64  // 游戏开始时间
	DtCompleted      field.Int64  // 游戏结束时间
	WinTransactionID field.String // 开奖交易单号
	BetJSON          field.String // 投注原始json
	RewardJSON       field.String // 开彩原始json
	CreateTimeStr    field.String // 投注时间
	CreatedAt        field.Int64
	Diff             field.Field
	UpdatedAt        field.Int64

	fieldMap map[string]field.Expr
}

func (b bet) Table(newTableName string) *bet {
	b.betDo.UseTable(newTableName)
	return b.updateTableName(newTableName)
}

func (b bet) As(alias string) *bet {
	b.betDo.DO = *(b.betDo.As(alias).(*gen.DO))
	return b.updateTableName(alias)
}

func (b *bet) updateTableName(table string) *bet {
	b.ALL = field.NewAsterisk(table)
	b.ID = field.NewInt64(table, "id")
	b.RoundID = field.NewString(table, "round_id")
	b.TransactionID = field.NewString(table, "transaction_id")
	b.GamePlatID = field.NewInt64(table, "game_plat_id")
	b.XbStatus = field.NewInt64(table, "xb_status")
	b.XbUID = field.NewInt64(table, "xb_uid")
	b.XbUsername = field.NewString(table, "xb_username")
	b.XbProfit = field.NewField(table, "xb_profit")
	b.Stake = field.NewField(table, "stake")
	b.ValidStake = field.NewField(table, "valid_stake")
	b.Payout = field.NewField(table, "payout")
	b.CoinRefund = field.NewField(table, "coin_refund")
	b.CoinBefore = field.NewField(table, "coin_before")
	b.GameID = field.NewString(table, "game_id")
	b.GameName = field.NewString(table, "game_name")
	b.AmountType = field.NewInt64(table, "amount_type")
	b.GameTypeID = field.NewString(table, "game_type_id")
	b.GameGroupID = field.NewInt64(table, "game_group_id")
	b.SportType = field.NewString(table, "sport_type")
	b.DtStarted = field.NewInt64(table, "dt_started")
	b.DtCompleted = field.NewInt64(table, "dt_completed")
	b.WinTransactionID = field.NewString(table, "win_transaction_id")
	b.BetJSON = field.NewString(table, "bet_json")
	b.RewardJSON = field.NewString(table, "reward_json")
	b.CreateTimeStr = field.NewString(table, "create_time_str")
	b.CreatedAt = field.NewInt64(table, "created_at")
	b.Diff = field.NewField(table, "diff")
	b.UpdatedAt = field.NewInt64(table, "updated_at")

	b.fillFieldMap()

	return b
}

func (b *bet) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := b.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (b *bet) fillFieldMap() {
	b.fieldMap = make(map[string]field.Expr, 28)
	b.fieldMap["id"] = b.ID
	b.fieldMap["round_id"] = b.RoundID
	b.fieldMap["transaction_id"] = b.TransactionID
	b.fieldMap["game_plat_id"] = b.GamePlatID
	b.fieldMap["xb_status"] = b.XbStatus
	b.fieldMap["xb_uid"] = b.XbUID
	b.fieldMap["xb_username"] = b.XbUsername
	b.fieldMap["xb_profit"] = b.XbProfit
	b.fieldMap["stake"] = b.Stake
	b.fieldMap["valid_stake"] = b.ValidStake
	b.fieldMap["payout"] = b.Payout
	b.fieldMap["coin_refund"] = b.CoinRefund
	b.fieldMap["coin_before"] = b.CoinBefore
	b.fieldMap["game_id"] = b.GameID
	b.fieldMap["game_name"] = b.GameName
	b.fieldMap["amount_type"] = b.AmountType
	b.fieldMap["game_type_id"] = b.GameTypeID
	b.fieldMap["game_group_id"] = b.GameGroupID
	b.fieldMap["sport_type"] = b.SportType
	b.fieldMap["dt_started"] = b.DtStarted
	b.fieldMap["dt_completed"] = b.DtCompleted
	b.fieldMap["win_transaction_id"] = b.WinTransactionID
	b.fieldMap["bet_json"] = b.BetJSON
	b.fieldMap["reward_json"] = b.RewardJSON
	b.fieldMap["create_time_str"] = b.CreateTimeStr
	b.fieldMap["created_at"] = b.CreatedAt
	b.fieldMap["diff"] = b.Diff
	b.fieldMap["updated_at"] = b.UpdatedAt
}

func (b bet) clone(db *gorm.DB) bet {
	b.betDo.ReplaceConnPool(db.Statement.ConnPool)
	return b
}

func (b bet) replaceDB(db *gorm.DB) bet {
	b.betDo.ReplaceDB(db)
	return b
}

type betDo struct{ gen.DO }

type IBetDo interface {
	gen.SubQuery
	Debug() IBetDo
	WithContext(ctx context.Context) IBetDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IBetDo
	WriteDB() IBetDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IBetDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IBetDo
	Not(conds ...gen.Condition) IBetDo
	Or(conds ...gen.Condition) IBetDo
	Select(conds ...field.Expr) IBetDo
	Where(conds ...gen.Condition) IBetDo
	Order(conds ...field.Expr) IBetDo
	Distinct(cols ...field.Expr) IBetDo
	Omit(cols ...field.Expr) IBetDo
	Join(table schema.Tabler, on ...field.Expr) IBetDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IBetDo
	RightJoin(table schema.Tabler, on ...field.Expr) IBetDo
	Group(cols ...field.Expr) IBetDo
	Having(conds ...gen.Condition) IBetDo
	Limit(limit int) IBetDo
	Offset(offset int) IBetDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IBetDo
	Unscoped() IBetDo
	Create(values ...*model.Bet) error
	CreateInBatches(values []*model.Bet, batchSize int) error
	Save(values ...*model.Bet) error
	First() (*model.Bet, error)
	Take() (*model.Bet, error)
	Last() (*model.Bet, error)
	Find() ([]*model.Bet, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Bet, err error)
	FindInBatches(result *[]*model.Bet, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.Bet) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IBetDo
	Assign(attrs ...field.AssignExpr) IBetDo
	Joins(fields ...field.RelationField) IBetDo
	Preload(fields ...field.RelationField) IBetDo
	FirstOrInit() (*model.Bet, error)
	FirstOrCreate() (*model.Bet, error)
	FindByPage(offset int, limit int) (result []*model.Bet, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IBetDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (b betDo) Debug() IBetDo {
	return b.withDO(b.DO.Debug())
}

func (b betDo) WithContext(ctx context.Context) IBetDo {
	return b.withDO(b.DO.WithContext(ctx))
}

func (b betDo) ReadDB() IBetDo {
	return b.Clauses(dbresolver.Read)
}

func (b betDo) WriteDB() IBetDo {
	return b.Clauses(dbresolver.Write)
}

func (b betDo) Session(config *gorm.Session) IBetDo {
	return b.withDO(b.DO.Session(config))
}

func (b betDo) Clauses(conds ...clause.Expression) IBetDo {
	return b.withDO(b.DO.Clauses(conds...))
}

func (b betDo) Returning(value interface{}, columns ...string) IBetDo {
	return b.withDO(b.DO.Returning(value, columns...))
}

func (b betDo) Not(conds ...gen.Condition) IBetDo {
	return b.withDO(b.DO.Not(conds...))
}

func (b betDo) Or(conds ...gen.Condition) IBetDo {
	return b.withDO(b.DO.Or(conds...))
}

func (b betDo) Select(conds ...field.Expr) IBetDo {
	return b.withDO(b.DO.Select(conds...))
}

func (b betDo) Where(conds ...gen.Condition) IBetDo {
	return b.withDO(b.DO.Where(conds...))
}

func (b betDo) Order(conds ...field.Expr) IBetDo {
	return b.withDO(b.DO.Order(conds...))
}

func (b betDo) Distinct(cols ...field.Expr) IBetDo {
	return b.withDO(b.DO.Distinct(cols...))
}

func (b betDo) Omit(cols ...field.Expr) IBetDo {
	return b.withDO(b.DO.Omit(cols...))
}

func (b betDo) Join(table schema.Tabler, on ...field.Expr) IBetDo {
	return b.withDO(b.DO.Join(table, on...))
}

func (b betDo) LeftJoin(table schema.Tabler, on ...field.Expr) IBetDo {
	return b.withDO(b.DO.LeftJoin(table, on...))
}

func (b betDo) RightJoin(table schema.Tabler, on ...field.Expr) IBetDo {
	return b.withDO(b.DO.RightJoin(table, on...))
}

func (b betDo) Group(cols ...field.Expr) IBetDo {
	return b.withDO(b.DO.Group(cols...))
}

func (b betDo) Having(conds ...gen.Condition) IBetDo {
	return b.withDO(b.DO.Having(conds...))
}

func (b betDo) Limit(limit int) IBetDo {
	return b.withDO(b.DO.Limit(limit))
}

func (b betDo) Offset(offset int) IBetDo {
	return b.withDO(b.DO.Offset(offset))
}

func (b betDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IBetDo {
	return b.withDO(b.DO.Scopes(funcs...))
}

func (b betDo) Unscoped() IBetDo {
	return b.withDO(b.DO.Unscoped())
}

func (b betDo) Create(values ...*model.Bet) error {
	if len(values) == 0 {
		return nil
	}
	return b.DO.Create(values)
}

func (b betDo) CreateInBatches(values []*model.Bet, batchSize int) error {
	return b.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (b betDo) Save(values ...*model.Bet) error {
	if len(values) == 0 {
		return nil
	}
	return b.DO.Save(values)
}

func (b betDo) First() (*model.Bet, error) {
	if result, err := b.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Bet), nil
	}
}

func (b betDo) Take() (*model.Bet, error) {
	if result, err := b.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Bet), nil
	}
}

func (b betDo) Last() (*model.Bet, error) {
	if result, err := b.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Bet), nil
	}
}

func (b betDo) Find() ([]*model.Bet, error) {
	result, err := b.DO.Find()
	return result.([]*model.Bet), err
}

func (b betDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Bet, err error) {
	buf := make([]*model.Bet, 0, batchSize)
	err = b.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (b betDo) FindInBatches(result *[]*model.Bet, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return b.DO.FindInBatches(result, batchSize, fc)
}

func (b betDo) Attrs(attrs ...field.AssignExpr) IBetDo {
	return b.withDO(b.DO.Attrs(attrs...))
}

func (b betDo) Assign(attrs ...field.AssignExpr) IBetDo {
	return b.withDO(b.DO.Assign(attrs...))
}

func (b betDo) Joins(fields ...field.RelationField) IBetDo {
	for _, _f := range fields {
		b = *b.withDO(b.DO.Joins(_f))
	}
	return &b
}

func (b betDo) Preload(fields ...field.RelationField) IBetDo {
	for _, _f := range fields {
		b = *b.withDO(b.DO.Preload(_f))
	}
	return &b
}

func (b betDo) FirstOrInit() (*model.Bet, error) {
	if result, err := b.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Bet), nil
	}
}

func (b betDo) FirstOrCreate() (*model.Bet, error) {
	if result, err := b.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Bet), nil
	}
}

func (b betDo) FindByPage(offset int, limit int) (result []*model.Bet, count int64, err error) {
	result, err = b.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = b.Offset(-1).Limit(-1).Count()
	return
}

func (b betDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = b.Count()
	if err != nil {
		return
	}

	err = b.Offset(offset).Limit(limit).Scan(result)
	return
}

func (b betDo) Scan(result interface{}) (err error) {
	return b.DO.Scan(result)
}

func (b betDo) Delete(models ...*model.Bet) (result gen.ResultInfo, err error) {
	return b.DO.Delete(models)
}

func (b *betDo) withDO(do gen.Dao) *betDo {
	b.DO = *do.(*gen.DO)
	return b
}
